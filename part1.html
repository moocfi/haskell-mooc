<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Haskell Mooc, part 1</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="./style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div id="everything">
<nav id="TOC">
<ul>
<li><a href="#lecture-1-and-so-it-begins"><span class="toc-section-number">1</span> Lecture 1: …and so it Begins</a><ul>
<li><a href="#about-the-course"><span class="toc-section-number">1.1</span> About the course</a></li>
<li><a href="#read-these"><span class="toc-section-number">1.2</span> Read these</a></li>
<li><a href="#haskell"><span class="toc-section-number">1.3</span> Haskell</a></li>
<li><a href="#running-haskell"><span class="toc-section-number">1.4</span> Running Haskell</a></li>
<li><a href="#lets-start"><span class="toc-section-number">1.5</span> Let’s start!</a></li>
<li><a href="#expressions-and-types"><span class="toc-section-number">1.6</span> Expressions and types</a></li>
<li><a href="#the-structure-of-a-haskell-program"><span class="toc-section-number">1.7</span> The structure of a Haskell program</a></li>
<li><a href="#working-with-examples"><span class="toc-section-number">1.8</span> Working with examples</a></li>
<li><a href="#how-do-i-get-anything-done"><span class="toc-section-number">1.9</span> How do I get anything done?</a></li>
<li><a href="#all-together-now"><span class="toc-section-number">1.10</span> All together now!</a></li>
<li><a href="#a-word-about-indentation"><span class="toc-section-number">1.11</span> A word about indentation</a></li>
<li><a href="#quiz"><span class="toc-section-number">1.12</span> Quiz</a></li>
<li><a href="#working-on-the-exercises"><span class="toc-section-number">1.13</span> Working on the exercises</a></li>
<li><a href="#exercises"><span class="toc-section-number">1.14</span> Exercises</a></li>
</ul></li>
<li><a href="#lecture-2-either-you-die-a-hero"><span class="toc-section-number">2</span> Lecture 2: Either You Die a Hero…</a><ul>
<li><a href="#recursion-and-helper-functions"><span class="toc-section-number">2.1</span> Recursion and Helper Functions</a></li>
<li><a href="#guards"><span class="toc-section-number">2.2</span> Guards</a></li>
<li><a href="#lists"><span class="toc-section-number">2.3</span> Lists</a></li>
<li><a href="#a-word-about-immutability-1"><span class="toc-section-number">2.4</span> A word about immutability</a></li>
<li><a href="#a-word-about-type-inference-and-polymorphism"><span class="toc-section-number">2.5</span> A word about type inference and polymorphism</a></li>
<li><a href="#maybe"><span class="toc-section-number">2.6</span> Maybe</a></li>
<li><a href="#sidenote-constructors"><span class="toc-section-number">2.7</span> Sidenote: Constructors</a></li>
<li><a href="#the-either-type"><span class="toc-section-number">2.8</span> The <code>Either</code> type</a></li>
<li><a href="#quiz-1"><span class="toc-section-number">2.9</span> Quiz</a></li>
<li><a href="#exercises-1"><span class="toc-section-number">2.10</span> Exercises</a></li>
</ul></li>
<li><a href="#lecture-3-catamorphic"><span class="toc-section-number">3</span> Lecture 3: Catamorphic</a><ul>
<li><a href="#functional-programming-at-last"><span class="toc-section-number">3.1</span> Functional programming, at last</a></li>
<li><a href="#partial-application"><span class="toc-section-number">3.2</span> Partial application</a></li>
<li><a href="#prefix-and-infix-notations"><span class="toc-section-number">3.3</span> Prefix and Infix Notations</a></li>
<li><a href="#lambdas"><span class="toc-section-number">3.4</span> Lambdas</a></li>
<li><a href="#sidenote-the-.-and-operators"><span class="toc-section-number">3.5</span> Sidenote: the <code>.</code> and <code>$</code> operators</a></li>
<li><a href="#example-rewriting-whatfollows"><span class="toc-section-number">3.6</span> Example: rewriting <code>whatFollows</code></a></li>
<li><a href="#more-functional-list-wrangling-examples"><span class="toc-section-number">3.7</span> More functional list wrangling examples</a></li>
<li><a href="#lists-and-recursion"><span class="toc-section-number">3.8</span> Lists and recursion</a></li>
<li><a href="#something-fun-list-comprehensions"><span class="toc-section-number">3.9</span> Something fun: list comprehensions</a></li>
<li><a href="#something-fun-custom-operators"><span class="toc-section-number">3.10</span> Something fun: custom operators</a></li>
<li><a href="#quiz-2"><span class="toc-section-number">3.11</span> Quiz</a></li>
<li><a href="#exercises-2"><span class="toc-section-number">3.12</span> Exercises</a></li>
</ul></li>
<li><a href="#lecture-4-real-classy"><span class="toc-section-number">4</span> Lecture 4: Real Classy</a><ul>
<li><a href="#sidenote-tuples"><span class="toc-section-number">4.1</span> Sidenote: tuples</a></li>
<li><a href="#interlude-folding"><span class="toc-section-number">4.2</span> Interlude: folding</a></li>
<li><a href="#type-classes"><span class="toc-section-number">4.3</span> Type classes</a></li>
<li><a href="#type-constraints"><span class="toc-section-number">4.4</span> Type constraints</a></li>
<li><a href="#standard-type-classes"><span class="toc-section-number">4.5</span> Standard type classes</a></li>
<li><a href="#sidenote-the-case-of-expression"><span class="toc-section-number">4.6</span> Sidenote: The case-of expression</a></li>
<li><a href="#more-data-structures"><span class="toc-section-number">4.7</span> More data structures</a></li>
<li><a href="#reading-docs"><span class="toc-section-number">4.8</span> Reading docs</a></li>
<li><a href="#quiz-3"><span class="toc-section-number">4.9</span> Quiz</a></li>
<li><a href="#exercises-3"><span class="toc-section-number">4.10</span> Exercises</a></li>
</ul></li>
<li><a href="#lecture-5-you-need-string-for-a-knot"><span class="toc-section-number">5</span> Lecture 5: You Need String for a Knot</a><ul>
<li><a href="#algebraic-datatypes"><span class="toc-section-number">5.1</span> Algebraic Datatypes</a></li>
<li><a href="#type-parameters"><span class="toc-section-number">5.2</span> Type parameters</a></li>
<li><a href="#recursive-types"><span class="toc-section-number">5.3</span> Recursive types</a></li>
<li><a href="#record-syntax"><span class="toc-section-number">5.4</span> Record Syntax</a></li>
<li><a href="#algebraic-datatypes-summary"><span class="toc-section-number">5.5</span> Algebraic Datatypes: Summary</a></li>
<li><a href="#sidenote-other-ways-of-defining-types"><span class="toc-section-number">5.6</span> Sidenote: other ways of defining types</a></li>
<li><a href="#how-do-algebraic-datatypes-work"><span class="toc-section-number">5.7</span> How do algebraic datatypes work?</a></li>
<li><a href="#quiz-4"><span class="toc-section-number">5.8</span> Quiz</a></li>
<li><a href="#exercises-4"><span class="toc-section-number">5.9</span> Exercises</a></li>
</ul></li>
<li><a href="#lecture-6-working-class-hero"><span class="toc-section-number">6</span> Lecture 6: Working Class Hero</a><ul>
<li><a href="#the-syntax-of-classes-and-instances"><span class="toc-section-number">6.1</span> The syntax of classes and instances</a></li>
<li><a href="#sidenote-restrictions-on-instances"><span class="toc-section-number">6.2</span> Sidenote: restrictions on instances</a></li>
<li><a href="#default-implementations"><span class="toc-section-number">6.3</span> Default implementations</a></li>
<li><a href="#useful-stuff"><span class="toc-section-number">6.4</span> Useful stuff</a></li>
<li><a href="#hierarchies"><span class="toc-section-number">6.5</span> Hierarchies</a></li>
<li><a href="#quiz-5"><span class="toc-section-number">6.6</span> Quiz</a></li>
<li><a href="#exercises-5"><span class="toc-section-number">6.7</span> Exercises</a></li>
</ul></li>
<li><a href="#lecture-7-new-constellations"><span class="toc-section-number">7</span> Lecture 7: New Constellations</a><ul>
<li><a href="#modeling-with-boxes"><span class="toc-section-number">7.1</span> Modeling with boxes</a></li>
<li><a href="#modeling-with-cases"><span class="toc-section-number">7.2</span> Modeling with cases</a></li>
<li><a href="#monoids"><span class="toc-section-number">7.3</span> Monoids</a></li>
<li><a href="#open-and-closed-abstractions"><span class="toc-section-number">7.4</span> Open and closed abstractions</a></li>
<li><a href="#modeling-with-languages"><span class="toc-section-number">7.5</span> Modeling with languages</a></li>
<li><a href="#exercises-6"><span class="toc-section-number">7.6</span> Exercises</a></li>
</ul></li>
<li><a href="#lecture-8-the-aftertaste"><span class="toc-section-number">8</span> Lecture 8: The Aftertaste</a><ul>
<li><a href="#a-taste-of-io"><span class="toc-section-number">8.1</span> A taste of IO</a></li>
<li><a href="#summary"><span class="toc-section-number">8.2</span> Summary</a></li>
<li><a href="#what-next"><span class="toc-section-number">8.3</span> What next?</a></li>
<li><a href="#final-project-graphics"><span class="toc-section-number">8.4</span> Final project: graphics</a></li>
<li><a href="#acknowledgements"><span class="toc-section-number">8.5</span> Acknowledgements</a></li>
</ul></li>
</ul>
</nav>
<div id="text-container">
<div id="text">
<header>
<h1 class="title">Haskell Mooc, part 1</h1>
</header>
<h1 id="lecture-1-and-so-it-begins"><span class="header-section-number">1</span> Lecture 1: …and so it Begins</h1>
<h2 id="about-the-course"><span class="header-section-number">1.1</span> About the course</h2>
<p>This is an online course on Functional Programming that uses the Haskell programming language. You can study at your own pace. All the material and exercises are openly available.</p>
<p>This course is aimed at beginners who wish to learn functional programming, but also people who have experience with functional programming and want to learn Haskell in particular. The course assumes no previous knowledge, but knowing at least one programming language beforehand will make the course easier.</p>
<p>Working on the exercises involves knowing how to use the command line, and basic usage of the Git version control system.</p>
<p>This is part 1 of a two-part course. Part 1 covers the basics of Haskell syntax and features. You will learn about recursion, higher-order functions, algebraic data types and some of Haskell’s advanced features. However, part 1 will stick to pure functional programming, without side-effects. I/O and Monads will be introduced in part 2.</p>
<h3 id="course-structure"><span class="header-section-number">1.1.1</span> Course structure</h3>
<p>The course is split into 8 lectures. They are roughly the same size, but some lectures have more material than others. Each lecture set ends with 10-30 small programming exercises on the topics of the lecture.</p>
<h3 id="administrative-information-grading"><span class="header-section-number">1.1.2</span> Administrative information, grading</h3>
<p>The course is worth 5 ECTS credits.</p>
<p>Grading is Fail/Pass/5. To pass the course you must complete at least 50% of each lecture’s exercises. A special grade of 5 is awarded to those who complete 99% of all exercises.</p>
<h2 id="read-these"><span class="header-section-number">1.2</span> Read these</h2>
<p>In addition to this course material, the following sources might be useful if you feel like you’re missing examples or explanations.</p>
<ul>
<li><a href="https://haskell.mooc.fi">The course pages</a></li>
<li>The course <a href="https://t.me/haskell_mooc_fi">channel on Telegram</a></li>
<li>The course <a href="https://github.com/moocfi/haskell-mooc">repository on Github</a> contains the exercises and this material</li>
<li>Additional resources
<ul>
<li><a href="https://www.haskell.org/tutorial/">A Gentle Introduction to Haskell</a> - an older and shorter tutorial, but still worth reading</li>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!</a> – a nice free introduction to Haskell</li>
<li><a href="https://www.cs.yale.edu/homes/hudak/SOE/index.htm">The Haskell School of Expression</a> - slightly older but still relevant introduction to functional programming</li>
<li><a href="http://haskellbook.com/">Haskell Programming from First Principles</a> - $59 e-book on Haskell, slow and long</li>
<li>The IRC channel <code>#haskell</code> on <a href="https://freenode.net/">freenode</a> is a nice place for beginners</li>
</ul></li>
</ul>
<h2 id="haskell"><span class="header-section-number">1.3</span> Haskell</h2>
<p>Haskell is</p>
<p><strong>Functional</strong> – the basic building blocks of programs are functions. Functions can return functions and take functions as arguments. Also, the only looping construct in Haskell is recursion.</p>
<p><strong>Pure</strong> - Haskell functions are pure, that is, they don’t have side effects. Side effects mean things like reading a file, printing out text, or changing global variables. All inputs to a function must be in its arguments, and all outputs from a function in its return value. This sounds restricting, but makes reasoning about programs easier, and allows for more optimizations by the compiler.</p>
<p><strong>Lazy</strong> - values are only evaluated when they are needed. This makes it possible to work with infinite data structures, and also makes pure programs more efficient.</p>
<p><strong>Strongly typed</strong> - every Haskell value and expression has a type. The compiler checks the types at compile-time and guarantees that no type errors can happen at runtime. This means no AttributeErrors (a la Python), ClassCastExceptions (a la Java) or segmentation faults (a la C). The Haskell type system is very powerful and can help you design better programs.</p>
<p><strong>Type inferred</strong> - in addition to checking the types, the compiler can deduce the types for most programs. This makes working with a strongly typed language easier. Indeed, most Haskell functions can be written completely without types. However programmers can still give functions and values type annotations to make finding type errors easier. Type annotations also make reading programs easier.</p>
<p><strong>Garbage-collected</strong> - like most high-level languages these days, Haskell has automatic memory management via garbage collection. This means that the programmer doesn’t need to worry about allocating or freeing memory, the language runtime handles all of it automatically.</p>
<p><strong>Compiled</strong> - even though we mostly use Haskell via the interactive GHCi environment on this course, Haskell is a compiled language. Haskell programs can be compiled to very efficient binaries, and the GHC compiler is very good at optimising functional code into performant machine code.</p>
<p>You’ll learn what these terms mean in practice during this course. Don’t worry if some of them sound abstract right now.</p>
<p>See also: <a href="https://wiki.haskell.org/Functional_programming">The Haskell Wiki page on Functional programming</a>.</p>
<h3 id="features"><span class="header-section-number">1.3.1</span> Features</h3>
<p>Here’s a showcase of some of the Haskell’s cool features:</p>
<p><strong>Higher-order functions</strong> – functions can take functions as arguments:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">map length [<span class="st">&quot;abc&quot;</span>,<span class="st">&quot;abcdef&quot;</span>]</a></code></pre></div>
<p>This results in <code>[3,6]</code>.</p>
<p><strong>Anonymous functions aka lambdas</strong> – you can define single-use helper functions without giving them a name</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">filter (\x <span class="ot">-&gt;</span> length x <span class="fu">&gt;</span> <span class="dv">1</span>) [<span class="st">&quot;abc&quot;</span>,<span class="st">&quot;d&quot;</span>,<span class="st">&quot;ef&quot;</span>]</a></code></pre></div>
<p>This results in <code>[&quot;abc&quot;,&quot;ef&quot;]</code>.</p>
<p><strong>Partial application</strong> – you can define new functions by giving another function only some of the arguments it needs. For example this multiplies all elements in a list by 3:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">map (<span class="fu">*</span><span class="dv">3</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a></code></pre></div>
<p><strong>Algebraic datatypes</strong> – a syntax for defining datatypes that can contain a number of different cases:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Shape</span> <span class="fu">=</span> <span class="dt">Point</span> <span class="fu">|</span> <span class="dt">Rectangle</span> <span class="dt">Double</span> <span class="dt">Double</span> <span class="fu">|</span> <span class="dt">Circle</span> <span class="dt">Double</span></a></code></pre></div>
<p>Now the type <code>Shape</code> can have values like <code>Point</code>, <code>Rectangle 3 6</code> and <code>Circle 5</code></p>
<p><strong>Pattern matching</strong> – defining functions based on cases that correspond to your data definitions:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">area <span class="dt">Point</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">area (<span class="dt">Rectangle</span> width height) <span class="fu">=</span> width <span class="fu">*</span> height</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">area (<span class="dt">Circle</span> radius) <span class="fu">=</span> <span class="dv">2</span> <span class="fu">*</span> pi <span class="fu">*</span> radius</a></code></pre></div>
<p><strong>Lists</strong> – Unlike many languages, Haskell has a concise built-in syntax for lists. Lists can be built from other lists using <em>list comprehensions</em>. Here’s a snippet that generates names of even length from a set of options for first and last names:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">[whole <span class="fu">|</span> first <span class="ot">&lt;-</span> [<span class="st">&quot;Eva&quot;</span>, <span class="st">&quot;Mike&quot;</span>], last <span class="ot">&lt;-</span> [<span class="st">&quot;Smith&quot;</span>, <span class="st">&quot;Wood&quot;</span>, <span class="st">&quot;Odd&quot;</span>], <span class="kw">let</span> whole <span class="fu">=</span> first <span class="fu">++</span> last, even (length whole)]</a></code></pre></div>
<p>This results in <code>[&quot;EvaSmith&quot;,&quot;EvaOdd&quot;,&quot;MikeWood&quot;]</code>. Thanks to the laziness of Haskell, we can even create so-called <em>infinite lists</em>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">primes <span class="fu">=</span> [ n <span class="fu">|</span> n <span class="ot">&lt;-</span> [<span class="dv">2</span><span class="fu">..</span>] , all (\k <span class="ot">-&gt;</span> n <span class="ot">`mod`</span> k <span class="fu">/=</span> <span class="dv">0</span>) [<span class="dv">2</span><span class="fu">..</span>n <span class="ot">`div`</span> <span class="dv">2</span>] ]</a></code></pre></div>
<p>The first ten prime numbers can be then obtained by evaluating</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">take <span class="dv">10</span> primes</a></code></pre></div>
<p>This evaluates to <code>[2,3,5,7,11,13,17,19,23,29]</code>.</p>
<p><strong>Parameterized types</strong> – you can define types that are parameterized by other types. For example <code>[Int]</code> is a list of <code>Int</code>s and <code>[Bool]</code> is a list of booleans. You can define typed functions that work on all kinds of lists, for example <code>reverse</code> has the type <code>[a] -&gt; [a]</code> which means it takes a list containing any type <code>a</code>, and returns a list of the same type.</p>
<p><strong>Type classes</strong> – another form of polymorphism where you can give a function a different implementation depending on the arguments’ types. For example the <code>Show</code> type class defines the function <code>show</code> that can convert types of various values to strings. The <code>Num</code> type class defines arithmetic operators like <code>+</code> that work on all number types (<code>Int</code>, <code>Double</code>, <code>Complex</code>, …).</p>
<h3 id="some-history"><span class="header-section-number">1.3.2</span> Some History</h3>
<p>A brief timeline of Haskell:</p>
<ul>
<li>1930s: Lamba Calculus</li>
<li>1950s-1970s: Lisp, Pattern Matching, Scheme, ML</li>
<li>1978 John Backus: <a href="https://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf">Can programming be liberated from the von Neumann style?</a></li>
<li>1987 A decision was made to unify the field of pure functional languages</li>
<li>1990 Haskell 1.0</li>
<li>1991 Haskell 1.1 (let-syntax, sections)</li>
<li>1992 Haskell 1.2, GHC</li>
<li>1996 Haskell 1.3 (Monads, do-syntax, type system improvements)</li>
<li>1999 Haskell 98</li>
<li>2000’s: GHC development, many extensions to the language</li>
<li>2009 <a href="http://www.haskell.org/onlinereport/haskell2010/">The Haskell 2010 standard</a></li>
<li>2010’s: GHC development, Haskell Platform, Haskell Stack</li>
</ul>
<p>The word ‘haskel’ means wisdom in Hebrew, but the name of the Haskell programming language comes from the logician Haskell Curry. The name Haskell comes from the Old Norse words áss (god) and ketill (helmet).</p>
<h3 id="uses-of-haskell"><span class="header-section-number">1.3.3</span> Uses of Haskell</h3>
<p>Here are some examples of software projects that were written in Haskell.</p>
<ul>
<li>The <a href="https://en.wikipedia.org/wiki/Darcs">Darcs</a> distributed version control system</li>
<li>The <a href="https://engineering.fb.com/security/fighting-spam-with-haskell/">Sigma spam-prevention tool at Facebook</a></li>
<li>The implementations of the <a href="https://www.purescript.org/">PureScript</a> and <a href="https://elm-lang.org/">Elm</a> programming languages are written in Haskell</li>
<li>The <a href="https://pandoc.org/">Pandoc</a> tool for converting between different document formats – it’s also used to produce this course material</li>
<li>The <a href="http://postgrest.org/">PostgREST</a> server that exposes a HTTP REST API for a PostgreSQL database</li>
<li>Functional consulting companies like <a href="https://galois.com/">Galois</a> and <a href="https://well-typed.com/">Well-Typed</a> have a long history of developing critical systems for clients in Haskell</li>
</ul>
<p>See <a href="http://wiki.haskell.org/Haskell_in_industry">The Haskell Wiki</a> and <a href="https://serokell.io/blog/top-software-written-in-haskell">this blog post</a> for more!</p>
<h2 id="running-haskell"><span class="header-section-number">1.4</span> Running Haskell</h2>
<p>The easiest way to get Haskell is to install the <code>stack</code> tool, see <a href="http://haskellstack.org" class="uri">http://haskellstack.org</a>. The exercises on this course are intended to work with Stack, so you should use it for now.</p>
<p>By the way, if you’re interested in what Stack is, and how it relates to other Haskell tools like Cabal and GHC, <a href="https://www.quora.com/What-is-the-difference-between-Cabal-and-Stack-in-Haskell-projects-Which-one-do-you-recommend-and-why">read more here</a> or <a href="https://docs.haskellstack.org/en/stable/faq/">here</a>. We’ll get back to Haskell packages and using them in detail in part 2 of the course.</p>
<p>For now, after installing Stack, just run <code>stack ghci</code> to get an interactive Haskell environment.</p>
<h2 id="lets-start"><span class="header-section-number">1.5</span> Let’s start!</h2>
<p>GHCi is the interactive Haskell interpreter. Here’s an example session:</p>
<pre><code>$ stack ghci
GHCi, version 8.0.1: http://www.haskell.org/ghc/  :? for help
Prelude&gt; 1+1
2
Prelude&gt; &quot;asdf&quot;
&quot;asdf&quot;
Prelude&gt; reverse &quot;asdf&quot;
&quot;fdsa&quot;
Prelude&gt; :type &quot;asdf&quot;
&quot;asdf&quot; :: [Char]
Prelude&gt; tail &quot;asdf&quot;
&quot;sdf&quot;
Prelude&gt; :type tail &quot;asdf&quot;
tail &quot;asdf&quot; :: [Char]
Prelude&gt; :type tail
tail :: [a] -&gt; [a]
Prelude&gt; :quit
Leaving GHCi.</code></pre>
<p>By the way, the first time you run <code>stack ghci</code> it will download GHC and some libraries, so don’t worry if you see some output and have to wait for a while before getting the <code>Prelude&gt;</code> prompt.</p>
<p>Let’s walk through this. Don’t worry if you don’t understand things yet, this is just a first brush with expressions and types.</p>
<pre><code>Prelude&gt; 1+1
2</code></pre>
<p>The <code>Prelude&gt;</code> is the GHCi prompt. It indicates we can use the functions from the Haskell base library called Prelude. We evaluate 1 plus 1, and the result is 2.</p>
<pre><code>Prelude&gt; &quot;asdf&quot;
&quot;asdf&quot;</code></pre>
<p>Here we evaluate a string literal, and the result is the same string.</p>
<pre><code>Prelude&gt; reverse &quot;asdf&quot;
&quot;fdsa&quot;</code></pre>
<p>Here we compute the reverse of a string by applying the function <code>reverse</code> to the value <code>&quot;asdf&quot;</code>.</p>
<pre><code>Prelude&gt; :type &quot;asdf&quot;
&quot;asdf&quot; :: [Char]</code></pre>
<p>In addition to evaluating expressions we can also ask for their type with the <code>:type</code> (abbreviated <code>:t</code>) GHCi command. The type of <code>&quot;asdf&quot;</code> is a list of characters. Commands that start with <code>:</code> are part of the user interface of GHCi, not part of the Haskell language.</p>
<pre><code>Prelude&gt; tail &quot;asdf&quot;
&quot;sdf&quot;
Prelude&gt; :t tail &quot;asdf&quot;
tail &quot;asdf&quot; :: [Char]</code></pre>
<p>The <code>tail</code> function works on lists and returns all except the first element of the list. Here we see <code>tail</code> applied to <code>&quot;asdf&quot;</code>. We also check the type of the expression, and it is a list of characters, as expected.</p>
<pre><code>Prelude&gt; :t tail
tail :: [a] -&gt; [a]</code></pre>
<p>Finally, here’s the type of the <code>tail</code> function. It takes a list of any type as an argument, and returns a list of the same type.</p>
<pre><code>Prelude&gt; :quit
Leaving GHCi.</code></pre>
<p>That’s how you quit GHCi.</p>
<h2 id="expressions-and-types"><span class="header-section-number">1.6</span> Expressions and types</h2>
<p>Just like we saw in the GHCi example above, <em>expressions</em> and <em>types</em> are the bread and butter of Haskell. In fact, almost everything in a Haskell program is an expression. In particular, there are no <em>statements</em> like in Python, Java or C.</p>
<p>An expression has a <em>value</em> and a <em>type</em>. We write an expression and its type like this: <code>expression :: type</code>. Here are some examples:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Expression</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>True</code></td>
<td style="text-align: left;"><code>Bool</code></td>
<td style="text-align: left;"><code>True</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>not True</code></td>
<td style="text-align: left;"><code>Bool</code></td>
<td style="text-align: left;"><code>False</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&quot;as&quot; ++ &quot;df&quot;</code></td>
<td style="text-align: left;"><code>[Char]</code></td>
<td style="text-align: left;"><code>&quot;asdf&quot;</code></td>
</tr>
</tbody>
</table>
<h3 id="syntax-of-expressions"><span class="header-section-number">1.6.1</span> Syntax of expressions</h3>
<p>Expressions consist of functions <em>applied</em> to arguments. Functions are <em>applied</em> (i.e. called) by placing the arguments after the name of the function – there is no special syntax for a function call.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Haskell</th>
<th style="text-align: left;">Python, Java or C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>f 1</code></td>
<td style="text-align: left;"><code>f(1)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>f 1 2</code></td>
<td style="text-align: left;"><code>f(1,2)</code></td>
</tr>
</tbody>
</table>
<p>Parentheses can be used to <em>group</em> expressions (just like in math and other languages).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Haskell</th>
<th style="text-align: left;">Python, Java or C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>g h f 1</code></td>
<td style="text-align: left;"><code>g(h,f,1)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>g h (f 1)</code></td>
<td style="text-align: left;"><code>g(h,f(1))</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>g (h f 1)</code></td>
<td style="text-align: left;"><code>g(h(f,1))</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>g (h (f 1))</code></td>
<td style="text-align: left;"><code>g(h(f(1)))</code></td>
</tr>
</tbody>
</table>
<p>Some function names are made special characters and they are used as operators: between their arguments instead of before them. Function calls <em>bind tighter</em> than operators, just like multiplication binds tighter than addition.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Haskell</th>
<th style="text-align: left;">Python, Java or C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>a + b</code></td>
<td style="text-align: left;"><code>a + b</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>f a + g b</code></td>
<td style="text-align: left;"><code>f(a) + g(b)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>f (a + g b)</code></td>
<td style="text-align: left;"><code>f(a+g(b))</code></td>
</tr>
</tbody>
</table>
<p>PS. in Haskell, function application <em>associates left</em>, that is, <code>f g x y</code> is actually the same as <code>(((f g) x) y)</code>. We’ll get back to this topic later. For now you can just think that <code>f g x y</code> is <code>f</code> applied to the arguments <code>g</code>, <code>x</code> and <code>y</code>.</p>
<h3 id="syntax-of-types"><span class="header-section-number">1.6.2</span> Syntax of types</h3>
<p>Here are some basic types of Haskell to get you started.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Literals</th>
<th style="text-align: left;">Use</th>
<th style="text-align: left;">Operations</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Int</code></td>
<td style="text-align: left;"><code>1</code>, <code>2</code>, <code>-3</code></td>
<td style="text-align: left;">Number type (signed, 64bit)</td>
<td style="text-align: left;"><code>+</code>, <code>-</code>, <code>*</code>, <code>div</code>, <code>mod</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Integer</code></td>
<td style="text-align: left;"><code>1</code>, <code>-2</code>, <code>900000000000000000</code></td>
<td style="text-align: left;">Unbounded number type</td>
<td style="text-align: left;"><code>+</code>, <code>-</code>, <code>*</code>, <code>div</code>, <code>mod</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Double</code></td>
<td style="text-align: left;"><code>0.1</code>, <code>1.2e5</code></td>
<td style="text-align: left;">Floating point numbers</td>
<td style="text-align: left;"><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>sqrt</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Bool</code></td>
<td style="text-align: left;"><code>True</code>, <code>False</code></td>
<td style="text-align: left;">Truth values</td>
<td style="text-align: left;"><code>&amp;&amp;</code>, <code>||</code>, <code>not</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>String</code> aka <code>[Char]</code></td>
<td style="text-align: left;"><code>&quot;abcd&quot;</code>, <code>&quot;&quot;</code></td>
<td style="text-align: left;">Strings of characters</td>
<td style="text-align: left;"><code>reverse</code>, <code>++</code></td>
</tr>
</tbody>
</table>
<p>As you can see, the names of types in Haskell start with a capital letter. Some values like <code>True</code> also start with a capital letter, but variables and functions start with a lower case letter (<code>reverse</code>, <code>not</code>, <code>x</code>). We’ll get back to the meaning of capital letters in Lecture 2.</p>
<p>Function types are written using the <code>-&gt;</code> syntax:</p>
<ul>
<li>A function of one argument: <code>argumentType -&gt; returnType</code></li>
<li>… of two arguments: <code>argument1Type -&gt; argument2Type -&gt; returnType</code></li>
<li>… of three arguments: <code>aargument1Type -&gt; argument2Type -&gt; argument3Type -&gt; returnType</code></li>
</ul>
<p>Looks a bit weird, right? We’ll get back to this as well.</p>
<h3 id="note-about-misleading-types"><span class="header-section-number">1.6.3</span> Note about misleading types</h3>
<p>Sometimes, the types you see in GHCi are a bit different than what you’d assume. Here are two common cases.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dv">1</span><span class="fu">+</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="dv">1</span><span class="fu">+</span><span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</a></code></pre></div>
<p>For now, you should read the type <code>Num a =&gt; a</code> as “any number type”. In Haskell, number literals are <em>overloaded</em> which means that they can be interpreted as any number type (e.g. <code>Int</code> or <code>Double</code>). We’ll get back to what <code>Num a</code> actually means when we talk about <em>type classes</em> later.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="st">&quot;asdf&quot;</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="st">&quot;asdf&quot;</span><span class="ot"> ::</span> [<span class="dt">Char</span>]</a></code></pre></div>
<p>The type <code>String</code> is just an alias for the type <code>[Char]</code> which means “list of characters”. We’ll get back to lists on the next lecture! In any case, you can use <code>String</code> and <code>[Char]</code> interchangeably, but GHCi will mostly use <code>[Char]</code> when describing types to you.</p>
<h2 id="the-structure-of-a-haskell-program"><span class="header-section-number">1.7</span> The structure of a Haskell program</h2>
<p>Here’s a simple Haskell program that does some arithmetic and prints some values.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Gold</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="co">-- The golden ratio</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">phi ::</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">phi <span class="fu">=</span> (sqrt <span class="dv">5</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">/</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6"></a>
<a class="sourceLine" id="cb19-7" data-line-number="7"><span class="ot">polynomial ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">polynomial x <span class="fu">=</span> x<span class="fu">^</span><span class="dv">2</span> <span class="fu">-</span> x <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">f x <span class="fu">=</span> polynomial (polynomial x)</a>
<a class="sourceLine" id="cb19-11" data-line-number="11"></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-13" data-line-number="13">  print (polynomial phi)</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">  print (f phi)</a></code></pre></div>
<p>If you put this in a file called <code>Gold.hs</code> and run it with (for example) <code>stack runhaskell Gold.hs</code>, you should see this output</p>
<pre><code>0.0
-1.0</code></pre>
<p>Let’s walk through the file.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Gold</span> <span class="kw">where</span></a></code></pre></div>
<p>There is one Haskell <em>module</em> per source file. A module consists of <em>definitions</em>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="co">-- The golden ratio</span></a></code></pre></div>
<p>This is a comment. Comments are not part of the actual program, but text for human readers of the program.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">phi ::</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">phi <span class="fu">=</span> (sqrt <span class="dv">5</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">/</span> <span class="dv">2</span></a></code></pre></div>
<p>This is a definition of the constant <code>phi</code>, with an accompanying <em>type annotation</em> (also known as a <em>type signature</em>) <code>phi :: Double</code>. The type annotation means that <code>phi</code> has type <code>Double</code>. The line with a equals sign (<code>=</code>) is called an <em>equation</em>. The left hand side of the <code>=</code> is the expression we are defining, and the right hand side of the <code>=</code> is the definition.</p>
<p>In general a definition (of a function or constant) consists of an optional <em>type annotation</em> and one or more <em>equations</em></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">polynomial ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">polynomial x <span class="fu">=</span> x<span class="fu">^</span><span class="dv">2</span> <span class="fu">-</span> x <span class="fu">-</span> <span class="dv">1</span></a></code></pre></div>
<p>This is the definition of a function called <code>polynomial</code>. It has a type annotation and an equation. Note how an equation for a function differs from the equation of a constant by the presence of a parameter <code>x</code> left of the <code>=</code> sign. Note also that <code>^</code> is the power operator in Haskell, not bitwise xor like in many other languages.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">f x <span class="fu">=</span> polynomial (polynomial x)</a></code></pre></div>
<p>This is the definition of a function called <code>f</code>. Note the lack of type annotation. What is the type of <code>f</code>?</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  print (polynomial phi)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  print (f phi)</a></code></pre></div>
<p>This is a description of what happens when you run the program. It uses do-syntax and the IO Monad. We’ll get back to those in part 2 of the course.</p>
<h2 id="working-with-examples"><span class="header-section-number">1.8</span> Working with examples</h2>
<p>When you see an example definition like this</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">polynomial ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">polynomial x <span class="fu">=</span> x<span class="fu">^</span><span class="dv">2</span> <span class="fu">-</span> x <span class="fu">-</span> <span class="dv">1</span></a></code></pre></div>
<p>you should usually play around with it. Start by running it. There are a couple of ways to do this.</p>
<p>If a definition fits on one line, you can just define it in GHCi using <code>let</code>:</p>
<pre><code>Prelude&gt; let polynomial x = x^2 - x - 1
Prelude&gt; polynomial 3.0
5.0</code></pre>
<p>For a multi-line definition, you can either use <code>;</code> to separate lines, or use the special <code>:{ :}</code> syntax to paste a block of code into GHCi:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>{</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">|</span><span class="ot"> polynomial ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">|</span> polynomial x <span class="fu">=</span> x<span class="fu">^</span><span class="dv">2</span> <span class="fu">-</span> x <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">|</span> <span class="fu">:</span>}</a>
<a class="sourceLine" id="cb29-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> polynomial <span class="fl">3.0</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6"><span class="fl">5.0</span></a></code></pre></div>
<p>Finally, you can paste the code into a new or existing <code>.hs</code> file, and then <code>:load</code> it into GHCi. If the file has already been loaded, you can also use <code>:reload</code>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="co">-- first copy and paste the definition into Example.hs, then run GHCi</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>load Example.hs</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span>             ( Example.hs, interpreted )</a>
<a class="sourceLine" id="cb30-4" data-line-number="4"><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="fu">.</span></a>
<a class="sourceLine" id="cb30-5" data-line-number="5"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> polynomial <span class="fl">3.0</span></a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="fl">5.0</span></a>
<a class="sourceLine" id="cb30-7" data-line-number="7"><span class="co">-- now you can edit the definition</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>reload</a>
<a class="sourceLine" id="cb30-9" data-line-number="9">[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span>             ( Example.hs, interpreted )</a>
<a class="sourceLine" id="cb30-10" data-line-number="10"><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="fu">.</span></a>
<a class="sourceLine" id="cb30-11" data-line-number="11"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> polynomial <span class="dv">3</span></a>
<a class="sourceLine" id="cb30-12" data-line-number="12"><span class="fl">3.0</span></a></code></pre></div>
<p>After you’ve run the example, try modifying it, or making another function that is similar but different. You learn programming by programming, not by reading!</p>
<h3 id="dealing-with-errors"><span class="header-section-number">1.8.1</span> Dealing with errors</h3>
<p>Since Haskell is a typed language, you’ll pretty quickly bump into type errors. Here’s an example of an error during a GHCi session:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;string&quot;</span> <span class="fu">++</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"></a>
<a class="sourceLine" id="cb31-3" data-line-number="3"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">13</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    • <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> ‘[<span class="dt">Char</span>]’ with actual <span class="kw">type</span> ‘<span class="dt">Bool</span>’</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    • <span class="dt">In</span> the second argument <span class="kw">of</span> ‘(<span class="fu">++</span>)’, namely ‘<span class="dt">True</span>’</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">      <span class="dt">In</span> the expression<span class="fu">:</span> <span class="st">&quot;string&quot;</span> <span class="fu">++</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">      <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> <span class="st">&quot;string&quot;</span> <span class="fu">++</span> <span class="dt">True</span></a></code></pre></div>
<p>This is the most common type error, “Couldn’t match expected type”. Even though the error looks long and scary, it’s pretty simple if you just read through it.</p>
<ul>
<li><p>The first line of the error message, <code>&lt;interactive&gt;:1:13: error:</code> tells us that the error occurred in GHCi. If we had loaded a file, we might instead get something like <code>Sandbox.hs:3:17: error:</code>, where <code>Sandbox.hs</code> is the name of the file, <code>3</code> is the line number and <code>17</code> is the number of a character in the line.</p></li>
<li><p>The line <code>• Couldn't match expected type ‘[Char]’ with actual type ‘Bool’</code> tells us that the immediate cause for the error is that there was an expression of type <code>Bool</code>, when GHCi was expecting to find an expression of type <code>[Char]</code>“. The location of this error was indicated in the first line of the error message. Note that the expected type is not always right. Giving type annotations by hand can help debugging typing errors.</p></li>
<li><p>The line <code>• In the second argument of ‘(++)’, namely ‘True’</code> tells that the expression that had the wrong type was the second argument of the operator <code>(++)</code>. We’ll learn later why it’s surrounded by parentheses.</p></li>
<li><p>The full expression with the error was <code>&quot;string&quot; ++ True</code>. As mentioned above, <code>String</code> is a type alias for <code>[Char]</code>, the type of character lists. The first argument to <code>++</code> was a list of characters, and since <code>++</code> can only combine two lists of the same type, the second argument should’ve been of type <code>[Char]</code> too.</p></li>
<li><p>The line <code>In an equation for ‘it’: it = &quot;string&quot; ++ True</code> says that the expression occurred in the definition of the variable <code>it</code>, which is a default variable name that GHCi uses for standalone expressions. If we had a line <code>x = &quot;string&quot; ++ True</code> in a file, or a declaration <code>let x = &quot;string&quot; ++ True</code> in GHCi, GHCi would print <code>In an equation for ‘x’: x = &quot;string&quot; ++ True</code> instead.</p></li>
</ul>
<p>There are also others types of errors.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">True</span> <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2"></a>
<a class="sourceLine" id="cb32-3" data-line-number="3"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">6</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    • <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Num</span> <span class="dt">Bool</span>) arising from a use <span class="kw">of</span> ‘<span class="fu">+</span>’</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">    • <span class="dt">In</span> the expression<span class="fu">:</span> <span class="dt">True</span> <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">      <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> <span class="dt">True</span> <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>This is the kind of error you get when you try to use a numeric function like <code>+</code> on something that’s not a number.</p>
<p>The hardest error to track down is usually this:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">True</span> <span class="fu">+</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2"></a>
<a class="sourceLine" id="cb33-3" data-line-number="3"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">10</span><span class="fu">:</span><span class="dv">7</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">    parse error (possibly incorrect indentation or mismatched brackets)</a></code></pre></div>
<p>There are many ways to cause it. Probably you’re missing some characters somewhere. We’ll get back to indentation later in this lecture.</p>
<!-- TODO more errors based on feedback -->
<h3 id="arithmetic"><span class="header-section-number">1.8.2</span> Arithmetic</h3>
<p>There’s one thing in Haskell arithmetic that often trips up beginners, and that’s division.</p>
<p>In Haskell there are two division functions, the <code>/</code> operator and the <code>div</code> function. The <code>div</code> function does integer division:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">7</span> <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="dv">3</span></a></code></pre></div>
<p>The <code>/</code> operator performs the usual division:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fl">7.0</span> <span class="fu">/</span> <span class="fl">2.0</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="fl">3.5</span></a></code></pre></div>
<p>However, you can only use <code>div</code> on whole number types like <code>Int</code> and <code>Integer</code>, and you can only use <code>/</code> on decimal types like <code>Double</code>. Here’s an example of what happens if you try to mix them up:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">halve ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">halve x <span class="fu">=</span> x <span class="fu">/</span> <span class="dv">2</span></a></code></pre></div>
<pre><code>error:
    • No instance for (Fractional Int) arising from a use of ‘/’
    • In the expression: x / 2
      In an equation for ‘halve’: halve x = x / 2</code></pre>
<p>Just try to keep this in mind for now. We’ll get back to the difference between <code>/</code> and <code>div</code>, and what <code>Num</code> and <code>Fractional</code> mean when talking about type classes.</p>
<h2 id="how-do-i-get-anything-done"><span class="header-section-number">1.9</span> How do I get anything done?</h2>
<p>So far you’ve seen some arithmetic, reversing a string and so on. How does one write actual programs in Haskell? Many of the usual programming constructs like loops, statements and assignment are missing from Haskell. Next, we’ll go through the basic building blocks of Haskell programs:</p>
<ul>
<li>Conditionals</li>
<li>Local definitions</li>
<li>Pattern matching</li>
<li>Recursion</li>
</ul>
<h3 id="conditionals"><span class="header-section-number">1.9.1</span> Conditionals</h3>
<p>In other languages, <code>if</code> is a <em>statement</em>. It doesn’t have a value, it just conditionally executes other statements.</p>
<p>In Haskell, <code>if</code> is an <em>expression</em>. It has a value. It selects between two other expressions. It corresponds to the <code>?:</code> operator in C or Java.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="co">// Java</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="dt">int</span> price = product.<span class="fu">equals</span>(<span class="st">&quot;milk&quot;</span>) ? <span class="dv">1</span> : <span class="dv">2</span>;</a></code></pre></div>
<p>Python’s conditional expressions are quite close to haskell’s <code>if</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="co"># Python</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">price <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> product <span class="op">==</span> <span class="st">&quot;milk&quot;</span> <span class="cf">else</span> <span class="dv">2</span></a></code></pre></div>
<p>This is how the same example looks in Haskell:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1">price <span class="fu">=</span> <span class="kw">if</span> product <span class="fu">==</span> <span class="st">&quot;milk&quot;</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">2</span></a></code></pre></div>
<p>Because Haskell’s <code>if</code> <em>returns</em> a value, you <strong>always</strong> need an <code>else</code>!</p>
<h4 id="functions-returning-bool"><span class="header-section-number">1.9.1.1</span> Functions returning <code>Bool</code></h4>
<p>In order to write if expressions, you need to know how to get values of type <code>Bool</code>. The most common way is comparisons. The usual <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> operators work in Haskell. You can do ordered comparisons (<code>&lt;</code>, <code>&gt;</code>) on all sorts of numbers, and equality comparisons (<code>==</code>) on almost anything:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;foo&quot;</span> <span class="fu">==</span> <span class="st">&quot;bar&quot;</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="dt">False</span></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fl">5.0</span> <span class="fu">&lt;=</span> <span class="fl">7.2</span></a>
<a class="sourceLine" id="cb41-4" data-line-number="4"><span class="dt">True</span></a>
<a class="sourceLine" id="cb41-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">==</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="dt">True</span></a></code></pre></div>
<p>One oddity of Haskell is that the not-equals operator is written <code>/=</code> instead of the usual <code>!=</code>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">/=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb42-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;bike&quot;</span> <span class="fu">/=</span> <span class="st">&quot;bike&quot;</span></a>
<a class="sourceLine" id="cb42-4" data-line-number="4"><span class="dt">False</span></a></code></pre></div>
<p>Remember that in addition to these comparisons, you can get <code>Bool</code> values out of other <code>Bool</code> values by using the <code>&amp;&amp;</code> (“and”) and <code>||</code> (“or”) operators, and the <code>not</code> function.</p>
<h4 id="examples"><span class="header-section-number">1.9.1.2</span> Examples</h4>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1">checkPassword password <span class="fu">=</span> <span class="kw">if</span> password <span class="fu">==</span> <span class="st">&quot;swordfish&quot;</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2">                         <span class="kw">then</span> <span class="st">&quot;You&#39;re in.&quot;</span></a>
<a class="sourceLine" id="cb43-3" data-line-number="3">                         <span class="kw">else</span> <span class="st">&quot;ACCESS DENIED!&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1">absoluteValue n <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">&lt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="fu">-</span>n <span class="kw">else</span> n</a></code></pre></div>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1">login user password <span class="fu">=</span> <span class="kw">if</span> user <span class="fu">==</span> <span class="st">&quot;unicorn73&quot;</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2">                      <span class="kw">then</span> <span class="kw">if</span> password <span class="fu">==</span> <span class="st">&quot;f4bulous!&quot;</span></a>
<a class="sourceLine" id="cb45-3" data-line-number="3">                           <span class="kw">then</span> <span class="st">&quot;unicorn73 logged in&quot;</span></a>
<a class="sourceLine" id="cb45-4" data-line-number="4">                           <span class="kw">else</span> <span class="st">&quot;wrong password&quot;</span></a>
<a class="sourceLine" id="cb45-5" data-line-number="5">                      <span class="kw">else</span> <span class="st">&quot;unknown user&quot;</span></a></code></pre></div>
<h3 id="local-definitions"><span class="header-section-number">1.9.2</span> Local definitions</h3>
<p>Haskell has two different ways for creating local definitions: <code>let...in</code> and <code>where</code>.</p>
<p><code>where</code> adds local definitions to a definition:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">circleArea ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2">circleArea r <span class="fu">=</span> pi <span class="fu">*</span> rsquare</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">    <span class="kw">where</span> pi <span class="fu">=</span> <span class="fl">3.1415926</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4">          rsquare <span class="fu">=</span> r <span class="fu">*</span> r</a></code></pre></div>
<p><code>let...in</code> is an expression:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1">circleArea r <span class="fu">=</span> <span class="kw">let</span> pi <span class="fu">=</span> <span class="fl">3.1415926</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2">                   rsquare <span class="fu">=</span> r <span class="fu">*</span> r</a>
<a class="sourceLine" id="cb47-3" data-line-number="3">               <span class="kw">in</span> pi <span class="fu">*</span> rsquare</a></code></pre></div>
<p>Local definitions can also be functions:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1">circleArea r <span class="fu">=</span> pi <span class="fu">*</span> square r</a>
<a class="sourceLine" id="cb48-2" data-line-number="2">    <span class="kw">where</span> pi <span class="fu">=</span> <span class="fl">3.1415926</span></a>
<a class="sourceLine" id="cb48-3" data-line-number="3">          square x <span class="fu">=</span> x <span class="fu">*</span> x</a></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1">circleArea r <span class="fu">=</span> <span class="kw">let</span> pi <span class="fu">=</span> <span class="fl">3.1415926</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2">                   square x <span class="fu">=</span> x <span class="fu">*</span> x</a>
<a class="sourceLine" id="cb49-3" data-line-number="3">               <span class="kw">in</span> pi <span class="fu">*</span> square r</a></code></pre></div>
<p>We’ll get back to the differences between <code>let</code> and <code>where</code>, but mostly you can use which ever you like.</p>
<h3 id="a-word-about-immutability"><span class="header-section-number">1.9.3</span> A word about immutability</h3>
<p>Even though things like <code>pi</code> above are often called <em>variables</em>, I’ve chosen to call them <em>definitions</em> here. This is because unlike variables in Python or Java, the values of these definitions can’t be changed. Haskell variables aren’t boxes into which you can put new values, Haskell variables name a value (or rather, an expression) and that’s it.</p>
<p>We’ll talk about immutability again later on this course, but for now it’s enough to know that things like this don’t work.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1">increment x <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> x<span class="fu">+</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2">              <span class="kw">in</span> x</a></code></pre></div>
<p>This is just an infinite loop, because it tries to define a new variable <code>x</code> with the property <code>x = x+1</code>. Thus when evaluating <code>x</code>, Haskell just keeps computing <code>1+1+1+1+...</code> indefinitely.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1">compute x <span class="fu">=</span> <span class="kw">let</span> a <span class="fu">=</span> x<span class="fu">+</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2">                a <span class="fu">=</span> a<span class="fu">*</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb51-3" data-line-number="3">            <span class="kw">in</span> a</a></code></pre></div>
<pre><code>error:
    Conflicting definitions for ‘a’
    Bound at: &lt;interactive&gt;:14:17
              &lt;interactive&gt;:15:17</code></pre>
<p>Here we get a straightforward error when we’re trying to “update” the value of <code>a</code>.</p>
<p>As a remark, local definitions can <em>shadow</em> the names of variables defined elsewhere. Shadowing is not a side-effect. Instead, shadowing creates a new variable within a more restricted scope that uses the same name as some variable in the outer scope. For example, all of the functions <code>f</code>, <code>g</code>, and <code>h</code> below are legal:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="ot">x ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2">x <span class="fu">=</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb53-3" data-line-number="3"></a>
<a class="sourceLine" id="cb53-4" data-line-number="4"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb53-5" data-line-number="5">f x <span class="fu">=</span> <span class="dv">2</span> <span class="fu">*</span> x</a>
<a class="sourceLine" id="cb53-6" data-line-number="6"></a>
<a class="sourceLine" id="cb53-7" data-line-number="7"><span class="ot">g ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb53-8" data-line-number="8">g y <span class="fu">=</span> x <span class="kw">where</span> x <span class="fu">=</span> <span class="dv">6</span></a>
<a class="sourceLine" id="cb53-9" data-line-number="9"></a>
<a class="sourceLine" id="cb53-10" data-line-number="10"><span class="ot">h ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb53-11" data-line-number="11">h x <span class="fu">=</span> x <span class="kw">where</span> x <span class="fu">=</span> <span class="dv">3</span></a></code></pre></div>
<p>If we apply them to the global constant <code>x</code>, we see the effects of shadowing:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1">f <span class="dv">1</span> <span class="fu">==&gt;</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2">g <span class="dv">1</span> <span class="fu">==&gt;</span> <span class="dv">6</span></a>
<a class="sourceLine" id="cb54-3" data-line-number="3">h <span class="dv">1</span> <span class="fu">==&gt;</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb54-4" data-line-number="4"></a>
<a class="sourceLine" id="cb54-5" data-line-number="5">f x <span class="fu">==&gt;</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb54-6" data-line-number="6">g x <span class="fu">==&gt;</span> <span class="dv">6</span></a>
<a class="sourceLine" id="cb54-7" data-line-number="7">h x <span class="fu">==&gt;</span> <span class="dv">3</span></a></code></pre></div>
<p>It is best to always choose new names for local variables, so that shadowing never happens. That way, the reader of the code will understand where the variables that are used in an expression come from. Note that in the following example, <code>f</code> and <code>g</code> don’t shadow each others’ arguments:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb55-2" data-line-number="2">f x <span class="fu">=</span> <span class="dv">2</span> <span class="fu">*</span> x <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb55-3" data-line-number="3"></a>
<a class="sourceLine" id="cb55-4" data-line-number="4"><span class="ot">g ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb55-5" data-line-number="5">g x <span class="fu">=</span> x <span class="fu">-</span> <span class="dv">2</span></a></code></pre></div>
<h3 id="pattern-matching"><span class="header-section-number">1.9.4</span> Pattern matching</h3>
<p>A definition (of a function) can consist of multiple <em>equations</em>. The equations are matched in order against the arguments until a suitable one is found. This is called <em>pattern matching</em>.</p>
<p>Pattern matching in Haskell is very powerful, and we’ll keep learning new things about it along this course, but here are a couple of first examples:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="ot">greet ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb56-2" data-line-number="2">greet <span class="st">&quot;Finland&quot;</span> name <span class="fu">=</span> <span class="st">&quot;Hei, &quot;</span> <span class="fu">++</span> name</a>
<a class="sourceLine" id="cb56-3" data-line-number="3">greet <span class="st">&quot;Italy&quot;</span>   name <span class="fu">=</span> <span class="st">&quot;Ciao, &quot;</span> <span class="fu">++</span> name</a>
<a class="sourceLine" id="cb56-4" data-line-number="4">greet <span class="st">&quot;England&quot;</span> name <span class="fu">=</span> <span class="st">&quot;How do you do, &quot;</span> <span class="fu">++</span> name</a>
<a class="sourceLine" id="cb56-5" data-line-number="5">greet _         name <span class="fu">=</span> <span class="st">&quot;Hello, &quot;</span> <span class="fu">++</span> name</a></code></pre></div>
<p>The function <code>greet</code> generates a greeting given a country and a name (both <code>String</code>s). It has special cases for three countries, and a default case. This is how it works:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> greet <span class="st">&quot;Finland&quot;</span> <span class="st">&quot;Pekka&quot;</span></a>
<a class="sourceLine" id="cb57-2" data-line-number="2"><span class="st">&quot;Hei, Pekka&quot;</span></a>
<a class="sourceLine" id="cb57-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> greet <span class="st">&quot;England&quot;</span> <span class="st">&quot;Bob&quot;</span></a>
<a class="sourceLine" id="cb57-4" data-line-number="4"><span class="st">&quot;How do you do, Bob&quot;</span></a>
<a class="sourceLine" id="cb57-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> greet <span class="st">&quot;Italy&quot;</span> <span class="st">&quot;Maria&quot;</span></a>
<a class="sourceLine" id="cb57-6" data-line-number="6"><span class="st">&quot;Ciao, Maria&quot;</span></a>
<a class="sourceLine" id="cb57-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> greet <span class="st">&quot;Greenland&quot;</span> <span class="st">&quot;Jan&quot;</span></a>
<a class="sourceLine" id="cb57-8" data-line-number="8"><span class="st">&quot;Hello, Jan&quot;</span></a></code></pre></div>
<p>The special pattern <code>_</code> matches anything. It’s usually used for default cases. Because patterns are matched in order, it’s important to (<em>usually</em>) put the <code>_</code> case last. Consider:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1">brokenGreet _         name <span class="fu">=</span> <span class="st">&quot;Hello, &quot;</span> <span class="fu">++</span> name</a>
<a class="sourceLine" id="cb58-2" data-line-number="2">brokenGreet <span class="st">&quot;Finland&quot;</span> name <span class="fu">=</span> <span class="st">&quot;Hei, &quot;</span> <span class="fu">++</span> name</a></code></pre></div>
<p>Now the first case gets selected for all inputs.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> brokenGreet <span class="st">&quot;Finland&quot;</span> <span class="st">&quot;Varpu&quot;</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2"><span class="st">&quot;Hello, Varpu&quot;</span></a>
<a class="sourceLine" id="cb59-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> brokenGreet <span class="st">&quot;Sweden&quot;</span> <span class="st">&quot;Ole&quot;</span></a>
<a class="sourceLine" id="cb59-4" data-line-number="4"><span class="st">&quot;Hello, Ole&quot;</span></a></code></pre></div>
<p>GHC even gives you a warning about this code:</p>
<pre><code>&lt;interactive&gt;:1:1: warning: [-Woverlapping-patterns]
    Pattern match is redundant
    In an equation for ‘brokenGreet’: brokenGreet &quot;Finland&quot; name = ...</code></pre>
<p>Some more examples follow. But first let’s introduce the standard library function <code>show</code> that can turn (almost!) anything into a string:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> show <span class="dt">True</span></a>
<a class="sourceLine" id="cb61-2" data-line-number="2"><span class="st">&quot;True&quot;</span></a>
<a class="sourceLine" id="cb61-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> show <span class="dv">3</span></a>
<a class="sourceLine" id="cb61-4" data-line-number="4"><span class="st">&quot;3&quot;</span></a></code></pre></div>
<p>So, here’s an example of a function with pattern matching and a default case that actually uses the value (instead of just ignoring it with <code>_</code>):</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="ot">describe ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb62-2" data-line-number="2">describe <span class="dv">0</span> <span class="fu">=</span> <span class="st">&quot;zero&quot;</span></a>
<a class="sourceLine" id="cb62-3" data-line-number="3">describe <span class="dv">1</span> <span class="fu">=</span> <span class="st">&quot;one&quot;</span></a>
<a class="sourceLine" id="cb62-4" data-line-number="4">describe <span class="dv">2</span> <span class="fu">=</span> <span class="st">&quot;an even prime&quot;</span></a>
<a class="sourceLine" id="cb62-5" data-line-number="5">describe n <span class="fu">=</span> <span class="st">&quot;the number &quot;</span> <span class="fu">++</span> show n</a></code></pre></div>
<p>This is how it works:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb63-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> describe <span class="dv">0</span></a>
<a class="sourceLine" id="cb63-2" data-line-number="2"><span class="st">&quot;zero&quot;</span></a>
<a class="sourceLine" id="cb63-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> describe <span class="dv">2</span></a>
<a class="sourceLine" id="cb63-4" data-line-number="4"><span class="st">&quot;an even prime&quot;</span></a>
<a class="sourceLine" id="cb63-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> describe <span class="dv">7</span></a>
<a class="sourceLine" id="cb63-6" data-line-number="6"><span class="st">&quot;the number 7&quot;</span></a></code></pre></div>
<p>You can even pattern match on multiple arguments. Again, the equations are tried in order. Here’s a reimplementation of the login function from earlier:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb64-1" data-line-number="1">login <span class="st">&quot;unicorn73&quot;</span> <span class="st">&quot;f4bulous!&quot;</span> <span class="fu">=</span> <span class="st">&quot;unicorn73 logged in&quot;</span></a>
<a class="sourceLine" id="cb64-2" data-line-number="2">login <span class="st">&quot;unicorn73&quot;</span> _           <span class="fu">=</span> <span class="st">&quot;wrong password&quot;</span></a>
<a class="sourceLine" id="cb64-3" data-line-number="3">login _           _           <span class="fu">=</span> <span class="st">&quot;unknown user&quot;</span></a></code></pre></div>
<h3 id="recursion"><span class="header-section-number">1.9.5</span> Recursion</h3>
<p>In Haskell, all sorts of loops are implemented with recursion. Function calls are very efficient, so you don’t need to worry about performance. (We’ll talk about performance later).</p>
<p>Learning how to do simple things with recursion in Haskell will help you use recursion on more complex problems later. Recursion is also often a useful way for thinking about solving harder problems.</p>
<p>Here’s our first recursive function which computes the factorial. In mathematics, factorial is the product of <em>n</em> first positive integers and is written as <em>n!</em>. The definition of factorial is</p>
<blockquote>
<p><em>n! = n * (n-1) * … * 1</em></p>
</blockquote>
<p>For example, <em>4! = 4*3*2*1 = 24</em>. Well anyway, here’s the Haskell implementation of factorial:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="ot">factorial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb65-2" data-line-number="2">factorial <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb65-3" data-line-number="3">factorial n <span class="fu">=</span> n <span class="fu">*</span> factorial (n<span class="fu">-</span><span class="dv">1</span>)</a></code></pre></div>
<p>This is how it works. We use <code>==&gt;</code> to mean “evaluates to”.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb66-1" data-line-number="1">factorial <span class="dv">3</span></a>
<a class="sourceLine" id="cb66-2" data-line-number="2">  <span class="fu">==&gt;</span> <span class="dv">3</span> <span class="fu">*</span> factorial (<span class="dv">3</span><span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb66-3" data-line-number="3">  <span class="fu">==&gt;</span> <span class="dv">3</span> <span class="fu">*</span> factorial <span class="dv">2</span></a>
<a class="sourceLine" id="cb66-4" data-line-number="4">  <span class="fu">==&gt;</span> <span class="dv">3</span> <span class="fu">*</span> <span class="dv">2</span> <span class="fu">*</span> factorial <span class="dv">1</span></a>
<a class="sourceLine" id="cb66-5" data-line-number="5">  <span class="fu">==&gt;</span> <span class="dv">3</span> <span class="fu">*</span> <span class="dv">2</span> <span class="fu">*</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb66-6" data-line-number="6">  <span class="fu">==&gt;</span> <span class="dv">6</span></a></code></pre></div>
<p>What happens when you evaluate <code>factorial (-1)</code>?</p>
<p>Here’s another example:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="co">-- compute the sum 1^2+2^2+3^2+...+n^2</span></a>
<a class="sourceLine" id="cb67-2" data-line-number="2">squareSum <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb67-3" data-line-number="3">squareSum n <span class="fu">=</span> n<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> squareSum (n<span class="fu">-</span><span class="dv">1</span>)</a></code></pre></div>
<p>A function can call itself recursively multiple times. As an example let’s consider the <em>Fibonacci sequence</em> from mathematics. The Fibonacci sequence is a sequence of integers with the following definition.</p>
<blockquote>
<p>The sequence starts with 1, 1. To get the next element of the sequence, sum the previous two elements of the sequence.</p>
</blockquote>
<p>The first elements of the Fibonacci sequence are 1, 1, 2, 3, 5, 8, 13 and so on. Here’s a function <code>fibonacci</code> wich computes the <code>n</code>th element in the Fibonacci sequence. Note how it mirrors the mathematical definition.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb68-1" data-line-number="1"><span class="co">-- Fibonacci numbers, slow version</span></a>
<a class="sourceLine" id="cb68-2" data-line-number="2">fibonacci <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb68-3" data-line-number="3">fibonacci <span class="dv">2</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb68-4" data-line-number="4">fibonacci n <span class="fu">=</span> fibonacci (n<span class="fu">-</span><span class="dv">2</span>) <span class="fu">+</span> fibonacci (n<span class="fu">-</span><span class="dv">1</span>)</a></code></pre></div>
<p>Here’s how <code>fibonacci 5</code> evaluates:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb69-1" data-line-number="1">fibonacci <span class="dv">5</span></a>
<a class="sourceLine" id="cb69-2" data-line-number="2">  <span class="fu">==&gt;</span> fibonacci <span class="dv">3</span>                 <span class="fu">+</span> fibonacci <span class="dv">4</span></a>
<a class="sourceLine" id="cb69-3" data-line-number="3">  <span class="fu">==&gt;</span> (fibonacci <span class="dv">1</span> <span class="fu">+</span> fibonacci <span class="dv">2</span>) <span class="fu">+</span> fibonacci <span class="dv">4</span></a>
<a class="sourceLine" id="cb69-4" data-line-number="4">  <span class="fu">==&gt;</span> (    <span class="dv">1</span>       <span class="fu">+</span>       <span class="dv">1</span>    ) <span class="fu">+</span> fibonacci <span class="dv">4</span></a>
<a class="sourceLine" id="cb69-5" data-line-number="5">  <span class="fu">==&gt;</span> (    <span class="dv">1</span>       <span class="fu">+</span>       <span class="dv">1</span>    ) <span class="fu">+</span> (fibonacci <span class="dv">2</span> <span class="fu">+</span> fibonacci <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb69-6" data-line-number="6">  <span class="fu">==&gt;</span> (    <span class="dv">1</span>       <span class="fu">+</span>       <span class="dv">1</span>    ) <span class="fu">+</span> (fibonacci <span class="dv">2</span> <span class="fu">+</span> (fibonacci <span class="dv">1</span> <span class="fu">+</span> fibonacci <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb69-7" data-line-number="7">  <span class="fu">==&gt;</span> (    <span class="dv">1</span>       <span class="fu">+</span>       <span class="dv">1</span>    ) <span class="fu">+</span> (    <span class="dv">1</span>       <span class="fu">+</span> (    <span class="dv">1</span>       <span class="fu">+</span>     <span class="dv">1</span>      ))</a>
<a class="sourceLine" id="cb69-8" data-line-number="8">  <span class="fu">==&gt;</span> <span class="dv">5</span></a></code></pre></div>
<p>Note how <code>fibonacci 3</code> gets evaluated twice and <code>fibonacci 2</code> three times. This is not the most efficient implementation of the <code>fibonacci</code> function. We’ll get back to this in the next lecture. Another way to think about the evaluation of the fibonacci function is to visualize it as a tree (we abbreviate <code>fibonacci</code> as <code>fib</code>):</p>
<pre><code>                          _____ + _____
fib 5        ==&gt;          |           |
                        fib 3       fib 4


             ==&gt;          __________ + __________
                          |                     |
                    _____ + _____         _____ + _____
                    |           |         |           |
                  fib 1       fib 2     fib 2       fib 3


             ==&gt;          __________ + __________
                          |                     |
                    _____ + _____         _____ + _____
                    |           |         |           |
                    1           1         1       ___ + ___
                                                  |       |
                                                fib 1   fib 2


             ==&gt;          __________ + __________
                          |                     |
                    _____ + _____         _____ + _____
                    |           |         |           |
                    1           1         1       ___ + ___
                                                  |       |
                                                  1       1</code></pre>
<p>This tree then exaclty corresponds with the expression <code>(1 + 1) + (1 + (1 + 1))</code>. Recursion can often produce chain-like, tree-like, nested, or loopy structures and computations. Recursion is one of the main techniques in functional programming, so it’s worth spending some effort in learning it.</p>
<h2 id="all-together-now"><span class="header-section-number">1.10</span> All together now!</h2>
<p>Finally, here’s a complete Haskell module that uses ifs, pattern matching, local defintions and recursion. The module is interested in the <a href="https://en.wikipedia.org/wiki/Collatz_conjecture"><em>Collatz conjecture</em></a>, a famous open problem in mathematics. It asks:</p>
<blockquote>
<p>Does the Collatz sequence eventually reach 1 for all positive integer initial values?</p>
</blockquote>
<p>The Collatz sequence is defined by taking any number as a starting value, and then repeatedly performing the following operation:</p>
<ul>
<li>if the number is even, divide it by two</li>
<li>if the number is odd, triple it and add one</li>
</ul>
<p>As an example, the Collatz sequence for 3 is: 3, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1, 4, 2, 1 … As you can see, once the number reaches 1, it gets caught in a loop.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb71-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Collatz</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb71-2" data-line-number="2"></a>
<a class="sourceLine" id="cb71-3" data-line-number="3"><span class="co">-- one step of the Collatz sequence</span></a>
<a class="sourceLine" id="cb71-4" data-line-number="4"><span class="ot">step ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb71-5" data-line-number="5">step x <span class="fu">=</span> <span class="kw">if</span> even x <span class="kw">then</span> down <span class="kw">else</span> up</a>
<a class="sourceLine" id="cb71-6" data-line-number="6">  <span class="kw">where</span> down <span class="fu">=</span> div x <span class="dv">2</span></a>
<a class="sourceLine" id="cb71-7" data-line-number="7">        up <span class="fu">=</span> <span class="dv">3</span><span class="fu">*</span>x<span class="fu">+</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb71-8" data-line-number="8"></a>
<a class="sourceLine" id="cb71-9" data-line-number="9"><span class="co">-- collatz x computes how many steps it takes for the Collatz sequence</span></a>
<a class="sourceLine" id="cb71-10" data-line-number="10"><span class="co">-- to reach 1 when starting from x</span></a>
<a class="sourceLine" id="cb71-11" data-line-number="11"><span class="ot">collatz ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb71-12" data-line-number="12">collatz <span class="dv">1</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb71-13" data-line-number="13">collatz x <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> collatz (step x)</a>
<a class="sourceLine" id="cb71-14" data-line-number="14"></a>
<a class="sourceLine" id="cb71-15" data-line-number="15"><span class="co">-- longest finds the number with the longest Collatz sequence for initial values</span></a>
<a class="sourceLine" id="cb71-16" data-line-number="16"><span class="co">-- between 0 and upperBound</span></a>
<a class="sourceLine" id="cb71-17" data-line-number="17"><span class="ot">longest ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb71-18" data-line-number="18">longest upperBound <span class="fu">=</span> longest&#39; <span class="dv">0</span> <span class="dv">0</span> upperBound</a>
<a class="sourceLine" id="cb71-19" data-line-number="19"></a>
<a class="sourceLine" id="cb71-20" data-line-number="20"><span class="co">-- helper function for longest</span></a>
<a class="sourceLine" id="cb71-21" data-line-number="21"><span class="ot">longest&#39; ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb71-22" data-line-number="22"><span class="co">-- end of recursion, return longest length found</span></a>
<a class="sourceLine" id="cb71-23" data-line-number="23">longest&#39; number _ <span class="dv">0</span> <span class="fu">=</span> number</a>
<a class="sourceLine" id="cb71-24" data-line-number="24"><span class="co">-- recursion step: check if n has a longer Collatz sequence than the current known longest</span></a>
<a class="sourceLine" id="cb71-25" data-line-number="25">longest&#39; number maxlength n <span class="fu">=</span> <span class="kw">if</span> length <span class="fu">&gt;</span> maxlength</a>
<a class="sourceLine" id="cb71-26" data-line-number="26">               <span class="kw">then</span> longest&#39; n length (n<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb71-27" data-line-number="27">               <span class="kw">else</span> longest&#39; number maxlength (n<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb71-28" data-line-number="28">  <span class="kw">where</span> length <span class="fu">=</span> collatz n</a></code></pre></div>
<p>We can load the program in GHCi and play with it.</p>
<pre><code>$ stack ghci
GHCi, version 8.2.2: http://www.haskell.org/ghc/  :? for help
Prelude&gt; :load Collatz.hs
[1 of 1] Compiling Collatz          ( Collatz.hs, interpreted )
Ok, one module loaded.
*Collatz&gt;</code></pre>
<p>Let’s verify that our program computes the start of the Collatz sequence for 3 correctly.</p>
<pre><code>*Collatz&gt; step 3
10
*Collatz&gt; step 10
5
*Collatz&gt; step 5
16</code></pre>
<p>How many steps does it take for 3 to reach 1?</p>
<pre><code>*Collatz&gt; collatz 3
7</code></pre>
<p>What’s the longest Collatz sequence for a staring value under 10? What about 100?</p>
<pre><code>*Collatz&gt; longest 10
9
*Collatz&gt; longest 100
97</code></pre>
<p>The lengths of theze Collatz sequences are:</p>
<pre><code>*Collatz&gt; collatz 9
19
*Collatz&gt; collatz 97
118</code></pre>
<h2 id="a-word-about-indentation"><span class="header-section-number">1.11</span> A word about indentation</h2>
<p>The previous examples have been fancily indented. In Haskell indentation matters, a bit like in Python. The complete set of rules for indentation is hard to describe, but you should get along fine with these rules of thumb:</p>
<ol type="1">
<li>Things that are grouped together start from the same column</li>
<li>If an expression (or equation) has to be split on to many lines, increase indentation</li>
</ol>
<p>While you can get away with using tabs, it is highly recommended to use spaces for all indenting.</p>
<p>Some examples are in order.</p>
<p>These all are ok:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb77-1" data-line-number="1">i x <span class="fu">=</span> <span class="kw">let</span> y <span class="fu">=</span> x<span class="fu">+</span>x<span class="fu">+</span>x<span class="fu">+</span>x<span class="fu">+</span>x<span class="fu">+</span>x <span class="kw">in</span> div y <span class="dv">5</span></a>
<a class="sourceLine" id="cb77-2" data-line-number="2"></a>
<a class="sourceLine" id="cb77-3" data-line-number="3"><span class="co">-- let and in are grouped together, an expression is split</span></a>
<a class="sourceLine" id="cb77-4" data-line-number="4">j x <span class="fu">=</span> <span class="kw">let</span> y <span class="fu">=</span> x<span class="fu">+</span>x<span class="fu">+</span>x</a>
<a class="sourceLine" id="cb77-5" data-line-number="5">              <span class="fu">+</span>x<span class="fu">+</span>x<span class="fu">+</span>x</a>
<a class="sourceLine" id="cb77-6" data-line-number="6">      <span class="kw">in</span> div y <span class="dv">5</span></a>
<a class="sourceLine" id="cb77-7" data-line-number="7"></a>
<a class="sourceLine" id="cb77-8" data-line-number="8"><span class="co">-- the definitions of a and b are grouped together</span></a>
<a class="sourceLine" id="cb77-9" data-line-number="9">k <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb77-10" data-line-number="10">  <span class="kw">where</span> a <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb77-11" data-line-number="11">        b <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb77-12" data-line-number="12"></a>
<a class="sourceLine" id="cb77-13" data-line-number="13">l <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb77-14" data-line-number="14">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb77-15" data-line-number="15">    a <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb77-16" data-line-number="16">    b <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p>These are not ok:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb78-1" data-line-number="1"><span class="co">-- indentation not increased even though expression split on many lines</span></a>
<a class="sourceLine" id="cb78-2" data-line-number="2">i x <span class="fu">=</span> <span class="kw">let</span> y <span class="fu">=</span> x<span class="fu">+</span>x<span class="fu">+</span>x<span class="fu">+</span>x<span class="fu">+</span>x<span class="fu">+</span>x</a>
<a class="sourceLine" id="cb78-3" data-line-number="3"><span class="kw">in</span> div y <span class="dv">5</span></a>
<a class="sourceLine" id="cb78-4" data-line-number="4"></a>
<a class="sourceLine" id="cb78-5" data-line-number="5"><span class="co">-- indentation not increased even though expression is split</span></a>
<a class="sourceLine" id="cb78-6" data-line-number="6">j x <span class="fu">=</span> <span class="kw">let</span> y <span class="fu">=</span> x<span class="fu">+</span>x<span class="fu">+</span>x</a>
<a class="sourceLine" id="cb78-7" data-line-number="7">      <span class="fu">+</span>x<span class="fu">+</span>x<span class="fu">+</span>x</a>
<a class="sourceLine" id="cb78-8" data-line-number="8">      <span class="kw">in</span> div y <span class="dv">5</span></a>
<a class="sourceLine" id="cb78-9" data-line-number="9"></a>
<a class="sourceLine" id="cb78-10" data-line-number="10"><span class="co">-- grouped things are not aligned</span></a>
<a class="sourceLine" id="cb78-11" data-line-number="11">k <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb78-12" data-line-number="12">  <span class="kw">where</span> a <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb78-13" data-line-number="13">      b <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb78-14" data-line-number="14"></a>
<a class="sourceLine" id="cb78-15" data-line-number="15"><span class="co">-- grouped things are not aligned</span></a>
<a class="sourceLine" id="cb78-16" data-line-number="16">l <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb78-17" data-line-number="17">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb78-18" data-line-number="18">    a <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb78-19" data-line-number="19">     b <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb78-20" data-line-number="20"></a>
<a class="sourceLine" id="cb78-21" data-line-number="21"><span class="co">-- where is part of the equation, so indentation needs to increase</span></a>
<a class="sourceLine" id="cb78-22" data-line-number="22">l <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb78-23" data-line-number="23"><span class="kw">where</span></a>
<a class="sourceLine" id="cb78-24" data-line-number="24">  a <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb78-25" data-line-number="25">  b <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p>If you make a mistake with the indentation, you’ll typically get a parse error like this:</p>
<pre><code>Indent.hs:2:1: error: parse error on input ‘where’</code></pre>
<p>The error includes the line number, so just go over that line again. If you can’t seem to get indentation to work, try putting everything on just one long line at first.</p>
<h2 id="quiz"><span class="header-section-number">1.12</span> Quiz</h2>
<p>At the end of each lecture you’ll find a quiz like this. The quizes aren’t graded, they’re just here to help you check you’ve understood the chapter. You can check your answer by clicking on an option. You’ll see a green background if you were right, a red one if you were wrong. Feel free to guess as many times as you want, just make sure you understand why the right option is right in the end.</p>
<p>What is the Haskell equivalent of the C/Java/Python expression <code>combine(prettify(lawn),construct(house,concrete))</code>?</p>
<ol class="quiz">
<li>
<code>combine prettify (lawn) construct (house concerete)</code>
</li>
<li>
<code>combine (prettify lawn (counstruct house concrete))</code>
</li>
<li class="correct">
<code>combine (prettify lawn) (construct house concrete)</code>
</li>
</ol>
What is the C/Java/Python equivalent of the Haskell expression <code>send metric (double population + increase)</code>?
<ol class="quiz">
<li>
<code>send(metric(double(population+increase)))</code>
</li>
<li>
<code>send(metric(double(population)+increase))</code>
</li>
<li class="correct">
<code>send(metric,double(population)+increase)</code>
</li>
<li>
<code>send(metric,double(population+increase))</code>
</li>
</ol>
<p>Which one of the following claims is true in Haskell?</p>
<ol class="quiz">
<li class="correct">
Every value has a type
</li>
<li>
Every type has a value
</li>
<li>
Every statement has a type
</li>
</ol>
<p>Which one of the following claims true in Haskell?</p>
<ol class="quiz">
<li>
It’s impossible to reuse the name of a variable
</li>
<li>
It’s possible to reassign a value to a variable
</li>
<li class="correct">
An <code>if</code> always requires both <code>then</code> and <code>else</code>
</li>
</ol>
<p>What does the function <code>f x = if even (x + 1) then x + 1 else f (x - 1)</code> do?</p>
<ol class="quiz">
<li class="correct">
Maps every value <code>x</code> to the least even number greater than or equal to <code>x</code>
</li>
<li>
Maps every value <code>x</code> to the greatest even number less than or equal to <code>x</code>
</li>
<li>
Maps every value to itself
</li>
</ol>
<p>Why is <code>3 * &quot;F00&quot;</code> not valid Haskell?</p>
<ol class="quiz">
<li class="correct">
<code>3</code> and <code>&quot;F00&quot;</code> have different types
</li>
<li>
All numeric values need a decimal point
</li>
<li>
<code>&quot;F00&quot;</code> needs the prefix “0x”
</li>
</ol>
<p>Why does <code>7.0 `div` 2</code> give an error?</p>
<ol class="quiz">
<li class="correct">
Because <code>div</code> is not defined for the type <code>Double</code>
</li>
<li>
Because <code>div</code> is not defined for the type <code>Int</code>
</li>
<li>
Because <code>`...`</code> is used for delimiting strings.
</li>
</ol>
<h2 id="working-on-the-exercises"><span class="header-section-number">1.13</span> Working on the exercises</h2>
<p>The course materials, including exercises, are available in a Git repository on GitHub at <a href="https://github.com/moocfi/haskell-mooc" class="uri">https://github.com/moocfi/haskell-mooc</a>.</p>
<p>If you’re not familiar with Git, <a href="https://help.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository">this might help</a>.</p>
<p>Once you’ve cloned the <code>haskell-mooc</code> repository, go into the <code>exercises</code> directory. To download dependencies needed for running the exercise tests (like the correct version of GHC and various libraries), run this command in your terminal. This might take a while.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb80-1" data-line-number="1"><span class="ex">stack</span> build</a></code></pre></div>
<p>You’ll find the first set of exercises in the file <code>Set1.hs</code>. This is a Haskell source file that you should edit according to the instructions in the file itself. You can check your answers by running this command in your terminal:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb81-1" data-line-number="1"><span class="ex">stack</span> runhaskell Set1Test.hs</a></code></pre></div>
<p>The output of the tests looks something like this:</p>
<pre><code>===== EXERCISE 1
+++++ Pass
===== EXERCISE 2
+++++ Pass
===== EXERCISE 3
*** Failed! Falsified (after 2 tests and 1 shrink):
quadruple 1
  Expected: 4
  Was: 2

----- Fail
===== EXERCISE 4
+++++ Pass
===== EXERCISE 5
+++++ Pass
===== EXERCISE 6
+++++ Pass
===== EXERCISE 7
+++++ Pass
===== EXERCISE 8
+++++ Pass
===== EXERCISE 9
+++++ Pass
===== EXERCISE 10
+++++ Pass
===== EXERCISE 11
+++++ Pass
===== EXERCISE 12
+++++ Pass
===== EXERCISE 13
+++++ Pass
===== EXERCISE 14
+++++ Pass
===== EXERCISE 15
+++++ Pass
===== EXERCISE 16
+++++ Pass
===== EXERCISE 17
+++++ Pass
===== EXERCISE 18
+++++ Pass
===== EXERCISE 19
+++++ Pass
===== TOTAL
1101111111111111111
18 / 19</code></pre>
<p>As you can see, I’ve made a mistake in exercise 3. I can verify the mistake myself by loading my answers in GHCi:</p>
<pre><code>$ stack ghci Set1.hs
GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
[1 of 2] Compiling Mooc.Todo        ( Mooc/Todo.hs, interpreted )
[2 of 2] Compiling Set1             ( Set1.hs, interpreted )
Ok, two modules loaded.
*Set1&gt; quadruple 1
2</code></pre>
<p>Once you’re done with an exercise set, you can turn it in on the <a href="https://haskell.mooc.fi/submit.php">Submit page</a> on the course pages. After that you can see the results of your submission on the <a href="https://haskell.mooc.fi/results.php">Results page</a> and your total score on the <a href="https://haskell.mooc.fi/status.php">My status page</a>.</p>
<p><strong>Note!</strong> you may turn in an exercise set as many times as you want.</p>
<p><strong>Note!</strong> if you don’t want to use Stack or can’t get it working, you should also be able to run the tests with <a href="https://www.haskell.org/cabal/download.html">Cabal</a> like this:</p>
<pre class="shell"><code>cabal v2-build
cabal v2-exec runhaskell Set1Test.hs</code></pre>
<h2 id="exercises"><span class="header-section-number">1.14</span> Exercises</h2>
<ul>
<li><a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set1.hs">Set1</a></li>
</ul>
<p>Remember to give <a href="https://forms.gle/YCo2jAaUTg9vER7G6">feedback</a>!</p>
<h1 id="lecture-2-either-you-die-a-hero"><span class="header-section-number">2</span> Lecture 2: Either You Die a Hero…</h1>
<ul>
<li>More about recursion</li>
<li>Guards</li>
<li>More types: lists, <code>Maybe</code>, <code>Either</code></li>
<li>Polymorphism</li>
</ul>
<h2 id="recursion-and-helper-functions"><span class="header-section-number">2.1</span> Recursion and Helper Functions</h2>
<p>Often you’ll find you need helper variables in recursion to keep track of things. You can get them by defining a helper function with more arguments. Analogy: arguments of the helper function are variables you update in your loop.</p>
<p>Here’s an example of how you would convert a loop (in Java or Python) into a recursive helper function in Haskell.</p>
<p>Java:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb85-1" data-line-number="1"><span class="kw">public</span> <span class="dt">int</span> <span class="fu">repeatString</span>(<span class="dt">int</span> n, <span class="bu">String</span> str) {</a>
<a class="sourceLine" id="cb85-2" data-line-number="2">    <span class="bu">String</span> result = <span class="st">&quot;&quot;</span>;</a>
<a class="sourceLine" id="cb85-3" data-line-number="3">    <span class="kw">while</span> (n&gt;<span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb85-4" data-line-number="4">        result = result+str;</a>
<a class="sourceLine" id="cb85-5" data-line-number="5">        n = n<span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb85-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb85-7" data-line-number="7">    <span class="kw">return</span> result;</a>
<a class="sourceLine" id="cb85-8" data-line-number="8">}</a></code></pre></div>
<p>Python:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb86-1" data-line-number="1"><span class="kw">def</span> repeatString(n, <span class="bu">str</span>):</a>
<a class="sourceLine" id="cb86-2" data-line-number="2">    result <span class="op">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb86-3" data-line-number="3">    <span class="cf">while</span> n<span class="op">&gt;</span><span class="dv">0</span>:</a>
<a class="sourceLine" id="cb86-4" data-line-number="4">        result <span class="op">=</span> result<span class="op">+</span><span class="bu">str</span></a>
<a class="sourceLine" id="cb86-5" data-line-number="5">        n <span class="op">=</span> n<span class="dv">-1</span></a>
<a class="sourceLine" id="cb86-6" data-line-number="6">    <span class="cf">return</span> result</a></code></pre></div>
<p>Haskell:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb87-1" data-line-number="1">repeatString n str <span class="fu">=</span> repeatHelper n str <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb87-2" data-line-number="2"></a>
<a class="sourceLine" id="cb87-3" data-line-number="3">repeatHelper n str result <span class="fu">=</span> <span class="kw">if</span> (n<span class="fu">==</span><span class="dv">0</span>)</a>
<a class="sourceLine" id="cb87-4" data-line-number="4">                            <span class="kw">then</span> result</a>
<a class="sourceLine" id="cb87-5" data-line-number="5">                            <span class="kw">else</span> repeatHelper (n<span class="fu">-</span><span class="dv">1</span>) str (result<span class="fu">++</span>str)</a></code></pre></div>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb88-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> repeatString <span class="dv">3</span> <span class="st">&quot;ABC&quot;</span></a>
<a class="sourceLine" id="cb88-2" data-line-number="2"><span class="st">&quot;ABCABCABC&quot;</span></a></code></pre></div>
<p>You might have noticed that the Java and Python implementations look a bit weird since they use while loops instead of for loops. This is because this way the conversion to Haskell is more straightforward.</p>
<p>This can be made a bit tidier by using pattern matching instead of an <code>if</code>:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb89-1" data-line-number="1">repeatString n str <span class="fu">=</span> repeatHelper n str <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb89-2" data-line-number="2"></a>
<a class="sourceLine" id="cb89-3" data-line-number="3">repeatHelper <span class="dv">0</span> _   result <span class="fu">=</span> result</a>
<a class="sourceLine" id="cb89-4" data-line-number="4">repeatHelper n str result <span class="fu">=</span> repeatHelper (n<span class="fu">-</span><span class="dv">1</span>) str (result<span class="fu">++</span>str)</a></code></pre></div>
<p>Here’s another example with more variables: computing fibonacci numbers efficiently.</p>
<p>Java:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb90-1" data-line-number="1"><span class="kw">public</span> <span class="dt">int</span> <span class="fu">fibonacci</span>(<span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb90-2" data-line-number="2">    <span class="dt">int</span> a = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb90-3" data-line-number="3">    <span class="dt">int</span> b = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb90-4" data-line-number="4">    <span class="kw">while</span> (n&gt;<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb90-5" data-line-number="5">        <span class="dt">int</span> c = a+b;</a>
<a class="sourceLine" id="cb90-6" data-line-number="6">        a=b;</a>
<a class="sourceLine" id="cb90-7" data-line-number="7">        b=c;</a>
<a class="sourceLine" id="cb90-8" data-line-number="8">        n--;</a>
<a class="sourceLine" id="cb90-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb90-10" data-line-number="10">    <span class="kw">return</span> b;</a>
<a class="sourceLine" id="cb90-11" data-line-number="11">}</a></code></pre></div>
<p>Python:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb91-1" data-line-number="1"><span class="kw">def</span> fibonacci(n):</a>
<a class="sourceLine" id="cb91-2" data-line-number="2">    a <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb91-3" data-line-number="3">    b <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb91-4" data-line-number="4">    <span class="cf">while</span> n<span class="op">&gt;</span><span class="dv">1</span>:</a>
<a class="sourceLine" id="cb91-5" data-line-number="5">        c <span class="op">=</span> a<span class="op">+</span>b</a>
<a class="sourceLine" id="cb91-6" data-line-number="6">        a <span class="op">=</span> b</a>
<a class="sourceLine" id="cb91-7" data-line-number="7">        b <span class="op">=</span> c</a>
<a class="sourceLine" id="cb91-8" data-line-number="8">        n <span class="op">=</span> n<span class="dv">-1</span></a>
<a class="sourceLine" id="cb91-9" data-line-number="9">    <span class="cf">return</span> b</a></code></pre></div>
<p>Haskell:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb92-1" data-line-number="1"><span class="co">-- fibonacci numbers, fast version</span></a>
<a class="sourceLine" id="cb92-2" data-line-number="2"><span class="ot">fibonacci ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb92-3" data-line-number="3">fibonacci n <span class="fu">=</span> fibonacci&#39; <span class="dv">0</span> <span class="dv">1</span> n</a>
<a class="sourceLine" id="cb92-4" data-line-number="4"></a>
<a class="sourceLine" id="cb92-5" data-line-number="5"><span class="ot">fibonacci&#39; ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb92-6" data-line-number="6">fibonacci&#39; a b <span class="dv">1</span> <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb92-7" data-line-number="7">fibonacci&#39; a b n <span class="fu">=</span> fibonacci&#39; b (a<span class="fu">+</span>b) (n<span class="fu">-</span><span class="dv">1</span>)</a></code></pre></div>
<p>Take a while to study these and note how the Haskell recursion has the same format as the loop.</p>
<p>Sidenote: Haskell programs often use the apostrophe to name helper functions and alternative versions of functions. Thus the name <code>fibonnaci'</code> for the helper function above. Names like <code>foo'</code> are usually read <em>foo prime</em> (like in mathematics).</p>
<p>I said earlier that this version of fibonacci is more efficient. Can you see why? The answer is that there are less recursive calls. The expression <code>fibonacci' _ _ n</code> calls <code>fibonacci' _ _ (n-1)</code> once, and this means that we can compute <code>fibonacci' _ _ n</code> in <code>n</code> steps.</p>
<p>This type of recursion where a function just directly calls itself with different arguments is called <em>tail recursion</em>. As you’ve seen above, tail recursion corresponds to loops. This is why tail recursion is often fast: the compiler can generate a loop in machine code when it sees tail recursion.</p>
<h2 id="guards"><span class="header-section-number">2.2</span> Guards</h2>
<p>Before we move on to new types, let’s go over one more piece of Haskell syntax.</p>
<p>The <code>if then else</code> is often a bit cumbersome, especially when you have multiple cases. An easier alternative is Haskell’s <em>conditional definition</em> or <em>guarded definition</em>. This is a bit like pattern matching in that you have multiple equations, but you can have arbitrary code deciding which equation to use. Guarded definitions look like this:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb93-1" data-line-number="1">f x y z</a>
<a class="sourceLine" id="cb93-2" data-line-number="2">  <span class="fu">|</span> condition1 <span class="fu">=</span> something</a>
<a class="sourceLine" id="cb93-3" data-line-number="3">  <span class="fu">|</span> condition2 <span class="fu">=</span> other</a>
<a class="sourceLine" id="cb93-4" data-line-number="4">  <span class="fu">|</span> otherwise  <span class="fu">=</span> somethingother</a></code></pre></div>
<p>A condition can be any expression of type <code>Bool</code>. The first condition that evaluates to <code>True</code> is chosen. The word <code>otherwise</code> is just an alias for <code>True</code>. It is used to mark the default case.</p>
<h3 id="examples-1"><span class="header-section-number">2.2.1</span> Examples</h3>
<p>Here are some examples of using guards. First off, we have a function that describes the given number. Note how it is important to have the <code>&quot;Two&quot;</code> case before the <code>&quot;Even&quot;</code> case.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb94-1" data-line-number="1"><span class="ot">describe ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb94-2" data-line-number="2">describe n</a>
<a class="sourceLine" id="cb94-3" data-line-number="3">  <span class="fu">|</span> n<span class="fu">==</span><span class="dv">2</span>      <span class="fu">=</span> <span class="st">&quot;Two&quot;</span></a>
<a class="sourceLine" id="cb94-4" data-line-number="4">  <span class="fu">|</span> even n    <span class="fu">=</span> <span class="st">&quot;Even&quot;</span></a>
<a class="sourceLine" id="cb94-5" data-line-number="5">  <span class="fu">|</span> n<span class="fu">==</span><span class="dv">3</span>      <span class="fu">=</span> <span class="st">&quot;Three&quot;</span></a>
<a class="sourceLine" id="cb94-6" data-line-number="6">  <span class="fu">|</span> n<span class="fu">&gt;</span><span class="dv">100</span>     <span class="fu">=</span> <span class="st">&quot;Big!!&quot;</span></a>
<a class="sourceLine" id="cb94-7" data-line-number="7">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="st">&quot;The number &quot;</span><span class="fu">++</span>show n</a></code></pre></div>
<p>Here is factorial, implemented with guards instead of pattern matching. Unlike the pattern-matching version, this one doesn’t loop forever with negative inputs.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb95-1" data-line-number="1">factorial n</a>
<a class="sourceLine" id="cb95-2" data-line-number="2">  <span class="fu">|</span> n<span class="fu">&lt;</span><span class="dv">0</span>       <span class="fu">=</span> <span class="fu">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb95-3" data-line-number="3">  <span class="fu">|</span> n<span class="fu">==</span><span class="dv">0</span>      <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb95-4" data-line-number="4">  <span class="fu">|</span> otherwise <span class="fu">=</span> n <span class="fu">*</span> factorial (n<span class="fu">-</span><span class="dv">1</span>)</a></code></pre></div>
<p>You can even combine guards with pattern matching. Here’s the implementation of a simple age guessing game:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb96-1" data-line-number="1"><span class="ot">guessAge ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb96-2" data-line-number="2">guessAge <span class="st">&quot;Griselda&quot;</span> age</a>
<a class="sourceLine" id="cb96-3" data-line-number="3">    <span class="fu">|</span> age <span class="fu">&lt;</span> <span class="dv">47</span> <span class="fu">=</span> <span class="st">&quot;Too low!&quot;</span></a>
<a class="sourceLine" id="cb96-4" data-line-number="4">    <span class="fu">|</span> age <span class="fu">&gt;</span> <span class="dv">47</span> <span class="fu">=</span> <span class="st">&quot;Too high!&quot;</span></a>
<a class="sourceLine" id="cb96-5" data-line-number="5">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="st">&quot;Correct!&quot;</span></a>
<a class="sourceLine" id="cb96-6" data-line-number="6">guessAge <span class="st">&quot;Hansel&quot;</span> age</a>
<a class="sourceLine" id="cb96-7" data-line-number="7">    <span class="fu">|</span> age <span class="fu">&lt;</span> <span class="dv">12</span> <span class="fu">=</span> <span class="st">&quot;Too low!&quot;</span></a>
<a class="sourceLine" id="cb96-8" data-line-number="8">    <span class="fu">|</span> age <span class="fu">&gt;</span> <span class="dv">12</span> <span class="fu">=</span> <span class="st">&quot;Too high!&quot;</span></a>
<a class="sourceLine" id="cb96-9" data-line-number="9">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="st">&quot;Correct!&quot;</span></a>
<a class="sourceLine" id="cb96-10" data-line-number="10">guessAge name age <span class="fu">=</span> <span class="st">&quot;Wrong name!&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb97-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> guessAge <span class="st">&quot;Griselda&quot;</span> <span class="dv">30</span></a>
<a class="sourceLine" id="cb97-2" data-line-number="2"><span class="st">&quot;Too low!&quot;</span></a>
<a class="sourceLine" id="cb97-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> guessAge <span class="st">&quot;Griselda&quot;</span> <span class="dv">60</span></a>
<a class="sourceLine" id="cb97-4" data-line-number="4"><span class="st">&quot;Too high!&quot;</span></a>
<a class="sourceLine" id="cb97-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> guessAge <span class="st">&quot;Griselda&quot;</span> <span class="dv">47</span></a>
<a class="sourceLine" id="cb97-6" data-line-number="6"><span class="st">&quot;Correct!&quot;</span></a>
<a class="sourceLine" id="cb97-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> guessAge <span class="st">&quot;Bob&quot;</span> <span class="dv">30</span></a>
<a class="sourceLine" id="cb97-8" data-line-number="8"><span class="st">&quot;Wrong name!&quot;</span></a>
<a class="sourceLine" id="cb97-9" data-line-number="9"><span class="dt">Prelude</span><span class="fu">&gt;</span> guessAge <span class="st">&quot;Hansel&quot;</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb97-10" data-line-number="10"><span class="st">&quot;Too low!&quot;</span></a></code></pre></div>
<h2 id="lists"><span class="header-section-number">2.3</span> Lists</h2>
<p>So far we’ve always worked with single values like number or booleans. Strings contain multiple characters, but still in some sense a string is just one piece of information. In order to be able to do actual programming, we need to handle variable numbers of items. For this we need <em>data structures</em>.</p>
<p>The basic datastructure in Haskell is the list. Lists are used to store multiple values of the same type (in other words, Haskell lists are homogeneous). This is what a list literal looks like:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb98-1" data-line-number="1">[<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">1</span><span class="fu">+</span><span class="dv">1</span>]</a></code></pre></div>
<p>A list type is written as <code>[Element]</code>, where <code>Element</code> is the type of the lists elements. Here are some more list expressions and their types:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb99-1" data-line-number="1">[<span class="dt">True</span>,<span class="dt">True</span>,<span class="dt">False</span>]<span class="ot"> ::</span> [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb99-2" data-line-number="2">[<span class="st">&quot;Moi&quot;</span>,<span class="st">&quot;Hei&quot;</span>]<span class="ot"> ::</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb99-3" data-line-number="3">[]<span class="ot"> ::</span> [a]                   <span class="co">-- more about this later</span></a>
<a class="sourceLine" id="cb99-4" data-line-number="4">[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">4</span>]]<span class="ot"> ::</span> [[<span class="dt">Int</span>]]    <span class="co">-- a list of lists</span></a>
<a class="sourceLine" id="cb99-5" data-line-number="5">[<span class="dv">1</span><span class="fu">..</span><span class="dv">7</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]             <span class="co">-- range syntax, value [1,2,3,4,5,6,7]</span></a></code></pre></div>
<p>Haskell lists are implemented as singly-linked lists. We’ll return to this later.</p>
<h3 id="list-operations"><span class="header-section-number">2.3.1</span> List operations</h3>
<p>The Haskell standard library comes with lots of functions that operate on lists. Here are some of the most important ones, together with their types. We’ll get back to what <code>[a]</code> actually means in a second, but for now you can imagine it means “any list”.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb100-1" data-line-number="1">head<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a            <span class="co">-- returns the first element</span></a>
<a class="sourceLine" id="cb100-2" data-line-number="2">tail<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]          <span class="co">-- returns everything except the first element</span></a>
<a class="sourceLine" id="cb100-3" data-line-number="3">take<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]   <span class="co">-- returns the n first elements</span></a>
<a class="sourceLine" id="cb100-4" data-line-number="4">drop<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]   <span class="co">-- returns everything except the n first elements</span></a>
<a class="sourceLine" id="cb100-5" data-line-number="5"><span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]   <span class="co">-- lists are catenated with the ++ operator</span></a>
<a class="sourceLine" id="cb100-6" data-line-number="6"><span class="ot">(!!) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a     <span class="co">-- lists are indexed with the !! operator</span></a>
<a class="sourceLine" id="cb100-7" data-line-number="7">reverse<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]       <span class="co">-- reverse a list</span></a>
<a class="sourceLine" id="cb100-8" data-line-number="8">null<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>         <span class="co">-- is this list empty?</span></a>
<a class="sourceLine" id="cb100-9" data-line-number="9">length<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>        <span class="co">-- the length of a list</span></a></code></pre></div>
<p>Sidenote: the last two operations (<code>null</code> and <code>length</code>) actually have more generic types, but here I’m pretending that you can only use them on lists.</p>
<p>Lists can be compared with the familiar <code>==</code> operator.</p>
<p>Do you remember this from our first GHCi session?</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb101-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="st">&quot;asdf&quot;</span></a>
<a class="sourceLine" id="cb101-2" data-line-number="2"><span class="st">&quot;asdf&quot;</span><span class="ot"> ::</span> [<span class="dt">Char</span>]</a></code></pre></div>
<p>This means that <code>String</code> is just an alias for <code>[Char]</code>, which means string is a list of characters. This means you can use all list operations on strings!</p>
<p>Some list operations come from the module <code>Data.List</code>. You can import a module in code or in GHCi with the <code>import Data.List</code> syntax. One example is the <code>sort</code> function which sorts a list:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb102-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb102-2" data-line-number="2"><span class="dt">Prelude</span> <span class="dt">Data.List</span><span class="fu">&gt;</span> sort [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb102-3" data-line-number="3">[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>]</a></code></pre></div>
<p>Note how the set of imported modules shows up in the GHCi prompt.</p>
<h3 id="examples-2"><span class="header-section-number">2.3.2</span> Examples</h3>
<p>Here are some examples of working with lists. In this case, instead of showing you output from GHCi, I merely use <code>==&gt;</code> to show what an expression evaluates to.</p>
<p>Indexing a list:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb103-1" data-line-number="1">[<span class="dv">7</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span>] <span class="fu">!!</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb103-2" data-line-number="2">  <span class="fu">==&gt;</span> <span class="dv">4</span></a></code></pre></div>
<p>Defining a function that discards the 3rd and 4th elements of a list using <code>take</code> and <code>drop</code>:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb104-1" data-line-number="1">f xs <span class="fu">=</span> take <span class="dv">2</span> xs <span class="fu">++</span> drop <span class="dv">4</span> xs</a></code></pre></div>
<div class="sourceCode" id="cb105"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb105-1" data-line-number="1">f [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]  <span class="fu">==&gt;</span>  [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb105-2" data-line-number="2">f [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]        <span class="fu">==&gt;</span>  [<span class="dv">1</span>,<span class="dv">2</span>]</a></code></pre></div>
<p>Rotating a list by taking the first element and moving it to the end:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb106-1" data-line-number="1">g xs <span class="fu">=</span> tail xs <span class="fu">++</span> [head xs]</a></code></pre></div>
<div class="sourceCode" id="cb107"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb107-1" data-line-number="1">g [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]      <span class="fu">==&gt;</span>  [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb107-2" data-line-number="2">g (g [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])  <span class="fu">==&gt;</span>  [<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>]</a></code></pre></div>
<p>Here’s an example of the range syntax:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb108-1" data-line-number="1">reverse [<span class="dv">1</span><span class="fu">..</span><span class="dv">4</span>] <span class="fu">==&gt;</span> [<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a></code></pre></div>
<h2 id="a-word-about-immutability-1"><span class="header-section-number">2.4</span> A word about immutability</h2>
<p>Because Haskell is pure, it also means that functions can’t <em>mutate</em> (change) their inputs. Mutation is a side effect, and Haskell functions are only allowed output via their return value. This means that Haskell list functions always return a new list. In practice:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb109-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> list <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb109-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> reverse list</a>
<a class="sourceLine" id="cb109-3" data-line-number="3">[<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb109-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> list</a>
<a class="sourceLine" id="cb109-5" data-line-number="5">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb109-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> drop <span class="dv">2</span> list</a>
<a class="sourceLine" id="cb109-7" data-line-number="7">[<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb109-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> list</a>
<a class="sourceLine" id="cb109-9" data-line-number="9">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a></code></pre></div>
<p>This might seem very inefficient but it turns out it can be both performant and quite useful. We’ll get back to how Haskell datastructures work in a later lecture.</p>
<h2 id="a-word-about-type-inference-and-polymorphism"><span class="header-section-number">2.5</span> A word about type inference and polymorphism</h2>
<p>So what does a type like <code>head :: [a] -&gt; a</code> mean? It means given a list that contains elements of any type <code>a</code>, the return value will be of the same type <code>a</code>.</p>
<p>In this type, <code>a</code> is a <em>type variable</em>. Type variables are types that start with a small letter, e.g. <code>a</code>, <code>b</code>, <code>thisIsATypeVariable</code>. A type variable means a type that is not yet known, or in other words a type that could be anything. Type variables can turn into <em>concrete types</em> (e.g. <code>Bool</code>) by the process of <em>type inference</em> (also called <em>unification</em>).</p>
<p>Let’s have a look at some examples. If we apply <code>head</code> to a list of booleans, type inference will compare the type of head’s argument, <code>[a]</code>, with the type of the actual argument, <code>[Bool]</code> and deduce that <code>a</code> must be <code>Bool</code>. This means that the return type of <code>head</code> will in this case also be <code>Bool</code>.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb110-1" data-line-number="1">head<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb110-2" data-line-number="2">head [<span class="dt">True</span>,<span class="dt">False</span>]<span class="ot"> ::</span> <span class="dt">Bool</span></a></code></pre></div>
<p>The function <code>tail</code> takes a list, and returns a list of the same type. If we apply <code>tail</code> to a list of booleans, the return value will also be a list of booleans.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb111-1" data-line-number="1">tail<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb111-2" data-line-number="2">tail [<span class="dt">True</span>,<span class="dt">False</span>]<span class="ot"> ::</span> [<span class="dt">Bool</span>]</a></code></pre></div>
<p>If types don’t match, we get a type error. Consider the operator <code>++</code> which takes two lists of the same type, as we can see from its type <code>[a] -&gt; [a] -&gt; [a]</code>. If we try to apply <code>++</code> to a list of booleans and a list of characters we get an error. This is what happens in GHCi:</p>
<pre><code>Prelude&gt; [True,False] ++ &quot;Moi&quot;

&lt;interactive&gt;:1:16:
    Couldn&#39;t match expected type `Bool&#39; against inferred type `Char&#39;
      Expected type: [Bool]
      Inferred type: [Char]
    In the second argument of `(++)&#39;, namely `&quot;Moi&quot;&#39;
    In the expression: [True, False] ++ &quot;Moi&quot;</code></pre>
<p>Type inference is really powerful. It uses the simple process of unification to get us types for practically any Haskell expression. Consider these two functions:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb113-1" data-line-number="1">f xs ys <span class="fu">=</span> [head xs, head ys]</a>
<a class="sourceLine" id="cb113-2" data-line-number="2">g zs <span class="fu">=</span> f <span class="st">&quot;Moi&quot;</span> zs</a></code></pre></div>
<p>We can ask GHCi for their types, and we will see that type inference has figured out that the two arguments to <code>f</code> must have the same type, since their heads get put into the same list.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb114-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t f</a>
<a class="sourceLine" id="cb114-2" data-line-number="2"><span class="ot">f ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a></code></pre></div>
<p>The function <code>g</code>, which fixed one of the arguments of <code>f</code> to a string (i.e. <code>[Char]</code>) gets a narrower type. Type inference has decided that the argument <code>zs</code> to <code>g</code> must also have type <code>[Char]</code>, since otherwise the type of <code>f</code> would not match the call to <code>f</code>.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb115-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t g</a>
<a class="sourceLine" id="cb115-2" data-line-number="2"><span class="ot">g ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</a></code></pre></div>
<h3 id="sidenote-some-terminology"><span class="header-section-number">2.5.1</span> Sidenote: some terminology</h3>
<p>In a type like <code>[Char]</code> we call <code>Char</code> a <em>type parameter</em>. A type like the list type that needs a type parameter is called a <em>parameterized type</em>.</p>
<p>The fact that a function like <code>head</code> can be used with many different types of arguments is called <em>polymorphism</em>. The <code>head</code> function is said to be <em>polymorphic</em>. There are many forms of polymorphism, and this Haskell form that uses type variables is called <em>parametric polymorphism</em>.</p>
<h3 id="sidenote-type-annotations"><span class="header-section-number">2.5.2</span> Sidenote: type annotations</h3>
<p>Since Haskell has type inference, you don’t need to give any type annotations. However even though type annotations aren’t required, there are multiple reasons to add them:</p>
<ol type="1">
<li>They act as documentation</li>
<li>They act as assertions that the compiler checks: help you spot mistakes</li>
<li>You can use type annotations to give a function a narrower type than Haskell infers</li>
</ol>
<p>A good rule of thumb is to give top-level definitions type annotations.</p>
<h2 id="maybe"><span class="header-section-number">2.6</span> Maybe</h2>
<p>In addition to the list type, Haskell has other parameterized types too. Let’s look at a very common and useful one: the <code>Maybe</code> type.</p>
<p>Sometimes an operation doesn’t have a valid return value (E.g. division by zero.). We have a couple of options in this situation. We can use an error value, like <code>-1</code>. This is a bit ugly, not always possible. We can throw an exception. This is impure. In some other languages we would return a special null value that exists in (almost) all types. However Haskell does not have a null.</p>
<p>The solution Haskell offers us instead is to change our return type to a <code>Maybe</code> type. This is pure, safe and neat. The type <code>Maybe a</code> has two <em>constructors</em>: <code>Nothing</code> and <code>Just</code>. <code>Nothing</code> is just a constant, but <code>Just</code> takes a parameter. More concretely:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Values</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Maybe Bool</code></td>
<td style="text-align: left;"><code>Nothing</code>, <code>Just False</code>, <code>Just True</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Maybe Int</code></td>
<td style="text-align: left;"><code>Nothing</code>, <code>Just 0</code>, <code>Just 1</code>, …</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Maybe [Int]</code></td>
<td style="text-align: left;"><code>Nothing</code>, <code>Just []</code>, <code>Just [1,1337]</code>, …</td>
</tr>
</tbody>
</table>
<p>You can think of <code>Maybe a</code> as being a bit like <code>[a]</code> except there can only be 0 or 1 elements, not more. Alternatively, you can think of <code>Maybe a</code> introducing a null value to the type <code>a</code>. If you’re familiar with Java, <code>Maybe Integer</code> is the Haskell equivalent of Java’s <code>Optional&lt;Integer&gt;</code>.</p>
<p>You use a <code>Maybe</code> value by pattern matching on it. Some more examples:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb116-1" data-line-number="1"><span class="ot">intOrZero ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb116-2" data-line-number="2">intOrZero <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb116-3" data-line-number="3">intOrZero (<span class="dt">Just</span> i) <span class="fu">=</span> i</a>
<a class="sourceLine" id="cb116-4" data-line-number="4"></a>
<a class="sourceLine" id="cb116-5" data-line-number="5"><span class="ot">safeHead ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb116-6" data-line-number="6">safeHead xs <span class="fu">=</span> <span class="kw">if</span> null xs <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (head xs)</a>
<a class="sourceLine" id="cb116-7" data-line-number="7"></a>
<a class="sourceLine" id="cb116-8" data-line-number="8"><span class="ot">headOrZero ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb116-9" data-line-number="9">headOrZero xs <span class="fu">=</span> intOrZero (safeHead xs)</a></code></pre></div>
<div class="sourceCode" id="cb117"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb117-1" data-line-number="1">headOrZero []  <span class="fu">==&gt;</span> intOrZero (safeHead [])  <span class="fu">==&gt;</span> intOrZero <span class="dt">Nothing</span>  <span class="fu">==&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb117-2" data-line-number="2">headOrZero [<span class="dv">1</span>] <span class="fu">==&gt;</span> intOrZero (safeHead [<span class="dv">1</span>]) <span class="fu">==&gt;</span> intOrZero (<span class="dt">Just</span> <span class="dv">1</span>) <span class="fu">==&gt;</span> <span class="dv">1</span></a></code></pre></div>
<h2 id="sidenote-constructors"><span class="header-section-number">2.7</span> Sidenote: Constructors</h2>
<p>As you can see above, we can pattern match on the constructors of <code>Maybe</code>: <code>Just</code> and <code>Nothing</code>. We’ll get back to what constructors mean later. For now it’s enough to note that constructors are special values that start with a capital letter that you can pattern match on.</p>
<p>Other constructors that we’ve already seen include the constructors of <code>Bool</code> – <code>True</code> and <code>False</code>. We’ll introduce the constructors of the list type on the next lecture.</p>
<p>Constructors can be used just like Haskell values. Constructors that take no arguments like <code>Nothing</code>, and <code>False</code> are just constants. Constructors like <code>Just</code> that take an argument behave like functions. They even have function types!</p>
<pre><code>Prelude&gt; :t Just
Just :: a -&gt; Maybe a</code></pre>
<h2 id="the-either-type"><span class="header-section-number">2.8</span> The <code>Either</code> type</h2>
<p>Sometimes it would be nice if you could add an error message or something to <code>Nothing</code>. That’s why we the have <code>Either</code> type. The <code>Either</code> type takes two type arguments. The type <code>Either a b</code> has two constructors: <code>Left</code> and <code>Right</code>. Both take an argument, <code>Left</code> an argument of type <code>a</code> and <code>Right</code> and argument of type <code>b</code>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Values</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Either Int Bool</code></td>
<td style="text-align: left;"><code>Left 0</code>, <code>Left 1</code>, <code>Right False</code>, <code>Right True</code>, …</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Either String [Int]</code></td>
<td style="text-align: left;"><code>Left &quot;asdf&quot;</code>, <code>Right [0,1,2]</code>, …</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Either Integer Integer</code></td>
<td style="text-align: left;"><code>Left 0</code>, <code>Right 0</code>, <code>Left 1</code>, <code>Right 1</code>, …</td>
</tr>
</tbody>
</table>
<p>Here’s a simple example: a <code>readInt</code> function that only knows a couple of numbers and returns a descriptive error for the rest. Note the Haskell convention of using <code>Left</code> for errors and <code>Right</code> for success.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb119-1" data-line-number="1">readInt<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb119-2" data-line-number="2">readInt <span class="st">&quot;0&quot;</span> <span class="fu">=</span> <span class="dt">Right</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb119-3" data-line-number="3">readInt <span class="st">&quot;1&quot;</span> <span class="fu">=</span> <span class="dt">Right</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb119-4" data-line-number="4">readInt s <span class="fu">=</span> <span class="dt">Left</span> (<span class="st">&quot;Unsupported string: &quot;</span> <span class="fu">++</span> s)</a></code></pre></div>
<p>Sidenote: the constructors of <code>Either</code> are called <code>Left</code> and <code>Right</code> because they refer to the left and right type arguments of <code>Either</code>. Note how in <code>Either a b</code>, <code>a</code> is the left argument and <code>b</code> is the right argument. Thus <code>Left</code> contains a value of type <code>a</code> and likewise <code>Right</code> of type <code>b</code>. The convention of using <code>Right</code> for success is probably simply because right also means correct. No offense is intended to left-handed people.</p>
<p>Here’s another example: pattern matching an Either.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb120-1" data-line-number="1"><span class="ot">iWantAString ::</span> <span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb120-2" data-line-number="2">iWantAString (<span class="dt">Right</span> str)   <span class="fu">=</span> str</a>
<a class="sourceLine" id="cb120-3" data-line-number="3">iWantAString (<span class="dt">Left</span> number) <span class="fu">=</span> show number</a></code></pre></div>
<p>As you recall, Haskell lists can only contain elements of the same type. You can’t have a value like <code>[1,&quot;foo&quot;,2]</code>. However, you can use a type like <code>Either</code> to represent lists that can contain two different types of values. For example we could track the number of people on a lecture, with a possibility of adding an explanation if a value is missing:</p>
<pre><code>lectureParticipants :: [Either String Int]
lectureParticipants = [Right 10, Right 13, Left &quot;easter vacation&quot;, Right 17, Left &quot;lecturer was sick&quot;, Right 3]</code></pre>
<h2 id="quiz-1"><span class="header-section-number">2.9</span> Quiz</h2>
<p>How many values does <code>f x = [x,x]</code> return?</p>
<ol class="quiz">
<li>
Zero
<li class="correct">
One
</li>
<li>
Two
</ol>
<p>Why does the expression <code>Nothing 1</code> cause a type error?</p>
<ol class="quiz">
<li class="correct">
Because <code>Nothing</code> takes no arguments
</li>
<li>
Because <code>Nothing</code> returns nothing
</li>
<li>
Because <code>Nothing</code> is a constructor
</li>
</ol>
<p>What is the type of the function <code>f x y = if x &amp;&amp; y then Right x else Left &quot;foo&quot;</code>?</p>
<ol class="quiz">
<li>
<code>Bool -&gt; Bool -&gt; Either Bool String</code>
</li>
<li>
<code>String -&gt; String -&gt; Either String String</code>
</li>
<li class="correct">
<code>Bool -&gt; Bool -&gt; Either String Bool</code>
</li>
</ol>
<p>Which of the following functions could have the type <code>Bool -&gt; Int -&gt; [Bool]</code></p>
<ol class="quiz">
<li>
<code>f x y = [0, y]</code>
</li>
<li class="correct">
<code>f x y = [x, True]</code>
</li>
<li>
<code>f x y = [y, True]</code>
</li>
</ol>
<p>What is the type of this function? <code>justBoth a b = [Just a, Just b]</code></p>
<ol class="quiz">
<li>
<code>a -&gt; b -&gt; [Maybe a, Maybe b]</code>
</li>
<li>
<code>a -&gt; a -&gt; [Just a]</code>
</li>
<li>
<code>a -&gt; b -&gt; [Maybe a]</code>
</li>
<li class="correct">
<code>a -&gt; a -&gt; [Maybe a]</code>
</li>
</ol>
<h2 id="exercises-1"><span class="header-section-number">2.10</span> Exercises</h2>
<ul>
<li><a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set2a.hs">Set2a</a></li>
<li><a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set2b.hs">Set2b</a></li>
</ul>
<p>Remember to give <a href="https://forms.gle/YCo2jAaUTg9vER7G6">feedback</a>!</p>
<h1 id="lecture-3-catamorphic"><span class="header-section-number">3</span> Lecture 3: Catamorphic</h1>
<!-- TODO name of lecture is too obscure, and also folds are only introduced in Lecture 4 -->
<ul>
<li>Lists, lists, lists</li>
<li>Functionality</li>
<li>A bit about types</li>
</ul>
<h2 id="functional-programming-at-last"><span class="header-section-number">3.1</span> Functional programming, at last</h2>
<p>Now with lists and polymorphism in our toolbox, we can finally start to look at functional programming.</p>
<p>In Haskell a function is a value, just like a number or a list is. Functions can be passed as parameters to other functions. Here’s a toy example. The function <code>applyTo1</code> takes a function of type <code>Int-&gt;Int</code>, applies it to the number <code>1</code>, and returns the result.</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb122-1" data-line-number="1"><span class="ot">applyTo1 ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb122-2" data-line-number="2">applyTo1 f <span class="fu">=</span> f <span class="dv">1</span></a></code></pre></div>
<p>Let’s define a simple function of type <code>Int-&gt;Int</code> and see <code>applyTo1</code> in action.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb123-1" data-line-number="1"><span class="ot">addThree ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb123-2" data-line-number="2">addThree x <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">3</span></a></code></pre></div>
<div class="sourceCode" id="cb124"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb124-1" data-line-number="1">applyTo1 addThree</a>
<a class="sourceLine" id="cb124-2" data-line-number="2">  <span class="fu">==&gt;</span> addThree <span class="dv">1</span></a>
<a class="sourceLine" id="cb124-3" data-line-number="3">  <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb124-4" data-line-number="4">  <span class="fu">==&gt;</span> <span class="dv">4</span></a></code></pre></div>
<p>Let’s go back to the type annotation for <code>applyTo1</code>.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb125-1" data-line-number="1"><span class="ot">applyTo1 ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>The parentheses are needed because the type <code>Int -&gt; Int -&gt; Int</code> would be the type of a function taking two <code>Int</code> arguments. More on this later.</p>
<p>Let’s look at a slightly more interesting example. This time we’ll implement a polymorphic function <code>doTwice</code>. Note how we can use it with various types of values and functions.</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb126-1" data-line-number="1"><span class="ot">doTwice ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb126-2" data-line-number="2">doTwice f x <span class="fu">=</span> f (f x)</a></code></pre></div>
<div class="sourceCode" id="cb127"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb127-1" data-line-number="1">doTwice addThree <span class="dv">1</span></a>
<a class="sourceLine" id="cb127-2" data-line-number="2">  <span class="fu">==&gt;</span> addThree (addThree <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb127-3" data-line-number="3">  <span class="fu">==&gt;</span> <span class="dv">7</span></a>
<a class="sourceLine" id="cb127-4" data-line-number="4">doTwice tail <span class="st">&quot;abcd&quot;</span></a>
<a class="sourceLine" id="cb127-5" data-line-number="5">  <span class="fu">==&gt;</span> tail (tail <span class="st">&quot;abcd&quot;</span>)</a>
<a class="sourceLine" id="cb127-6" data-line-number="6">  <span class="fu">==&gt;</span> <span class="st">&quot;cd&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb128"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb128-1" data-line-number="1"><span class="ot">makeCool ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb128-2" data-line-number="2">makeCool str <span class="fu">=</span> <span class="st">&quot;WOW &quot;</span> <span class="fu">++</span> str <span class="fu">++</span> <span class="st">&quot;!&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb129"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb129-1" data-line-number="1">doTwice makeCool <span class="st">&quot;Haskell&quot;</span></a>
<a class="sourceLine" id="cb129-2" data-line-number="2">  <span class="fu">==&gt;</span> <span class="st">&quot;WOW WOW Haskell!!&quot;</span></a></code></pre></div>
<h3 id="functional-programming-on-lists"><span class="header-section-number">3.1.1</span> Functional programming on lists</h3>
<p>That was a bit boring. Luckily there are many useful list functions that take functions as arguments. By the way, functions that take functions as arguments (or return functions) are often called <em>higher-order functions</em>.</p>
<p>The most famous of these list-processing higher-order functions is <code>map</code>. It gives you a new list by applying the given function to all elements of a list.</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb130-1" data-line-number="1">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a></code></pre></div>
<div class="sourceCode" id="cb131"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb131-1" data-line-number="1">map addThree [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb131-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a></code></pre></div>
<p>The partner in crime for <code>map</code> is <code>filter</code>. Instead of transforming all elements of a list, <code>filter</code> drops some elements of a list and keeps others. In other words, <code>filter</code> selects the elements from a list that fulfill a condition.</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb132-1" data-line-number="1">filter<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a></code></pre></div>
<p>Here’s an example: selecting the positive elements from a list</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb133-1" data-line-number="1"><span class="ot">positive ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb133-2" data-line-number="2">positive x <span class="fu">=</span> x<span class="fu">&gt;</span><span class="dv">0</span></a></code></pre></div>
<div class="sourceCode" id="cb134"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb134-1" data-line-number="1">filter positive [<span class="dv">0</span>,<span class="dv">1</span>,<span class="fu">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="fu">-</span><span class="dv">3</span>]</a>
<a class="sourceLine" id="cb134-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="dv">1</span>,<span class="dv">3</span>]</a></code></pre></div>
<p>Note how both the type signatures of <code>map</code> and <code>filter</code> use polymorphism. They work on all kinds of lists. The type of <code>map</code> even uses two type parameters! Here are some examples of type inference using <code>map</code> and <code>filter</code>.</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb135-1" data-line-number="1">onlyPositive xs <span class="fu">=</span> filter positive xs</a>
<a class="sourceLine" id="cb135-2" data-line-number="2">mapBooleans f <span class="fu">=</span> map f [<span class="dt">False</span>,<span class="dt">True</span>]</a></code></pre></div>
<div class="sourceCode" id="cb136"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb136-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t onlyPositive</a>
<a class="sourceLine" id="cb136-2" data-line-number="2"><span class="ot">onlyPositive ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb136-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t mapBooleans</a>
<a class="sourceLine" id="cb136-4" data-line-number="4"><span class="ot">mapBooleans ::</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb136-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t mapBooleans not</a>
<a class="sourceLine" id="cb136-6" data-line-number="6">mapBooleans<span class="ot"> not ::</span> [<span class="dt">Bool</span>]</a></code></pre></div>
<p>One more thing: remember how constructors were just functions? That means you can pass them as arguments to other functions!</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb137-1" data-line-number="1">wrapJust xs <span class="fu">=</span> map <span class="dt">Just</span> xs</a></code></pre></div>
<div class="sourceCode" id="cb138"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb138-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t wrapJust</a>
<a class="sourceLine" id="cb138-2" data-line-number="2"><span class="ot">wrapJust ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Maybe</span> a]</a>
<a class="sourceLine" id="cb138-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> wrapJust [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb138-4" data-line-number="4">[<span class="dt">Just</span> <span class="dv">1</span>,<span class="dt">Just</span> <span class="dv">2</span>,<span class="dt">Just</span> <span class="dv">3</span>]</a></code></pre></div>
<h3 id="examples-of-functional-programming-on-lists"><span class="header-section-number">3.1.2</span> Examples of functional programming on lists</h3>
<p>How many “palindrome numbers” are between <code>1</code> and <code>n</code>?</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb139-1" data-line-number="1"><span class="co">-- a predicate that checks if a string is a palindrome</span></a>
<a class="sourceLine" id="cb139-2" data-line-number="2"><span class="ot">palindrome ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb139-3" data-line-number="3">palindrome str <span class="fu">=</span> str <span class="fu">==</span> reverse str</a>
<a class="sourceLine" id="cb139-4" data-line-number="4"></a>
<a class="sourceLine" id="cb139-5" data-line-number="5"><span class="co">-- palindromes n takes all numbers from 1 to n, converts them to strings using show, and keeps only palindromes</span></a>
<a class="sourceLine" id="cb139-6" data-line-number="6"><span class="ot">palindromes ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb139-7" data-line-number="7">palindromes n <span class="fu">=</span> filter palindrome (map show [<span class="dv">1</span><span class="fu">..</span>n])</a></code></pre></div>
<div class="sourceCode" id="cb140"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb140-1" data-line-number="1">palindrome <span class="st">&quot;1331&quot;</span> <span class="fu">==&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb140-2" data-line-number="2">palindromes <span class="dv">150</span> <span class="fu">==&gt;</span></a>
<a class="sourceLine" id="cb140-3" data-line-number="3">  [<span class="st">&quot;1&quot;</span>,<span class="st">&quot;2&quot;</span>,<span class="st">&quot;3&quot;</span>,<span class="st">&quot;4&quot;</span>,<span class="st">&quot;5&quot;</span>,<span class="st">&quot;6&quot;</span>,<span class="st">&quot;7&quot;</span>,<span class="st">&quot;8&quot;</span>,<span class="st">&quot;9&quot;</span>,</a>
<a class="sourceLine" id="cb140-4" data-line-number="4">   <span class="st">&quot;11&quot;</span>,<span class="st">&quot;22&quot;</span>,<span class="st">&quot;33&quot;</span>,<span class="st">&quot;44&quot;</span>,<span class="st">&quot;55&quot;</span>,<span class="st">&quot;66&quot;</span>,<span class="st">&quot;77&quot;</span>,<span class="st">&quot;88&quot;</span>,<span class="st">&quot;99&quot;</span>,</a>
<a class="sourceLine" id="cb140-5" data-line-number="5">   <span class="st">&quot;101&quot;</span>,<span class="st">&quot;111&quot;</span>,<span class="st">&quot;121&quot;</span>,<span class="st">&quot;131&quot;</span>,<span class="st">&quot;141&quot;</span>]</a>
<a class="sourceLine" id="cb140-6" data-line-number="6">length (palindromes <span class="dv">9999</span>) <span class="fu">==&gt;</span> <span class="dv">198</span></a></code></pre></div>
<p>How many words in a string start with “a”? This uses the function <code>words</code> from the module <code>Data.List</code> that splits a string into words.</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb141-1" data-line-number="1"><span class="ot">countAWords ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb141-2" data-line-number="2">countAWords string <span class="fu">=</span> length (filter startsWithA (words string))</a>
<a class="sourceLine" id="cb141-3" data-line-number="3">  <span class="kw">where</span> startsWithA s <span class="fu">=</span> head s <span class="fu">==</span> <span class="ch">&#39;a&#39;</span></a></code></pre></div>
<div class="sourceCode" id="cb142"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb142-1" data-line-number="1">countAWords <span class="st">&quot;does anyone want an apple?&quot;</span></a>
<a class="sourceLine" id="cb142-2" data-line-number="2">  <span class="fu">==&gt;</span> <span class="dv">3</span></a></code></pre></div>
<p>The function <code>tails</code> from <code>Data.List</code> returns the list of all suffixes (“tails”) of a list. We can use <code>tails</code> for many string processing tasks. Here’s how <code>tails</code> works:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb143-1" data-line-number="1">tails <span class="st">&quot;echo&quot;</span></a>
<a class="sourceLine" id="cb143-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="st">&quot;echo&quot;</span>,<span class="st">&quot;cho&quot;</span>,<span class="st">&quot;ho&quot;</span>,<span class="st">&quot;o&quot;</span>,<span class="st">&quot;&quot;</span>]</a></code></pre></div>
<p>Here’s an example where we find what characters come after a given character in a string. First of all, we use <code>tails</code>, <code>map</code> and <code>take</code> to get all substrings of a certain length:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb144-1" data-line-number="1"><span class="ot">substringsOfLength ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb144-2" data-line-number="2">substringsOfLength n string <span class="fu">=</span> map shorten (tails string)</a>
<a class="sourceLine" id="cb144-3" data-line-number="3">  <span class="kw">where</span> shorten s <span class="fu">=</span> take n s</a></code></pre></div>
<div class="sourceCode" id="cb145"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb145-1" data-line-number="1">substringsOfLength <span class="dv">3</span> <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb145-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="st">&quot;hel&quot;</span>,<span class="st">&quot;ell&quot;</span>,<span class="st">&quot;llo&quot;</span>,<span class="st">&quot;lo&quot;</span>,<span class="st">&quot;o&quot;</span>,<span class="st">&quot;&quot;</span>]</a></code></pre></div>
<p>There’s some shorter substrings left at the end (can you see why?), but they’re fine for our purposes right now. Now that we have <code>substringsOfLength</code>, we can implement the function <code>whatFollows c k s</code> that finds all the occurrences of the character <code>c</code> in the string <code>s</code>, and outputs the <code>k</code> letters that come after these occurrences.</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb146-1" data-line-number="1"><span class="ot">whatFollows ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb146-2" data-line-number="2">whatFollows c k string <span class="fu">=</span> map tail (filter match (substringsOfLength (k<span class="fu">+</span><span class="dv">1</span>) string))</a>
<a class="sourceLine" id="cb146-3" data-line-number="3">  <span class="kw">where</span> match sub <span class="fu">=</span> take <span class="dv">1</span> sub <span class="fu">==</span> [c]</a></code></pre></div>
<div class="sourceCode" id="cb147"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb147-1" data-line-number="1">whatFollows <span class="ch">&#39;a&#39;</span> <span class="dv">2</span> <span class="st">&quot;abracadabra&quot;</span></a>
<a class="sourceLine" id="cb147-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="st">&quot;br&quot;</span>,<span class="st">&quot;ca&quot;</span>,<span class="st">&quot;da&quot;</span>,<span class="st">&quot;br&quot;</span>,<span class="st">&quot;&quot;</span>]</a></code></pre></div>
<h2 id="partial-application"><span class="header-section-number">3.2</span> Partial application</h2>
<p>When using higher-order functions you can find yourself defining lots of small helper functions, like <code>addThree</code> or <code>shorten</code> in the previous examples. This is a bit of a chore in the long run, but luckily Haskell’s functions behave a bit weirdly…</p>
<p>Let’s start in GHCi:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb148-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> add a b <span class="fu">=</span> a<span class="fu">+</span>b</a>
<a class="sourceLine" id="cb148-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> add <span class="dv">1</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb148-3" data-line-number="3"><span class="dv">6</span></a>
<a class="sourceLine" id="cb148-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> addThree <span class="fu">=</span> add <span class="dv">3</span></a>
<a class="sourceLine" id="cb148-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> addThree <span class="dv">2</span></a>
<a class="sourceLine" id="cb148-6" data-line-number="6"><span class="dv">5</span></a></code></pre></div>
<p>So, we’ve defined <code>add</code>, a function of two arguments, and only given it one argument. The result is not a type error but a new function. The new function just stores (or remembers) the given argument, waits for another argument, and then gives both to <code>add</code>.</p>
<pre><code>Prelude&gt; map addThree [1,2,3]
[4,5,6]
Prelude&gt; map (add 3) [1,2,3]
[4,5,6]</code></pre>
<p>Here we can see that we don’t even need to give a name to the function returned by <code>add 3</code>. We can just use it anywhere where a function of one argument is expected.</p>
<p>This is called <em>partial application</em>. All functions in Haskell behave like this. Let’s have a closer look. Here’s a function that takes many arguments.</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb150-1" data-line-number="1"><span class="ot">between ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb150-2" data-line-number="2">between lo high x <span class="fu">=</span> x <span class="fu">&lt;</span> high <span class="fu">&amp;&amp;</span> x <span class="fu">&gt;</span> lo</a></code></pre></div>
<div class="sourceCode" id="cb151"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb151-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> between <span class="dv">3</span> <span class="dv">7</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb151-2" data-line-number="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb151-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> between <span class="dv">3</span> <span class="dv">6</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb151-4" data-line-number="4"><span class="dt">False</span></a></code></pre></div>
<p>We can give <code>between</code> less arguments and get back new functions, just like we saw with <code>add</code>:</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb152-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (between <span class="dv">1</span> <span class="dv">5</span>) <span class="dv">2</span></a>
<a class="sourceLine" id="cb152-2" data-line-number="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb152-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> f <span class="fu">=</span> between <span class="dv">1</span> <span class="dv">5</span> <span class="kw">in</span> f <span class="dv">2</span></a>
<a class="sourceLine" id="cb152-4" data-line-number="4"><span class="dt">True</span></a>
<a class="sourceLine" id="cb152-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> map (between <span class="dv">1</span> <span class="dv">3</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb152-6" data-line-number="6">[<span class="dt">False</span>,<span class="dt">True</span>,<span class="dt">False</span>]</a></code></pre></div>
<p>Look at the types of partially applying <code>between</code>. They behave neatly, with arguments disappearing one by one from the type as values are added to the expression.</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb153-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t between</a>
<a class="sourceLine" id="cb153-2" data-line-number="2"><span class="ot">between ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb153-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t between <span class="dv">1</span></a>
<a class="sourceLine" id="cb153-4" data-line-number="4">between <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb153-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t between <span class="dv">1</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb153-6" data-line-number="6">between <span class="dv">1</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb153-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t between <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb153-8" data-line-number="8">between <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Bool</span></a></code></pre></div>
<p>Actually, when we write a type like <code>Integer -&gt; Integer -&gt; Integer -&gt; Bool</code>, it means <code>Integer -&gt; (Integer -&gt; (Integer -&gt; Bool))</code>. That is, a multi-argument function is just a function that returns a function. Similarly, an expression like <code>between 1 2 3</code> is the same as <code>((between 1) 2) 3</code>, so passing multiple arguments to a function happens via multiple single-argument calls. Representing multi-argument functions like this is called <em>currying</em> (after the logician Haskell Curry). Currying is what makes partial application possible.</p>
<p>Here’s another example of using partial application with <code>map</code>:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb154-1" data-line-number="1">map (drop <span class="dv">1</span>) [<span class="st">&quot;Hello&quot;</span>,<span class="st">&quot;World!&quot;</span>]</a>
<a class="sourceLine" id="cb154-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="st">&quot;ello&quot;</span>,<span class="st">&quot;orld!&quot;</span>]</a></code></pre></div>
<p>In addition to normal functions, partial application also works with operators. With operators you can choose whether you apply the left or the right argument. (Partially applied operators are also called <em>sections</em> or <em>operator sections</em>). Some examples:</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb155-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> map (<span class="fu">*</span><span class="dv">2</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb155-2" data-line-number="2">[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb155-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> map (<span class="dv">2</span><span class="fu">*</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb155-4" data-line-number="4">[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb155-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> map (<span class="dv">1</span><span class="fu">/</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb155-6" data-line-number="6">[<span class="fl">1.0</span>,<span class="fl">0.5</span>,<span class="fl">0.3333333333333333</span>,<span class="fl">0.25</span>,<span class="fl">0.2</span>]</a></code></pre></div>
<h2 id="prefix-and-infix-notations"><span class="header-section-number">3.3</span> Prefix and Infix Notations</h2>
<p>Normal Haskell operators are applied with <em>prefix notation</em>, which is just a fancy way to say that the function name comes before the arguments. In contrast, operators are applied with <em>infix notation</em> – the name of the function comes between the arguments.</p>
<p>An infix operator can be converted into a prefix function by adding parentheses around it. For instance,</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb156-1" data-line-number="1">(<span class="fu">+</span>) <span class="dv">1</span> <span class="dv">2</span> <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">==&gt;</span> <span class="dv">3</span></a></code></pre></div>
<p>This is useful especially when an operator needs to be passed as an argument to another function.</p>
<p>As an example, the function <code>zipWith</code> takes two lists, a binary function, and joins the lists using the function. We can use <code>zipWith (+)</code> to sum two lists, element-by-element:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb157-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t zipWith</a>
<a class="sourceLine" id="cb157-2" data-line-number="2">zipWith<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]</a>
<a class="sourceLine" id="cb157-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> zipWith (<span class="fu">+</span>) [<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">5</span>] [<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb157-4" data-line-number="4">[<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">8</span>]</a></code></pre></div>
<p>Without the ability to turn an operator into a function, we’d have to use a helper function – such as <code>add</code> above.</p>
<p>Note that omitting the parentheses leads into a type error:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb158-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> zipWith <span class="fu">+</span> [<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">3</span>] [<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb158-2" data-line-number="2"></a>
<a class="sourceLine" id="cb158-3" data-line-number="3"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">11</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb158-4" data-line-number="4">    • <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> ‘[<span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb158-5" data-line-number="5">                                    <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]’</a>
<a class="sourceLine" id="cb158-6" data-line-number="6">                  with actual <span class="kw">type</span> ‘[<span class="dt">Integer</span>]’</a>
<a class="sourceLine" id="cb158-7" data-line-number="7">    • <span class="dt">The</span> function ‘[<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>]’ is applied to one argument,</a>
<a class="sourceLine" id="cb158-8" data-line-number="8">      but its <span class="kw">type</span> ‘[<span class="dt">Integer</span>]’ has none</a>
<a class="sourceLine" id="cb158-9" data-line-number="9">      <span class="dt">In</span> the second argument <span class="kw">of</span> ‘(<span class="fu">+</span>)’, namely ‘[<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>] [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>]’</a>
<a class="sourceLine" id="cb158-10" data-line-number="10">      <span class="dt">In</span> the expression<span class="fu">:</span> zipWith <span class="fu">+</span> [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>] [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>]</a>
<a class="sourceLine" id="cb158-11" data-line-number="11">    • <span class="dt">Relevant</span> bindings include</a>
<a class="sourceLine" id="cb158-12" data-line-number="12"><span class="ot">        it ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]</a>
<a class="sourceLine" id="cb158-13" data-line-number="13">          (bound at <span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span>)</a></code></pre></div>
<p>The reason for this weird-looking error is that GHCi got confused and thought that we were somehow trying to add <code>zipWith</code> and <code>[0,2,5,3] [1,3,3]</code> together. Logically, it deduced that <code>[0,2,5,3]</code> must be a function since it’s being applied to <code>[1,3,3]</code> (remember that functions bind tighter than operators).</p>
<p>Unfortunately, error messages can sometimes be obscure, since the compiler cannot always know the “real” cause of the error (which is in this case was omitting the parentheses). Weird error messages are frustrating, but only the programmer knows what was the original intent behind the code.</p>
<p>Another nice feature of Haskell is the syntax for applying a binary function as if it was an infix operator, by surrounding it with backticks (`). For example:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb159-1" data-line-number="1"><span class="dv">6</span> <span class="ot">`div`</span> <span class="dv">2</span> <span class="fu">==&gt;</span> div <span class="dv">6</span> <span class="dv">2</span> <span class="fu">==&gt;</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb159-2" data-line-number="2">(<span class="fu">+</span><span class="dv">1</span>) <span class="ot">`map`</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">==&gt;</span> map (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">==&gt;</span> [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a></code></pre></div>
<h2 id="lambdas"><span class="header-section-number">3.4</span> Lambdas</h2>
<p>The last spanner we need in our functional programming toolbox is λ (lambda). Lambda expressions are <em>anonymous functions</em>. Consider a situation where you need a function only once, for example in an expression like</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb160-1" data-line-number="1"><span class="kw">let</span> big x <span class="fu">=</span> x<span class="fu">&gt;</span><span class="dv">7</span> <span class="kw">in</span> filter big [<span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">100</span>]</a></code></pre></div>
<p>A lambda expression allows us to write this directly, without defining a name (<code>big</code>) for the helper function:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb161-1" data-line-number="1">filter (\x <span class="ot">-&gt;</span> x<span class="fu">&gt;</span><span class="dv">7</span>) [<span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">100</span>]</a></code></pre></div>
<p>Here are some more examples in GHCi:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb162-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (\x <span class="ot">-&gt;</span> x<span class="fu">*</span>x) <span class="dv">3</span></a>
<a class="sourceLine" id="cb162-2" data-line-number="2"><span class="dv">9</span></a>
<a class="sourceLine" id="cb162-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> (\x <span class="ot">-&gt;</span> reverse x <span class="fu">==</span> x) <span class="st">&quot;ABBA&quot;</span></a>
<a class="sourceLine" id="cb162-4" data-line-number="4"><span class="dt">True</span></a>
<a class="sourceLine" id="cb162-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> filter (\x <span class="ot">-&gt;</span> reverse x <span class="fu">==</span> x) [<span class="st">&quot;ABBA&quot;</span>,<span class="st">&quot;ACDC&quot;</span>,<span class="st">&quot;otto&quot;</span>,<span class="st">&quot;lothar&quot;</span>,<span class="st">&quot;anna&quot;</span>]</a>
<a class="sourceLine" id="cb162-6" data-line-number="6">[<span class="st">&quot;ABBA&quot;</span>,<span class="st">&quot;otto&quot;</span>,<span class="st">&quot;anna&quot;</span>]</a>
<a class="sourceLine" id="cb162-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> (\x y <span class="ot">-&gt;</span> x<span class="fu">^</span><span class="dv">2</span><span class="fu">+</span>y<span class="fu">^</span><span class="dv">2</span>) <span class="dv">2</span> <span class="dv">3</span>           <span class="co">-- multiple arguments</span></a>
<a class="sourceLine" id="cb162-8" data-line-number="8"><span class="dv">13</span></a></code></pre></div>
<p>The Haskell syntax for lambdas is a bit surprising. The backslash character (<code>\</code>) stands for the greek letter lambda (λ). The Haskell expression <code>\x -&gt; x+1</code> is trying to mimic the mathematical notation <em>λx. x+1</em>. Other languages use syntax like <code>x =&gt; x+1</code> (JavaScript) or <code>lambda x: x+1</code> (Python).</p>
<p><strong>Note!</strong> you never <em>need</em> to use a lambda expression. You can always instead define the function normally using <code>let</code> or <code>where</code>.</p>
<p>By the way, lambda expressions are quite powerful constructs which have a deep theory of their own, known as <a href="https://en.wikipedia.org/wiki/Lambda_calculus">Lambda calculus</a>. Some even consider purely functional programming languages such as Haskell to be typed extensions of Lambda calculus with extra syntax.</p>
<h2 id="sidenote-the-.-and-operators"><span class="header-section-number">3.5</span> Sidenote: the <code>.</code> and <code>$</code> operators</h2>
<p>The two most common operators in Haskell codebases are probably <code>.</code> and <code>$</code>. They are useful when writing code that uses higher-order functions. The first of these, the <code>.</code> operator, is the <em>function composition</em> operator. Here’s its type</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb163-1" data-line-number="1"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</a></code></pre></div>
<p>And here’s what it does</p>
<pre><code>(f.g) x ==&gt; f (g x)</code></pre>
<p>You can use function composition to build functions out of other functions, without mentioning any arguments. For example:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb165-1" data-line-number="1">double x <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>x</a>
<a class="sourceLine" id="cb165-2" data-line-number="2">quadruple <span class="fu">=</span> double <span class="fu">.</span> double  <span class="co">-- computes 2*(2*x) == 4*x</span></a>
<a class="sourceLine" id="cb165-3" data-line-number="3">f <span class="fu">=</span> quadruple <span class="fu">.</span> (<span class="fu">+</span><span class="dv">1</span>)         <span class="co">-- computes 4*(x+1)</span></a>
<a class="sourceLine" id="cb165-4" data-line-number="4">g <span class="fu">=</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">.</span> quadruple         <span class="co">-- computes 4*x+1</span></a>
<a class="sourceLine" id="cb165-5" data-line-number="5">third <span class="fu">=</span> head <span class="fu">.</span> tail <span class="fu">.</span> tail   <span class="co">-- fetches the third element of a list</span></a></code></pre></div>
<p>We can also reimplement <code>doTwice</code> using <code>(.)</code>. Note how we can use <code>doTwice</code> both as applied only to a function, or as applies to a function and a value.</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb166-1" data-line-number="1"><span class="ot">doTwice ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb166-2" data-line-number="2">doTwice f <span class="fu">=</span> f <span class="fu">.</span> f</a></code></pre></div>
<div class="sourceCode" id="cb167"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb167-1" data-line-number="1"><span class="kw">let</span> ttail <span class="fu">=</span> doTwice tail</a>
<a class="sourceLine" id="cb167-2" data-line-number="2"><span class="kw">in</span> ttail [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb167-3" data-line-number="3">  <span class="fu">==&gt;</span> [<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb167-4" data-line-number="4"></a>
<a class="sourceLine" id="cb167-5" data-line-number="5">(doTwice tail) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] <span class="fu">==&gt;</span> [<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb167-6" data-line-number="6"></a>
<a class="sourceLine" id="cb167-7" data-line-number="7">doTwice tail [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] <span class="fu">==&gt;</span> [<span class="dv">3</span>,<span class="dv">4</span>]</a></code></pre></div>
<p>Often function composition is not used when defining a new function, but instead to avoid defining a helper function. For instance, consider the difference between these two expressions:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb168-1" data-line-number="1"><span class="kw">let</span> notEmpty x <span class="fu">=</span> not (null x)</a>
<a class="sourceLine" id="cb168-2" data-line-number="2"><span class="kw">in</span> filter notEmpty [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[],[<span class="dv">4</span>]]</a>
<a class="sourceLine" id="cb168-3" data-line-number="3">  <span class="fu">==&gt;</span> [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>]]</a></code></pre></div>
<div class="sourceCode" id="cb169"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb169-1" data-line-number="1">filter (not <span class="fu">.</span> null) [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[],[<span class="dv">4</span>]]</a>
<a class="sourceLine" id="cb169-2" data-line-number="2">  <span class="fu">==&gt;</span> [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>]]</a></code></pre></div>
<p>The other operator, <code>$</code> is more subtle. Let’s look at its type.</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb170-1" data-line-number="1"><span class="ot">($) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>It takes a function of type <code>a -&gt; b</code> and a value of type <code>a</code>, and returns a value of type <code>b</code>. In other words, it’s a function application operator. The expression <code>f $ x</code> is the same as <code>f x</code>. This seems pretty useless, but it means that the <code>$</code> operator can be used to eliminate parentheses! These expressions are the same:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb171-1" data-line-number="1">head (reverse <span class="st">&quot;abcd&quot;</span>)</a>
<a class="sourceLine" id="cb171-2" data-line-number="2">head <span class="fu">$</span> reverse <span class="st">&quot;abcd&quot;</span></a></code></pre></div>
<p>This isn’t that impressive when it’s used to eliminate one pair of parentheses, but together <code>.</code> and <code>$</code> can eliminate lots of them! For example, we can rewrite</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb172-1" data-line-number="1">reverse (map head (map reverse ([<span class="st">&quot;Haskell&quot;</span>,<span class="st">&quot;pro&quot;</span>] <span class="fu">++</span> [<span class="st">&quot;dodo&quot;</span>,<span class="st">&quot;lyric&quot;</span>])))</a></code></pre></div>
<p>as</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb173-1" data-line-number="1">(reverse <span class="fu">.</span> map head <span class="fu">.</span> map reverse) ([<span class="st">&quot;Haskell&quot;</span>,<span class="st">&quot;pro&quot;</span>] <span class="fu">++</span> [<span class="st">&quot;dodo&quot;</span>,<span class="st">&quot;lyric&quot;</span>])</a></code></pre></div>
<p>and then</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb174-1" data-line-number="1">reverse <span class="fu">.</span> map head <span class="fu">.</span> map reverse <span class="fu">$</span> [<span class="st">&quot;Haskell&quot;</span>,<span class="st">&quot;pro&quot;</span>] <span class="fu">++</span> [<span class="st">&quot;dodo&quot;</span>,<span class="st">&quot;lyric&quot;</span>]</a></code></pre></div>
<p>Sometimes the operators <code>.</code> and <code>$</code> are useful as functions in their own right. For example, a list of functions can be applied to an argument using map and a section of <code>$</code>:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb175-1" data-line-number="1">map (<span class="fu">$</span><span class="st">&quot;string&quot;</span>) [reverse, take <span class="dv">2</span>, drop <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb175-2" data-line-number="2">  <span class="fu">==&gt;</span> [reverse <span class="fu">$</span> <span class="st">&quot;string&quot;</span>, take <span class="dv">2</span> <span class="fu">$</span> <span class="st">&quot;string&quot;</span>, drop <span class="dv">2</span> <span class="fu">$</span> <span class="st">&quot;string&quot;</span>]</a>
<a class="sourceLine" id="cb175-3" data-line-number="3">  <span class="fu">==&gt;</span> [reverse <span class="st">&quot;string&quot;</span>, take <span class="dv">2</span> <span class="st">&quot;string&quot;</span>, drop <span class="dv">2</span> <span class="st">&quot;string&quot;</span>]</a>
<a class="sourceLine" id="cb175-4" data-line-number="4">  <span class="fu">==&gt;</span> [<span class="st">&quot;gnirts&quot;</span>, <span class="st">&quot;st&quot;</span>, <span class="st">&quot;ring&quot;</span>]</a></code></pre></div>
<!-- `zipWith (.)` would be an example on using `.` as a function. -->
<p>If this seems complicated, don’t worry. You don’t need to use <code>.</code> and <code>$</code> in your own code until you’re comfortable with them. However, you’ll bump into <code>.</code> and <code>$</code> when reading Haskell examples and code on the internet, so it’s good to know about them. <a href="https://typeclasses.com/featured/dollar">This article</a> might also help.</p>
<h2 id="example-rewriting-whatfollows"><span class="header-section-number">3.6</span> Example: rewriting <code>whatFollows</code></h2>
<p>Now, let’s rewrite the <code>whatFollows</code> example from earlier using the tools we just saw. Here’s the original version:</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb176-1" data-line-number="1"><span class="ot">substringsOfLength ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb176-2" data-line-number="2">substringsOfLength n string <span class="fu">=</span> map shorten (tails string)</a>
<a class="sourceLine" id="cb176-3" data-line-number="3">  <span class="kw">where</span> shorten s <span class="fu">=</span> take n s</a>
<a class="sourceLine" id="cb176-4" data-line-number="4"></a>
<a class="sourceLine" id="cb176-5" data-line-number="5"><span class="ot">whatFollows ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb176-6" data-line-number="6">whatFollows c k string <span class="fu">=</span> map tail (filter match (substringsOfLength (k<span class="fu">+</span><span class="dv">1</span>) string))</a>
<a class="sourceLine" id="cb176-7" data-line-number="7">  <span class="kw">where</span> match sub <span class="fu">=</span> take <span class="dv">1</span> sub <span class="fu">==</span> [c]</a></code></pre></div>
<p>To get started, let’s get rid of the helper function <code>substringsOfLength</code> and move all the code to <code>whatFollows</code>:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb177-1" data-line-number="1">whatFollows c k string <span class="fu">=</span> map tail (filter match (map shorten (tails string)))</a>
<a class="sourceLine" id="cb177-2" data-line-number="2">  <span class="kw">where</span> shorten s <span class="fu">=</span> take (k<span class="fu">+</span><span class="dv">1</span>) s</a>
<a class="sourceLine" id="cb177-3" data-line-number="3">        match sub <span class="fu">=</span> take <span class="dv">1</span> sub <span class="fu">==</span> [c]</a></code></pre></div>
<p>Now let’s use partial application instead of defining <code>shorten</code>:</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb178-1" data-line-number="1">whatFollows c k string <span class="fu">=</span> map tail (filter match (map (take (k<span class="fu">+</span><span class="dv">1</span>)) (tails string)))</a>
<a class="sourceLine" id="cb178-2" data-line-number="2">  <span class="kw">where</span> match sub <span class="fu">=</span> take <span class="dv">1</span> sub <span class="fu">==</span> [c]</a></code></pre></div>
<p>Let’s use <code>.</code> and <code>$</code> to eliminate some of those parentheses:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb179-1" data-line-number="1">whatFollows c k string <span class="fu">=</span> map tail <span class="fu">.</span> filter match <span class="fu">.</span> map (take (k<span class="fu">+</span><span class="dv">1</span>)) <span class="fu">$</span> tails string</a>
<a class="sourceLine" id="cb179-2" data-line-number="2">  <span class="kw">where</span> match sub <span class="fu">=</span> take <span class="dv">1</span> sub <span class="fu">==</span> [c]</a></code></pre></div>
<p>We can also replace <code>match</code> with a lambda:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb180-1" data-line-number="1">whatFollows c k string <span class="fu">=</span> map tail <span class="fu">.</span> filter (\sub <span class="ot">-&gt;</span> take <span class="dv">1</span> sub <span class="fu">==</span> [c]) <span class="fu">.</span> map (take (k<span class="fu">+</span><span class="dv">1</span>)) <span class="fu">$</span> tails string</a></code></pre></div>
<p>Finally, we don’t need to mention the <code>string</code> parameter at all, since we can just express <code>whatFollows</code> as a composition of <code>map</code>, <code>filter</code>, <code>map</code> and <code>tails</code>:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb181-1" data-line-number="1">whatFollows c k <span class="fu">=</span> map tail <span class="fu">.</span> filter (\sub <span class="ot">-&gt;</span> take <span class="dv">1</span> sub <span class="fu">==</span> [c]) <span class="fu">.</span> map (take (k<span class="fu">+</span><span class="dv">1</span>)) <span class="fu">.</span> tails</a></code></pre></div>
<p>We can even go a bit further by rewriting the lambda using an operator section</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb182-1" data-line-number="1">    \sub <span class="ot">-&gt;</span> take <span class="dv">1</span> sub <span class="fu">==</span> [c]</a>
<a class="sourceLine" id="cb182-2" data-line-number="2"><span class="fu">===</span> \sub <span class="ot">-&gt;</span> (<span class="fu">==</span>[c]) (take <span class="dv">1</span> sub)</a>
<a class="sourceLine" id="cb182-3" data-line-number="3"><span class="fu">===</span> \sub <span class="ot">-&gt;</span> (<span class="fu">==</span>[c]) ((take <span class="dv">1</span>) sub)</a>
<a class="sourceLine" id="cb182-4" data-line-number="4"><span class="fu">===</span> \sub <span class="ot">-&gt;</span> ((<span class="fu">==</span>[c]) <span class="fu">.</span> (take <span class="dv">1</span>)) sub</a>
<a class="sourceLine" id="cb182-5" data-line-number="5"><span class="fu">===</span> ((<span class="fu">==</span>[c]) <span class="fu">.</span> (take <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb182-6" data-line-number="6"><span class="fu">===</span> ((<span class="fu">==</span>[c]) <span class="fu">.</span> take <span class="dv">1</span>)</a></code></pre></div>
<p>Now what we have left is:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb183-1" data-line-number="1">whatFollows c k <span class="fu">=</span> map tail <span class="fu">.</span> filter ((<span class="fu">==</span>[c]) <span class="fu">.</span> take <span class="dv">1</span>) <span class="fu">.</span> map (take (k<span class="fu">+</span><span class="dv">1</span>)) <span class="fu">.</span> tails</a></code></pre></div>
<p>This is a somewhat extreme version of the function, but when used in moderation the techniques shown here can make code easier to read.</p>
<h2 id="more-functional-list-wrangling-examples"><span class="header-section-number">3.7</span> More functional list wrangling examples</h2>
<p>Here are some more examples of functional programming with lists. Let’s start by introducing a couple of new list functions:</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb184-1" data-line-number="1">takeWhile<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]   <span class="co">-- take elements from a list as long as they satisfy a predicate</span></a>
<a class="sourceLine" id="cb184-2" data-line-number="2">dropWhile<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]   <span class="co">-- drop elements from a list as long as they satisfy a predicate</span></a></code></pre></div>
<div class="sourceCode" id="cb185"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb185-1" data-line-number="1">takeWhile even [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]   <span class="fu">==&gt;</span> [<span class="dv">2</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb185-2" data-line-number="2">dropWhile even [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]   <span class="fu">==&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a></code></pre></div>
<p>There’s also the function <code>elem</code>, which can be used to check if a list contains an element:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb186-1" data-line-number="1">elem <span class="dv">3</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]   <span class="fu">==&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb186-2" data-line-number="2">elem <span class="dv">4</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]   <span class="fu">==&gt;</span> <span class="dt">False</span></a></code></pre></div>
<p>Using these, we can implement a function <code>findSubString</code> that finds the first substring in a string that consist only of the given characters.</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb187-1" data-line-number="1"><span class="ot">findSubString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb187-2" data-line-number="2">findSubString chars <span class="fu">=</span> takeWhile (\x <span class="ot">-&gt;</span> elem x chars)</a>
<a class="sourceLine" id="cb187-3" data-line-number="3">                      <span class="fu">.</span> dropWhile (\x <span class="ot">-&gt;</span> not <span class="fu">$</span> elem x chars)</a></code></pre></div>
<div class="sourceCode" id="cb188"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb188-1" data-line-number="1">findSubString <span class="st">&quot;abcd&quot;</span> <span class="st">&quot;xxxyyyzabaaxxabcd&quot;</span>    <span class="fu">==&gt;</span> <span class="st">&quot;abaa&quot;</span></a></code></pre></div>
<!-- `zipWith` has already been introduced in section 3.3 above. -->
<p>The function <code>zipWith</code> lets you combine two lists element-by-element:</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb189-1" data-line-number="1">zipWith<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]</a></code></pre></div>
<div class="sourceCode" id="cb190"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb190-1" data-line-number="1">zipWith (<span class="fu">++</span>) [<span class="st">&quot;John&quot;</span>,<span class="st">&quot;Mary&quot;</span>] [<span class="st">&quot;Smith&quot;</span>,<span class="st">&quot;Cooper&quot;</span>]</a>
<a class="sourceLine" id="cb190-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="st">&quot;JohnSmith&quot;</span>,<span class="st">&quot;MaryCooper&quot;</span>]</a>
<a class="sourceLine" id="cb190-3" data-line-number="3">zipWith take [<span class="dv">4</span>,<span class="dv">3</span>] [<span class="st">&quot;Hello&quot;</span>,<span class="st">&quot;Warden&quot;</span>]</a>
<a class="sourceLine" id="cb190-4" data-line-number="4">  <span class="fu">==&gt;</span> [<span class="st">&quot;Hell&quot;</span>,<span class="st">&quot;War&quot;</span>]</a></code></pre></div>
<h2 id="lists-and-recursion"><span class="header-section-number">3.8</span> Lists and recursion</h2>
<p>Here’s a new operator, <code>:</code></p>
<div class="sourceCode" id="cb191"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb191-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span><span class="fu">:</span>[]</a>
<a class="sourceLine" id="cb191-2" data-line-number="2">[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb191-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span><span class="fu">:</span>[<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb191-4" data-line-number="4">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb191-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> tail (<span class="dv">1</span><span class="fu">:</span>[<span class="dv">2</span>,<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb191-6" data-line-number="6">[<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb191-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> head (<span class="dv">1</span><span class="fu">:</span>[<span class="dv">2</span>,<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb191-8" data-line-number="8"><span class="dv">1</span></a>
<a class="sourceLine" id="cb191-9" data-line-number="9"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t (<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb191-10" data-line-number="10"><span class="ot">(:) ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a></code></pre></div>
<p>The <code>:</code> operator builds a list out of a head and a tail. In other words, <code>x : xs</code> is the same as <code>[x] ++ xs</code>. Why do we need an operator for this?</p>
<p>Actually, <code>:</code> is the <em>constructor</em> for lists: it returns a new linked list node. The other list constructor is <code>[]</code>, the empty list. All lists are built using <code>:</code> and <code>[]</code>. The familiar <code>[x,y,z]</code> syntax is actually just a nicer way to write <code>x:y:z:[]</code>, or even more explicitly, <code>x:(y:(z:[]))</code>. In fact <code>(++)</code> is defined in terms of <code>:</code> and recursion in the standard library.</p>
<p>Here’s a picture of how <code>[1,2,3]</code> is structured in memory:</p>
<pre><code>   (:)
  /   \
 1    (:)
     /   \
    2    (:)
        /   \
       3    []</code></pre>
<h3 id="building-a-list"><span class="header-section-number">3.8.1</span> Building a list</h3>
<p>Using <code>:</code> we can define recursive functions that build lists. For example here’s a function that builds lists like <code>[3,2,1]</code>:</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb193-1" data-line-number="1">descend <span class="dv">0</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb193-2" data-line-number="2">descend n <span class="fu">=</span> n <span class="fu">:</span> descend (n<span class="fu">-</span><span class="dv">1</span>)</a></code></pre></div>
<div class="sourceCode" id="cb194"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb194-1" data-line-number="1">descend <span class="dv">4</span> <span class="fu">==&gt;</span> [<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a></code></pre></div>
<p>Here’s a function that builds a list by iterating a function <code>n</code> times:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb195-1" data-line-number="1">iterate f <span class="dv">0</span> x <span class="fu">=</span> [x]</a>
<a class="sourceLine" id="cb195-2" data-line-number="2">iterate f n x <span class="fu">=</span> x <span class="fu">:</span> iterate f (n<span class="fu">-</span><span class="dv">1</span>) (f x)</a></code></pre></div>
<div class="sourceCode" id="cb196"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb196-1" data-line-number="1">iterate (<span class="fu">*</span><span class="dv">2</span>) <span class="dv">4</span> <span class="dv">3</span> <span class="fu">==&gt;</span> [<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">12</span>,<span class="dv">24</span>,<span class="dv">48</span>]</a>
<a class="sourceLine" id="cb196-2" data-line-number="2"></a>
<a class="sourceLine" id="cb196-3" data-line-number="3"><span class="kw">let</span> xs <span class="fu">=</span> <span class="st">&quot;terve&quot;</span></a>
<a class="sourceLine" id="cb196-4" data-line-number="4"><span class="kw">in</span> iterate tail (length xs) xs</a>
<a class="sourceLine" id="cb196-5" data-line-number="5">  <span class="fu">==&gt;</span> [<span class="st">&quot;terve&quot;</span>,<span class="st">&quot;erve&quot;</span>,<span class="st">&quot;rve&quot;</span>,<span class="st">&quot;ve&quot;</span>,<span class="st">&quot;e&quot;</span>,<span class="st">&quot;&quot;</span>]</a></code></pre></div>
<p>Here’s a more complicated example: splitting a string into pieces at a given character:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb197-1" data-line-number="1"><span class="ot">split ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb197-2" data-line-number="2">split c [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb197-3" data-line-number="3">split c xs <span class="fu">=</span> start <span class="fu">:</span> split c (drop <span class="dv">1</span> rest)</a>
<a class="sourceLine" id="cb197-4" data-line-number="4">  <span class="kw">where</span> start <span class="fu">=</span> takeWhile (<span class="fu">/=</span>c) xs</a>
<a class="sourceLine" id="cb197-5" data-line-number="5">        rest <span class="fu">=</span> dropWhile (<span class="fu">/=</span>c) xs</a></code></pre></div>
<div class="sourceCode" id="cb198"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb198-1" data-line-number="1">split <span class="ch">&#39;x&#39;</span> <span class="st">&quot;fooxxbarxquux&quot;</span>   <span class="fu">==&gt;</span>   [<span class="st">&quot;foo&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;bar&quot;</span>,<span class="st">&quot;quu&quot;</span>]</a></code></pre></div>
<h3 id="pattern-matching-for-lists"><span class="header-section-number">3.8.2</span> Pattern matching for lists</h3>
<p>Last lecture, it was said that constructors are things that can be pattern matched on. Above, it was divulged that the constructors for the list type are <code>:</code> and <code>[]</code>. We can put one and one together and guess that we can pattern match on <code>:</code> and <code>[]</code>. This is true! Here’s how you can define your own versions of <code>head</code> and <code>tail</code> using pattern matching:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb199-1" data-line-number="1"><span class="ot">myhead ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb199-2" data-line-number="2">myhead [] <span class="fu">=</span> <span class="fu">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb199-3" data-line-number="3">myhead (first<span class="fu">:</span>rest) <span class="fu">=</span> first</a>
<a class="sourceLine" id="cb199-4" data-line-number="4"></a>
<a class="sourceLine" id="cb199-5" data-line-number="5"><span class="ot">mytail ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb199-6" data-line-number="6">mytail [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb199-7" data-line-number="7">mytail (first<span class="fu">:</span>rest) <span class="fu">=</span> rest</a></code></pre></div>
<p>You can <em>nest</em> patterns. That is, you can pattern match more than one element from the start of a list. In this example, we use the pattern <code>(a:b:_)</code> which is the same as <code>(a:(b:_))</code>:</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb200-1" data-line-number="1"><span class="ot">sumFirstTwo ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb200-2" data-line-number="2"><span class="co">-- this equation gets used for lists of length at least two</span></a>
<a class="sourceLine" id="cb200-3" data-line-number="3">sumFirstTwo (a<span class="fu">:</span>b<span class="fu">:</span>_) <span class="fu">=</span> a<span class="fu">+</span>b</a>
<a class="sourceLine" id="cb200-4" data-line-number="4"><span class="co">-- this equation gets used for lists of length 0 or 1</span></a>
<a class="sourceLine" id="cb200-5" data-line-number="5">sumFirstTwo _       <span class="fu">=</span> <span class="dv">0</span></a></code></pre></div>
<div class="sourceCode" id="cb201"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb201-1" data-line-number="1">sumFirstTwo [<span class="dv">1</span>]      <span class="fu">==&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb201-2" data-line-number="2">sumFirstTwo [<span class="dv">1</span>,<span class="dv">2</span>]    <span class="fu">==&gt;</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb201-3" data-line-number="3">sumFirstTwo [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>]  <span class="fu">==&gt;</span> <span class="dv">3</span></a></code></pre></div>
<p>Another way we can nest patterns is pattern matching on the head while pattern matching on a list. For example this function checks if a list starts with <code>0</code>:</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb202-1" data-line-number="1"><span class="ot">startsWithZero ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb202-2" data-line-number="2">startsWithZero (<span class="dv">0</span><span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb202-3" data-line-number="3">startsWithZero (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb202-4" data-line-number="4">startsWithZero []     <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<!-- The last two cases could be merged as `startsWithZero _ = False`. -->
<h3 id="consuming-a-list"><span class="header-section-number">3.8.3</span> Consuming a list</h3>
<p>Using pattern matching and recursion, we can recursively process a whole list. Here’s how you sum all the numbers in a list:</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb203-1" data-line-number="1"><span class="ot">sumNumbers ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb203-2" data-line-number="2">sumNumbers [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb203-3" data-line-number="3">sumNumbers (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> sumNumbers xs</a></code></pre></div>
<p>Here’s how you compute the largest number in a list, this time using a helper function.</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb204-1" data-line-number="1"><span class="ot">myMaximum ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb204-2" data-line-number="2">myMaximum [] <span class="fu">=</span> <span class="dv">0</span>       <span class="co">-- actually this should be some sort of error...</span></a>
<a class="sourceLine" id="cb204-3" data-line-number="3">myMaximum (x<span class="fu">:</span>xs) <span class="fu">=</span> go x xs</a>
<a class="sourceLine" id="cb204-4" data-line-number="4">  <span class="kw">where</span> go biggest [] <span class="fu">=</span> biggest</a>
<a class="sourceLine" id="cb204-5" data-line-number="5">        go biggest (x<span class="fu">:</span>xs) <span class="fu">=</span> go (max biggest x) xs</a></code></pre></div>
<p>It’s often convenient to use nested patterns while consuming a list. Here’s an example that counts how many <code>Nothing</code> values occur in a list of <code>Maybe</code>s:</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb205-1" data-line-number="1"><span class="ot">countNothings ::</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb205-2" data-line-number="2">countNothings [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb205-3" data-line-number="3">countNothings (<span class="dt">Nothing</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> countNothings xs</a>
<a class="sourceLine" id="cb205-4" data-line-number="4">countNothings (<span class="dt">Just</span> _  <span class="fu">:</span> xs) <span class="fu">=</span> countNothings xs</a></code></pre></div>
<div class="sourceCode" id="cb206"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb206-1" data-line-number="1">countNothings [<span class="dt">Nothing</span>,<span class="dt">Just</span> <span class="dv">1</span>,<span class="dt">Nothing</span>]  <span class="fu">==&gt;</span>  <span class="dv">2</span></a></code></pre></div>
<h3 id="building-and-consuming-a-list"><span class="header-section-number">3.8.4</span> Building and consuming a list</h3>
<p>Now that we can build and consume lists, let’s do both of them at the same time. This function doubles all elements in a list.</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb207-1" data-line-number="1"><span class="ot">doubleList ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb207-2" data-line-number="2">doubleList [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb207-3" data-line-number="3">doubleList (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>x <span class="fu">:</span> doubleList xs</a></code></pre></div>
<p>It evaluates like this:</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb208-1" data-line-number="1">doubleList [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb208-2" data-line-number="2"><span class="fu">===</span> doubleList (<span class="dv">1</span><span class="fu">:</span>(<span class="dv">2</span><span class="fu">:</span>(<span class="dv">3</span><span class="fu">:</span>[])))</a>
<a class="sourceLine" id="cb208-3" data-line-number="3"><span class="fu">==&gt;</span> <span class="dv">2</span><span class="fu">*</span><span class="dv">1</span> <span class="fu">:</span> doubleList (<span class="dv">2</span><span class="fu">:</span>(<span class="dv">3</span><span class="fu">:</span>[]))</a>
<a class="sourceLine" id="cb208-4" data-line-number="4"><span class="fu">==&gt;</span> <span class="dv">2</span><span class="fu">*</span><span class="dv">1</span> <span class="fu">:</span> (<span class="dv">2</span><span class="fu">*</span><span class="dv">2</span> <span class="fu">:</span> doubleList (<span class="dv">3</span><span class="fu">:</span>[]))</a>
<a class="sourceLine" id="cb208-5" data-line-number="5"><span class="fu">==&gt;</span> <span class="dv">2</span><span class="fu">*</span><span class="dv">1</span> <span class="fu">:</span> (<span class="dv">2</span><span class="fu">*</span><span class="dv">2</span> <span class="fu">:</span> (<span class="dv">2</span><span class="fu">*</span><span class="dv">3</span> <span class="fu">:</span> doubleList []))</a>
<a class="sourceLine" id="cb208-6" data-line-number="6"><span class="fu">==&gt;</span> <span class="dv">2</span><span class="fu">*</span><span class="dv">1</span> <span class="fu">:</span> (<span class="dv">2</span><span class="fu">*</span><span class="dv">2</span> <span class="fu">:</span> (<span class="dv">2</span><span class="fu">*</span><span class="dv">3</span> <span class="fu">:</span> []))</a>
<a class="sourceLine" id="cb208-7" data-line-number="7"><span class="fu">===</span> [<span class="dv">2</span><span class="fu">*</span><span class="dv">1</span>, <span class="dv">2</span><span class="fu">*</span><span class="dv">2</span>, <span class="dv">2</span><span class="fu">*</span><span class="dv">3</span>]</a>
<a class="sourceLine" id="cb208-8" data-line-number="8"><span class="fu">==&gt;</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>]</a></code></pre></div>
<p>Once you know pattern matching for lists, it’s straightforward to define <code>map</code> and <code>filter</code>. Actually, let’s just look at the GHC standard library implementations. <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#map">Here’s map</a>:</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb209-1" data-line-number="1">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb209-2" data-line-number="2">map _ []     <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb209-3" data-line-number="3">map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</a></code></pre></div>
<p>and <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html#filter">here’s filter</a>:</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb210-1" data-line-number="1">filter<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb210-2" data-line-number="2">filter _pred []    <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb210-3" data-line-number="3">filter pred (x<span class="fu">:</span>xs)</a>
<a class="sourceLine" id="cb210-4" data-line-number="4">  <span class="fu">|</span> pred x         <span class="fu">=</span> x <span class="fu">:</span> filter pred xs</a>
<a class="sourceLine" id="cb210-5" data-line-number="5">  <span class="fu">|</span> otherwise      <span class="fu">=</span> filter pred xs</a></code></pre></div>
<p>(<strong>Note!</strong> naming the argument <code>_pred</code> is a way to tell the reader of the code that this argument is unused. It could have been just <code>_</code> as well.)</p>
<!-- TODO: section that introduces different types of recursion:

- accumulator recursion (aka tail recursion)
- "direct recursion"
- multiple recursion

These can be then used in in explaining Set 3a Ex 14
-->
<h2 id="something-fun-list-comprehensions"><span class="header-section-number">3.9</span> Something fun: list comprehensions</h2>
<p>Haskell has <em>list comprehensions</em>, a nice syntax for defining lists that combines the power of <code>map</code> and <code>filter</code>. You might be familiar with Python’s list comprehensions already. Haskell’s work pretty much the same way, but their syntax is a bit different.</p>
<p>Mapping:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb211-1" data-line-number="1">[<span class="dv">2</span><span class="fu">*</span>i <span class="fu">|</span> i<span class="ot">&lt;-</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb211-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>]</a></code></pre></div>
<p>Filtering:</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb212-1" data-line-number="1">[i <span class="fu">|</span> i <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">7</span>], even i]</a>
<a class="sourceLine" id="cb212-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>]</a></code></pre></div>
<p>In general, these two forms are equivalent:</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb213-1" data-line-number="1">[f x <span class="fu">|</span> x <span class="ot">&lt;-</span> lis, p x]</a>
<a class="sourceLine" id="cb213-2" data-line-number="2">map f (filter p lis)</a></code></pre></div>
<p>List comprehensions can do even more. You can iterate over multiple lists:</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb214-1" data-line-number="1">[ first <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> last <span class="fu">|</span> first <span class="ot">&lt;-</span> [<span class="st">&quot;John&quot;</span>, <span class="st">&quot;Mary&quot;</span>], last <span class="ot">&lt;-</span> [<span class="st">&quot;Smith&quot;</span>,<span class="st">&quot;Cooper&quot;</span>] ]</a>
<a class="sourceLine" id="cb214-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="st">&quot;John Smith&quot;</span>,<span class="st">&quot;John Cooper&quot;</span>,<span class="st">&quot;Mary Smith&quot;</span>,<span class="st">&quot;Mary Cooper&quot;</span>]</a></code></pre></div>
<p>You can make local defitions:</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb215-1" data-line-number="1">[ reversed <span class="fu">|</span> word <span class="ot">&lt;-</span> [<span class="st">&quot;this&quot;</span>,<span class="st">&quot;is&quot;</span>,<span class="st">&quot;a&quot;</span>,<span class="st">&quot;string&quot;</span>], <span class="kw">let</span> reversed <span class="fu">=</span> reverse word ]</a>
<a class="sourceLine" id="cb215-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="st">&quot;siht&quot;</span>,<span class="st">&quot;si&quot;</span>,<span class="st">&quot;a&quot;</span>,<span class="st">&quot;gnirts&quot;</span>]</a></code></pre></div>
<p>You can even do pattern matching in list comprehensions!</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb216-1" data-line-number="1">firstLetters string <span class="fu">=</span> [ char <span class="fu">|</span> (char<span class="fu">:</span>_) <span class="ot">&lt;-</span> words string ]</a></code></pre></div>
<div class="sourceCode" id="cb217"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb217-1" data-line-number="1">firstLetters <span class="st">&quot;Hello World!&quot;</span></a>
<a class="sourceLine" id="cb217-2" data-line-number="2">  <span class="fu">==&gt;</span> <span class="st">&quot;HW&quot;</span></a></code></pre></div>
<h2 id="something-fun-custom-operators"><span class="header-section-number">3.10</span> Something fun: custom operators</h2>
<p>In Haskell an <em>operator</em> is anything built from the characters <code>!#$%&amp;*+./&lt;=&gt;?@\^|-~</code>. Operators can be defined just like functions (note the slightly different type annotation):</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb218-1" data-line-number="1"><span class="ot">(&lt;+&gt;) ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb218-2" data-line-number="2">xs <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span> zipWith (<span class="fu">+</span>) xs ys</a></code></pre></div>
<div class="sourceCode" id="cb219"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb219-1" data-line-number="1"><span class="ot">(+++) ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb219-2" data-line-number="2">a <span class="fu">+++</span> b <span class="fu">=</span> a <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> b</a></code></pre></div>
<h2 id="quiz-2"><span class="header-section-number">3.11</span> Quiz</h2>
<p>What’s the type of this function? <code>both p q x = p x &amp;&amp; q x</code></p>
<ol class="quiz">
<li>
<code>a -&gt; Bool -&gt; a -&gt; Bool -&gt; a -&gt; Bool</code>
</li>
<li class="correct">
<code>(a -&gt; Bool) -&gt; (a -&gt; Bool) -&gt; a -&gt; Bool</code>
</li>
<li>
<code>(a -&gt; Bool) -&gt; (b -&gt; Bool) -&gt; c -&gt; Bool</code>
</li>
</ol>
<p>What’s the type of this function? <code>applyInOut f g x = f (g (f x))</code></p>
<ol class="quiz">
<li class="correct">
<code>(a -&gt; b) -&gt; (b -&gt; a) -&gt; a -&gt; b</code>
</li>
<li>
<code>(a -&gt; b) -&gt; (b -&gt; c) -&gt; a -&gt; c</code>
</li>
<li>
<code>(a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a</code>
</li>
</ol>
<p>Which one of the following functions adds its first argument to the second?</p>
<ol class="quiz">
<li>
<code>f x x = x + x</code>
</li>
<li class="correct">
<code>f x = \y -&gt; x + y</code>
</li>
<li>
<code>f = \x y -&gt; x + x</code>
</li>
</ol>
<p>Which one of the following functions does not satisfy <code>f 1 ==&gt; 1</code>?</p>
<ol class="quiz">
<li>
<code>f x = (\y -&gt; y) x</code>
</li>
<li class="correct">
<code>f x = \y -&gt; y</code>
</li>
<li>
<code>f x = (\y -&gt; x) x</code>
</li>
</ol>
<p>Which one of the following functions is correctly typed?</p>
<ol class="quiz">
<li>
<code>f x y = not x; f :: (Bool -&gt; Bool) -&gt; Bool</code>
</li>
<li>
<code>f x = x ++ &quot;a&quot;; f :: Char -&gt; String</code>
</li>
<li class="correct">
<code>f x = 'a' : x; f :: String -&gt; String</code>
</li>
</ol>
<p>How many arguments does <code>drop 2</code> take?</p>
<ol class="quiz">
<li>
Zero
</li>
<li class="correct">
One
</li>
<li>
Two
</li>
</ol>
<p>What does this function do? <code>f (_:x:_) = x</code></p>
<ol class="quiz">
<li>
Returns the first element of a list
</li>
<li>
Returns an arbitrary element of a list
</li>
<li>
Returns all except the first and last elements of a list
</li>
<li class="correct">
Returns the second element of a list
</li>
</ol>
<p>What is the result of <code>reverse $ take 5 . tail $ &quot;This is a test&quot;</code>?</p>
<ol class="quiz">
<li class="correct">
<code>&quot;i sih&quot;</code>
</li>
<li>
<code>&quot;set a&quot;</code>
</li>
<li>
A type error
</li>
</ol>
<h2 id="exercises-2"><span class="header-section-number">3.12</span> Exercises</h2>
<ul>
<li><a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set3a.hs">Set3a</a>: normal list exercises</li>
<li><a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set3b.hs">Set3b</a>: list recursion exercises</li>
</ul>
<p>Remember to give <a href="https://forms.gle/YCo2jAaUTg9vER7G6">feedback</a>!</p>
<h1 id="lecture-4-real-classy"><span class="header-section-number">4</span> Lecture 4: Real Classy</h1>
<ul>
<li>Tuples</li>
<li>Type classes</li>
<li>Data structures: Map, Array</li>
</ul>
<h2 id="sidenote-tuples"><span class="header-section-number">4.1</span> Sidenote: tuples</h2>
<p>Before we dive into type classes, let’s introduce the last remaining built-in datatype in Haskell: the tuple. <em>Tuples</em> or <em>pairs</em> (or triples, quadruples, etc) are a way of bundling a couple of values of different types together. You can think of tuples as fixed-length lists (just like Python’s tuples). Unlike lists, each element in the tuple can have a different type. The types of the elements are reflected in the type of the tuple. Here are some examples of tuple types and values:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Example value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>(String,String)</code></td>
<td style="text-align: left;"><code>(&quot;Hello&quot;,&quot;World!&quot;)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>(Int,Bool)</code></td>
<td style="text-align: left;"><code>(1,True)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>(Int,Int,Int)</code></td>
<td style="text-align: left;"><code>(4,0,3)</code></td>
</tr>
</tbody>
</table>
<p>To get values out of tuples, you can use the functions <code>fst</code> and <code>snd</code>:</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb220-1" data-line-number="1">fst<span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb220-2" data-line-number="2">snd<span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>You can also pattern match on tuples. This is often the most convenient way, and also works for tuples of larger sizes. The <code>fst</code> and <code>snd</code> functions work only on pairs.</p>
<p>Tuples are very useful in combination with lists. Here are some examples using the <code>zip</code>, <code>unzip</code> and <code>partition</code> functions from the <code>Data.List</code> module.</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb221-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a, b)]    <span class="co">-- two lists to list of pairs</span></a>
<a class="sourceLine" id="cb221-2" data-line-number="2">unzip<span class="ot"> ::</span> [(a, b)] <span class="ot">-&gt;</span> ([a], [b])  <span class="co">-- list of pairs to pair of lists</span></a>
<a class="sourceLine" id="cb221-3" data-line-number="3"><span class="ot">partition ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> ([a], [a])    <span class="co">-- elements that satisfy and don&#39;t satisfy a predicate</span></a></code></pre></div>
<!-- How about `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`? -->
<div class="sourceCode" id="cb222"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb222-1" data-line-number="1">zip [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>]</a>
<a class="sourceLine" id="cb222-2" data-line-number="2">  <span class="fu">==&gt;</span> [(<span class="dv">1</span>,<span class="dt">True</span>),(<span class="dv">2</span>,<span class="dt">False</span>),(<span class="dv">3</span>,<span class="dt">True</span>)]</a>
<a class="sourceLine" id="cb222-3" data-line-number="3">unzip [(<span class="st">&quot;Fred&quot;</span>,<span class="dv">1</span>), (<span class="st">&quot;Jack&quot;</span>,<span class="dv">10</span>), (<span class="st">&quot;Helen&quot;</span>,<span class="dv">13</span>)]</a>
<a class="sourceLine" id="cb222-4" data-line-number="4">  <span class="fu">==&gt;</span> ([<span class="st">&quot;Fred&quot;</span>,<span class="st">&quot;Jack&quot;</span>,<span class="st">&quot;Helen&quot;</span>],[<span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">13</span>])</a>
<a class="sourceLine" id="cb222-5" data-line-number="5">partition (<span class="fu">&gt;</span><span class="dv">0</span>) [<span class="fu">-</span><span class="dv">1</span>,<span class="dv">1</span>,<span class="fu">-</span><span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb222-6" data-line-number="6">  <span class="fu">==&gt;</span> ([<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>],[<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">4</span>,<span class="dv">0</span>])</a></code></pre></div>
<p>Here’s an example of pattern matching on tuples:</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb223-1" data-line-number="1"><span class="ot">swap ::</span> (a,b) <span class="ot">-&gt;</span> (b,a)</a>
<a class="sourceLine" id="cb223-2" data-line-number="2">swap (x,y) <span class="fu">=</span> (y,x)</a></code></pre></div>
<p>Here’s an example of pattern matching on tuples and lists at the same time:</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb224-1" data-line-number="1"><span class="co">-- sum all numbers that are paired with True</span></a>
<a class="sourceLine" id="cb224-2" data-line-number="2"><span class="ot">sumIf ::</span> [(<span class="dt">Bool</span>,<span class="dt">Int</span>)] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb224-3" data-line-number="3">sumIf [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb224-4" data-line-number="4">sumIf ((<span class="dt">True</span>,x)<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> sumIf xs</a>
<a class="sourceLine" id="cb224-5" data-line-number="5">sumIf ((<span class="dt">False</span>,_)<span class="fu">:</span>xs) <span class="fu">=</span> sumIf xs</a></code></pre></div>
<div class="sourceCode" id="cb225"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb225-1" data-line-number="1">sumIf [(<span class="dt">True</span>,<span class="dv">1</span>),(<span class="dt">False</span>,<span class="dv">10</span>),(<span class="dt">True</span>,<span class="dv">100</span>)]</a>
<a class="sourceLine" id="cb225-2" data-line-number="2">  <span class="fu">==&gt;</span> <span class="dv">101</span></a></code></pre></div>
<h2 id="interlude-folding"><span class="header-section-number">4.2</span> Interlude: folding</h2>
<!-- TODO: should this be in the same section as foldable? -->
<p>Consider the functions <code>sumNumbers :: [Int] -&gt; Int</code>, <code>myMaximum :: [Int] -&gt; Int</code>, and <code>countNothings :: [Maybe a] -&gt; Int</code> again.</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb226-1" data-line-number="1"><span class="ot">sumNumbers ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb226-2" data-line-number="2">sumNumbers [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb226-3" data-line-number="3">sumNumbers (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> sumNumbers xs</a>
<a class="sourceLine" id="cb226-4" data-line-number="4"></a>
<a class="sourceLine" id="cb226-5" data-line-number="5"><span class="ot">myMaximum ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb226-6" data-line-number="6">myMaximum [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb226-7" data-line-number="7">myMaximum (x<span class="fu">:</span>xs) <span class="fu">=</span> go x xs</a>
<a class="sourceLine" id="cb226-8" data-line-number="8">  <span class="kw">where</span> go biggest [] <span class="fu">=</span> biggest</a>
<a class="sourceLine" id="cb226-9" data-line-number="9">        go biggest (x<span class="fu">:</span>xs) <span class="fu">=</span> go (max biggest x) xs</a>
<a class="sourceLine" id="cb226-10" data-line-number="10"></a>
<a class="sourceLine" id="cb226-11" data-line-number="11"><span class="ot">countNothings ::</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb226-12" data-line-number="12">countNothings [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb226-13" data-line-number="13">countNothings (<span class="dt">Nothing</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> countNothings xs</a>
<a class="sourceLine" id="cb226-14" data-line-number="14">countNothings (<span class="dt">Just</span> _  <span class="fu">:</span> xs) <span class="fu">=</span> countNothings xs</a></code></pre></div>
<p>They have one common characteristic. They take a list and produce a value that depends on the values of the elements in the given list. They “crunch” or <em>fold</em> a list of many values into a single value.</p>
<p>Prelude has a function called <code>foldr</code>, which performs a <em>right associative fold</em> over a <code>Foldable</code> data type. We’ll learn more about <code>Foldable</code> soon. At this point, it suffices to think of lists, so we define</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb227-1" data-line-number="1">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb227-2" data-line-number="2">foldr f y []     <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb227-3" data-line-number="3">foldr f y (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (foldr f y xs)</a></code></pre></div>
<p>What this definition says, is that for an empty list <code>[] :: [a]</code>, <code>foldr</code> returns the default value <code>y :: b</code>. For any other list <code>x : xs</code>, <code>foldr</code> applies <code>f</code> to <code>x</code> and the result of <code>foldr f y xs</code> (i.e. folding over the rest of the list). It’s a simple definition by recursion.</p>
<p>Consider the list <code>[1,2,3]</code>:</p>
<pre><code>   (:)
  /   \
 1    (:)
     /   \
    2    (:)
        /   \
       3    []</code></pre>
<p>The expression <code>foldr (+) 0 [1,2,3]</code> evaluates as follows:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb229-1" data-line-number="1">foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">==&gt;</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span>[])</a>
<a class="sourceLine" id="cb229-2" data-line-number="2">                    <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> (foldr (<span class="fu">+</span>) <span class="dv">0</span> (<span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span>[]))</a>
<a class="sourceLine" id="cb229-3" data-line-number="3">                    <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (foldr (<span class="fu">+</span>) <span class="dv">0</span> (<span class="dv">3</span><span class="fu">:</span>[])))</a>
<a class="sourceLine" id="cb229-4" data-line-number="4">                    <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> (foldr (<span class="fu">+</span>) <span class="dv">0</span> [])))</a>
<a class="sourceLine" id="cb229-5" data-line-number="5">                    <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>))</a></code></pre></div>
<p>The result can be thought of as a tree:</p>
<pre><code>   (+)
  /   \
 1    (+)
     /   \
    2    (+)
        /   \
       3     0</code></pre>
<p>One way to think about <code>foldr f y xs</code> is that it replaces the <code>(:)</code> operation with <code>f</code> and <code>[]</code> with <code>y</code>. In this case, <code>f</code> was <code>(+)</code> and <code>y</code> was <code>0</code>. If you write out how <code>sumNumbers [1,2,3]</code> behaves, you’ll notice that it performs the same computation as <code>foldr (+) 0 [1,2,3]</code> does! More generally:</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb231-1" data-line-number="1">sumNumbers xs <span class="fu">==</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> xs</a></code></pre></div>
<p>Those more experienced with math may notice that we can prove this claim by <em>induction</em>: Firstly, <code>sumNumbers [] ==&gt; 0</code> and <code>foldr (+) 0 [] ==&gt; 0</code>, so in the base case <code>sumNumbers [] == foldr (+) 0 []</code>. Next, we may assume as our induction hypothesis that <code>sumNumbers xs == foldr (+) 0 xs</code> for any list <code>xs</code>. Then, for the list <code>x:xs</code>, we have <code>sumNumbers (x:xs) ==&gt; x + sumNumbers xs</code>. Hence, <code>foldr (+) 0 (x:xs) ==&gt; x + foldr (+) 0 xs ==&gt; x + sumNumbers xs</code> by induction hypothesis. Therefore, by induction, the equation holds.</p>
<p>You don’t need to read, write, or understand induction proofs in this course, but perhaps it is reassuring to know that properties and equalities of functions in Haskell can be (in principle) analysed mathematically, because Haskell is such a nice language. (Equalities and properties can be analysed in any programming language, but for Haskell, this analysis is especially convenient because Haskell is pure.)</p>
<p>Another folding example is the <code>map</code> function:</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb232-1" data-line-number="1">map g xs <span class="fu">=</span> foldr helper [] xs</a>
<a class="sourceLine" id="cb232-2" data-line-number="2">  <span class="kw">where</span> helper y ys <span class="fu">=</span> g y <span class="fu">:</span> ys</a></code></pre></div>
<p>To see why this works, consider what <code>foldr helper [] [x1,x2,..,xn]</code> does:</p>
<pre><code>   (:)                                    helper
  /   \                                   /   \
 x1   (:)                                x1  helper
     /   \                                   /   \
    x2   (:)                                x2  helper
        /   \                 ==&gt;               /   \
       x3   ...                                x3   ...
               \                                       \
               (:)                                    helper
              /   \                                   /   \
             xn    []                                xn    y</code></pre>
<p>Now, since <code>helper x xs ==&gt; g x : xs</code> for every <code>x</code> and <code>xs</code>, we get that:</p>
<pre><code>  helper                                   (:)
  /   \                                   /   \
 x1  helper                             g x1  (:)
     /   \                                   /   \
    x2  helper                             g x2  (:)
        /   \                 ==&gt;               /   \
       x3   ...                               g x3  ...
               \                                       \
              helper                                   (:)
              /   \                                   /   \
             xn    y                                g xn   y</code></pre>
<p>The resulting list is then exactly what we would have gotten with <code>map g xs</code>. (This could have been also proved by induction as we did for <code>sumNumbers</code>.) The lesson to take away is that folding is a particular, yet quite general, way to apply some transformation recursively into some structure (e.g. a list).</p>
<h2 id="type-classes"><span class="header-section-number">4.3</span> Type classes</h2>
<p>How can Haskell’s <code>+</code> work on both <code>Int</code>s and <code>Double</code>s? Why can I compare all sorts of things with <code>==</code>? We’ve briefly mentioned constrained types earlier. Let’s see what they really mean. Let’s look at the types of <code>==</code> and <code>+</code>.</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb235-1" data-line-number="1"><span class="ot">(==) ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p>The type <code>(Eq a) =&gt; a -&gt; a -&gt; Bool</code> means: <em>for all types <code>a</code> that belong to the class <code>Eq</code>, this is a function of type <code>a -&gt; a -&gt; Bool</code></em>. That is, if the type <code>a</code> is a member of the class <code>Eq</code>, you can give two values of type <code>a</code> to <code>==</code> and get a <code>Bool</code> result.</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb236-1" data-line-number="1"><span class="ot">(+) ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>Similarly, the type <code>(Num a) =&gt; a -&gt; a -&gt; a</code> means: <em>for all types <code>a</code> that belong to the class <code>Num</code>, this is a function of type <code>a -&gt; a -&gt; a</code></em>. That is, you can give two values of the same type <code>a</code> to <code>+</code> and get out a third value of type <code>a</code>, as long as <code>a</code> is a member of <code>Num</code>.</p>
<p><code>Num</code> and <code>Eq</code> are type classes. A <em>type class</em> is a way to group together types that support similar operations.</p>
<p><strong>Note!</strong> A type class is a collection of types. It doesn’t have much to do with the classes of object oriented programming! In some situations, type classes can act like <em>interfaces</em> in object oriented programming. Unfortunately the functions in a type class are often called <em>methods</em>, adding to the confusion.</p>
<p>PS. remember how using type variables for polymorphism was called <em>parametric polymorphism</em>? The fancy word for what type classes achieve is <em>ad-hoc polymorphism</em>. The difference is that with parametric polymorphism the function (e.g. <code>head</code>) has the same implementation for all types, whereas with ad-hoc polymorphisms there are multiple implementations (consider <code>==</code> on numbers and strings).</p>
<h2 id="type-constraints"><span class="header-section-number">4.4</span> Type constraints</h2>
<p>When you’re working with a concrete type (not a type variable), you can just use type class functions (in this case, <code>(==)</code>):</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb237-1" data-line-number="1"><span class="ot">f ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb237-2" data-line-number="2">f g x <span class="fu">=</span> x <span class="fu">==</span> g x</a></code></pre></div>
<p>Of course, if the type in question isn’t a member of the right class, you get an error. For example:</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb238-1" data-line-number="1"><span class="ot">addTrue ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb238-2" data-line-number="2">addTrue b <span class="fu">=</span> b <span class="fu">+</span> <span class="dt">True</span></a></code></pre></div>
<pre><code>error:
    • No instance for (Num Bool) arising from a use of ‘+’
    • In the expression: b + True
      In an equation for ‘addTrue’: addTrue b = b + True</code></pre>
<p>However in a <em>polymorphic</em> function, you need to add <em>type constraints</em>. This doesn’t work:</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb240-1" data-line-number="1"><span class="ot">f ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb240-2" data-line-number="2">f g x <span class="fu">=</span> x <span class="fu">==</span> g x</a></code></pre></div>
<p>Luckily the error is nice:</p>
<pre><code>error:
    • No instance for (Eq a) arising from a use of ‘==’
      Possible fix:
        add (Eq a) to the context of
          the type signature for:
            f :: (a -&gt; a) -&gt; a -&gt; Bool
    • In the expression: x == g x
      In an equation for ‘f’: f g x = x == g x</code></pre>
<p>To signal that <code>f</code> only works on types that are members of the <code>Eq</code> class, we add a type constraint <code>(Eq a) =&gt;</code> to the type annotation.</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb242-1" data-line-number="1"><span class="ot">f ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb242-2" data-line-number="2">f g x <span class="fu">=</span> x <span class="fu">==</span> g x</a></code></pre></div>
<p>If you don’t have a type annotation, <em>type inference</em> can provide the constraints!</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb243-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> f g x <span class="fu">=</span> x <span class="fu">==</span> g x</a>
<a class="sourceLine" id="cb243-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> f</a>
<a class="sourceLine" id="cb243-3" data-line-number="3"><span class="ot">f ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p>You can also have multiple constraints:</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb244-1" data-line-number="1"><span class="ot">bothPairsEqual ::</span> (<span class="dt">Eq</span> a, <span class="dt">Eq</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb244-2" data-line-number="2">bothPairsEqual left1 left2 right1 right2 <span class="fu">=</span> left1 <span class="fu">==</span> left2 <span class="fu">&amp;&amp;</span> right1 <span class="fu">==</span> right2</a></code></pre></div>
<h2 id="standard-type-classes"><span class="header-section-number">4.5</span> Standard type classes</h2>
<p>Here are some standard Haskell type classes you should know about.</p>
<h3 id="eq"><span class="header-section-number">4.5.1</span> <code>Eq</code></h3>
<p>We already saw the <code>Eq</code> class for equality comparisons. Here are the basic operations of the <code>Eq</code> class and some examples of their use. As you can see pretty much all the types we’ve seen so far, except for functions, are members of <code>Eq</code>.</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb245-1" data-line-number="1"><span class="ot">(==) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb245-2" data-line-number="2"><span class="ot">(/=) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<div class="sourceCode" id="cb246"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb246-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">==</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb246-2" data-line-number="2"><span class="dt">False</span></a>
<a class="sourceLine" id="cb246-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">/=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb246-4" data-line-number="4"><span class="dt">True</span></a>
<a class="sourceLine" id="cb246-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;Foo&quot;</span> <span class="fu">==</span> <span class="st">&quot;Bar&quot;</span></a>
<a class="sourceLine" id="cb246-6" data-line-number="6"><span class="dt">False</span></a>
<a class="sourceLine" id="cb246-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> [[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">4</span>]] <span class="fu">==</span> [[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">4</span>]]</a>
<a class="sourceLine" id="cb246-8" data-line-number="8"><span class="dt">True</span></a>
<a class="sourceLine" id="cb246-9" data-line-number="9"><span class="dt">Prelude</span><span class="fu">&gt;</span> (\x <span class="ot">-&gt;</span> x<span class="fu">+</span><span class="dv">1</span>) <span class="fu">==</span> (\x <span class="ot">-&gt;</span> x<span class="fu">+</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb246-10" data-line-number="10"></a>
<a class="sourceLine" id="cb246-11" data-line-number="11"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">5</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb246-12" data-line-number="12">    • <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Eq</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>))</a>
<a class="sourceLine" id="cb246-13" data-line-number="13">        arising from a use <span class="kw">of</span> ‘<span class="fu">==</span>’</a>
<a class="sourceLine" id="cb246-14" data-line-number="14">        (maybe you haven&#39;t applied a function to enough arguments<span class="fu">?</span>)</a>
<a class="sourceLine" id="cb246-15" data-line-number="15">    • <span class="dt">In</span> the expression<span class="fu">:</span> (\ x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">==</span> (\ x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb246-16" data-line-number="16">      <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> (\ x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">==</span> (\ x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">2</span>)</a></code></pre></div>
<p>There are some other useful functions that use the <code>Eq</code> class, like <code>nub</code> from the module <code>Data.List</code>.</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb247-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb247-2" data-line-number="2"><span class="dt">Prelude</span> <span class="dt">Data.List</span><span class="fu">&gt;</span> <span class="fu">:</span>t nub</a>
<a class="sourceLine" id="cb247-3" data-line-number="3"><span class="ot">nub ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb247-4" data-line-number="4"><span class="dt">Prelude</span> <span class="dt">Data.List</span><span class="fu">&gt;</span> nub [<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>]      <span class="co">-- eliminates duplicates</span></a>
<a class="sourceLine" id="cb247-5" data-line-number="5">[<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">1</span>]</a></code></pre></div>
<h3 id="ord"><span class="header-section-number">4.5.2</span> <code>Ord</code></h3>
<p>The <code>Ord</code> class is for ordering (less than, greater than). Again, here are the basic operations and some examples of their use. Note the new <code>Ordering</code> type. It has values <code>LT</code> for “less than”, <code>EQ</code> for “equal” and <code>GT</code> for “greater than”.</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb248-1" data-line-number="1">compare<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></a>
<a class="sourceLine" id="cb248-2" data-line-number="2"><span class="ot">(&lt;) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb248-3" data-line-number="3"><span class="ot">(&gt;) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb248-4" data-line-number="4"><span class="ot">(&gt;=) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb248-5" data-line-number="5"><span class="ot">(&lt;=) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb248-6" data-line-number="6">max<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb248-7" data-line-number="7">min<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<div class="sourceCode" id="cb249"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb249-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> compare <span class="dv">1</span> <span class="dv">1</span>                <span class="co">-- 1 is EQual to 1</span></a>
<a class="sourceLine" id="cb249-2" data-line-number="2"><span class="dt">EQ</span></a>
<a class="sourceLine" id="cb249-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> compare <span class="dv">1</span> <span class="dv">3</span>                <span class="co">-- 1 is Less Than 3</span></a>
<a class="sourceLine" id="cb249-4" data-line-number="4"><span class="dt">LT</span></a>
<a class="sourceLine" id="cb249-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> compare <span class="dv">1</span> <span class="dv">0</span>                <span class="co">-- 1 is Greater Than 0</span></a>
<a class="sourceLine" id="cb249-6" data-line-number="6"><span class="dt">GT</span></a>
<a class="sourceLine" id="cb249-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> min <span class="dv">5</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb249-8" data-line-number="8"><span class="dv">3</span></a>
<a class="sourceLine" id="cb249-9" data-line-number="9"><span class="dt">Prelude</span><span class="fu">&gt;</span> max <span class="dv">5</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb249-10" data-line-number="10"><span class="dv">5</span></a>
<a class="sourceLine" id="cb249-11" data-line-number="11"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;aardvark&quot;</span> <span class="fu">&lt;</span> <span class="st">&quot;banana&quot;</span>      <span class="co">-- strings are compared alphabetically</span></a>
<a class="sourceLine" id="cb249-12" data-line-number="12"><span class="dt">True</span></a>
<a class="sourceLine" id="cb249-13" data-line-number="13"><span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">&gt;</span> [<span class="dv">2</span>,<span class="dv">5</span>]            <span class="co">-- lists are compared like strings</span></a>
<a class="sourceLine" id="cb249-14" data-line-number="14"><span class="dt">False</span></a>
<a class="sourceLine" id="cb249-15" data-line-number="15"><span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">&gt;</span> [<span class="dv">1</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb249-16" data-line-number="16"><span class="dt">True</span></a></code></pre></div>
<p>When we can compare values, we can also sort lists of them. The function <code>sort</code> from <code>Data.List</code> works on all types that belong to the <code>Ord</code> class.</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb250-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb250-2" data-line-number="2"><span class="dt">Prelude</span> <span class="dt">Data.List</span><span class="fu">&gt;</span> <span class="fu">:</span>t sort</a>
<a class="sourceLine" id="cb250-3" data-line-number="3">sort<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb250-4" data-line-number="4"><span class="dt">Prelude</span> <span class="dt">Data.List</span><span class="fu">&gt;</span> sort [<span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb250-5" data-line-number="5">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>]</a>
<a class="sourceLine" id="cb250-6" data-line-number="6"><span class="dt">Prelude</span> <span class="dt">Data.List</span><span class="fu">&gt;</span> sort <span class="st">&quot;black sphinx of quartz, judge my vow!&quot;</span>     <span class="co">-- remember, strings are lists!</span></a>
<a class="sourceLine" id="cb250-7" data-line-number="7"><span class="st">&quot;      !,aabcdefghijklmnoopqrstuuvwxyz&quot;</span></a></code></pre></div>
<p>As a last example, let’s sort a list of lists according to length. We’ll need two helper functions:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb251-1" data-line-number="1"><span class="co">-- from the module Data.Ord</span></a>
<a class="sourceLine" id="cb251-2" data-line-number="2"><span class="co">-- compares two values &quot;through&quot; the function f</span></a>
<a class="sourceLine" id="cb251-3" data-line-number="3"><span class="ot">comparing ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Ordering</span></a>
<a class="sourceLine" id="cb251-4" data-line-number="4">comparing f x y <span class="fu">=</span> compare (f x) (f y)</a>
<a class="sourceLine" id="cb251-5" data-line-number="5"></a>
<a class="sourceLine" id="cb251-6" data-line-number="6"><span class="co">-- from the module Data.List</span></a>
<a class="sourceLine" id="cb251-7" data-line-number="7"><span class="co">-- sorts a list using the given comparison function</span></a>
<a class="sourceLine" id="cb251-8" data-line-number="8"><span class="ot">sortBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a></code></pre></div>
<p>Now the implementation of <code>sortByLength</code> is straightforward:</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb252-1" data-line-number="1"><span class="co">-- sorts lists by their length</span></a>
<a class="sourceLine" id="cb252-2" data-line-number="2"><span class="ot">sortByLength ::</span> [[a]] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb252-3" data-line-number="3">sortByLength <span class="fu">=</span> sortBy (comparing length)</a></code></pre></div>
<div class="sourceCode" id="cb253"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb253-1" data-line-number="1">sortByLength [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]]   <span class="fu">==&gt;</span>  [[<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]]</a></code></pre></div>
<h3 id="num-integral-fractional-floating"><span class="header-section-number">4.5.3</span> <code>Num</code>, <code>Integral</code>, <code>Fractional</code>, <code>Floating</code></h3>
<p>The <code>Num</code> class contains integer arithmetic:</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb254-1" data-line-number="1"><span class="ot">(+) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb254-2" data-line-number="2"><span class="ot">(-) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb254-3" data-line-number="3"><span class="ot">(*) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb254-4" data-line-number="4">negate<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a    <span class="co">-- 0-x</span></a>
<a class="sourceLine" id="cb254-5" data-line-number="5">abs<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a       <span class="co">-- absolute value</span></a>
<a class="sourceLine" id="cb254-6" data-line-number="6">signum<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a    <span class="co">-- -1 for negative values, 0 for 0, +1 for positive values</span></a>
<a class="sourceLine" id="cb254-7" data-line-number="7">fromInteger<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a</a></code></pre></div>
<p><code>Num</code> also shows up in the types of integer literals:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb255-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dv">12</span></a>
<a class="sourceLine" id="cb255-2" data-line-number="2"><span class="dv">12</span><span class="ot"> ::</span> <span class="dt">Num</span> p <span class="ot">=&gt;</span> p</a></code></pre></div>
<p><code>Integral</code> is the class of types that represent whole numbers, like <code>Int</code> and <code>Integer</code>. The most interesting functions are <code>div</code> and <code>mod</code> for integer division and remainder. All types that belong to <code>Integral</code> also belong to <code>Num</code>.</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb256-1" data-line-number="1">div<span class="ot"> ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb256-2" data-line-number="2">mod<span class="ot"> ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p><code>Fractional</code> is the class for types that have division. All types that belong to <code>Fractional</code> also belong to <code>Num</code>.</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb257-1" data-line-number="1"><span class="ot">(/) ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p><code>Floating</code> contains some additional operations that only make sense for floating point numbers. All types that belong to <code>Floating</code> also belong to <code>Fractional</code> (and to <code>Num</code>).</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb258-1" data-line-number="1">sqrt<span class="ot"> ::</span> <span class="dt">Floating</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb258-2" data-line-number="2">sin<span class="ot"> ::</span> <span class="dt">Floating</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<h3 id="read-and-show"><span class="header-section-number">4.5.4</span> <code>Read</code> and <code>Show</code></h3>
<p>The <code>Show</code> and <code>Read</code> classes are for the functions <code>show</code> and <code>read</code>, that convert values to and from Strings.</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb259-1" data-line-number="1">show<span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb259-2" data-line-number="2">read<span class="ot"> ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</a></code></pre></div>
<div class="sourceCode" id="cb260"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb260-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> show <span class="dv">3</span></a>
<a class="sourceLine" id="cb260-2" data-line-number="2"><span class="st">&quot;3&quot;</span></a>
<a class="sourceLine" id="cb260-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> read <span class="st">&quot;3&quot;</span><span class="ot"> ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb260-4" data-line-number="4"><span class="dv">3</span></a>
<a class="sourceLine" id="cb260-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> read <span class="st">&quot;3&quot;</span><span class="ot"> ::</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb260-6" data-line-number="6"><span class="fl">3.0</span></a></code></pre></div>
<p>As you can see above, you often need to use a type annotation with <code>read</code> so that the compiler can choose the right implementation.</p>
<h3 id="sidenote-foldable"><span class="header-section-number">4.5.5</span> Sidenote: <code>Foldable</code></h3>
<p>One more thing! You might remember that it was mentioned earlier that the type of <code>length</code> isn’t <code>[a] -&gt; Int</code> but something more general. Let’s have a look:</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb261-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t length</a>
<a class="sourceLine" id="cb261-2" data-line-number="2">length<span class="ot"> ::</span> <span class="dt">Foldable</span> t <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>This type looks a bit different than the ones we’ve seen before. The type variable <code>t</code> has an argument <code>a</code>. We’ll look at type classes like this in more detail in part 2, but here’s a crash course.</p>
<p>What <code>Foldable</code> represents is types that you can fold over. The true type of <code>foldr</code> is:</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb262-1" data-line-number="1">foldr<span class="ot"> ::</span> <span class="dt">Foldable</span> t <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>We’ve succesfully used the fact that lists are <code>Foldable</code> since we’ve managed to use <code>length</code> and <code>foldr</code> on lists. However, <code>Maybe</code> is also <code>Foldable</code>! The <code>Foldable</code> instance for <code>Maybe</code> just pretends that values of <code>Maybe a</code> are like lists of length 0 or 1:</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb263-1" data-line-number="1">foldr <span class="dv">1</span> (<span class="fu">+</span>) <span class="dt">Nothing</span> <span class="fu">==&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb263-2" data-line-number="2">foldr <span class="dv">1</span> (<span class="fu">+</span>) <span class="dt">Just</span> <span class="dv">3</span>  <span class="fu">==&gt;</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb263-3" data-line-number="3">length <span class="dt">Nothing</span>      <span class="fu">==&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb263-4" data-line-number="4">length (<span class="dt">Just</span> <span class="ch">&#39;a&#39;</span>)   <span class="fu">==&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>We’ll encounter another foldable type soon.</p>
<h2 id="sidenote-the-case-of-expression"><span class="header-section-number">4.6</span> Sidenote: The case-of expression</h2>
<p>We’ve seen pattern matching in function arguments, but there’s also a way to pattern match in an expression. It looks like this:</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb264-1" data-line-number="1"><span class="kw">case</span> <span class="fu">&lt;</span>value<span class="fu">&gt;</span> <span class="kw">of</span> <span class="fu">&lt;</span>pattern<span class="fu">&gt;</span> <span class="ot">-&gt;</span> <span class="fu">&lt;</span>expression<span class="fu">&gt;</span></a>
<a class="sourceLine" id="cb264-2" data-line-number="2">                <span class="fu">&lt;</span>pattern<span class="fu">&gt;</span> <span class="ot">-&gt;</span> <span class="fu">&lt;</span>expression<span class="fu">&gt;</span></a></code></pre></div>
<p>As an example let’s rewrite the <code>describe</code> example from the first lecture using <code>case</code>:</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb265-1" data-line-number="1"><span class="ot">describe ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb265-2" data-line-number="2">describe <span class="dv">0</span> <span class="fu">=</span> <span class="st">&quot;zero&quot;</span></a>
<a class="sourceLine" id="cb265-3" data-line-number="3">describe <span class="dv">1</span> <span class="fu">=</span> <span class="st">&quot;one&quot;</span></a>
<a class="sourceLine" id="cb265-4" data-line-number="4">describe <span class="dv">2</span> <span class="fu">=</span> <span class="st">&quot;an even prime&quot;</span></a>
<a class="sourceLine" id="cb265-5" data-line-number="5">describe n <span class="fu">=</span> <span class="st">&quot;the number &quot;</span> <span class="fu">++</span> show n</a></code></pre></div>
<div class="sourceCode" id="cb266"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb266-1" data-line-number="1"><span class="ot">describe ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb266-2" data-line-number="2">describe n <span class="fu">=</span> <span class="kw">case</span> n <span class="kw">of</span> <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="st">&quot;zero&quot;</span></a>
<a class="sourceLine" id="cb266-3" data-line-number="3">                       <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="st">&quot;one&quot;</span></a>
<a class="sourceLine" id="cb266-4" data-line-number="4">                       <span class="dv">2</span> <span class="ot">-&gt;</span> <span class="st">&quot;an even prime&quot;</span></a>
<a class="sourceLine" id="cb266-5" data-line-number="5">                       n <span class="ot">-&gt;</span> <span class="st">&quot;the number &quot;</span> <span class="fu">++</span> show n</a></code></pre></div>
<p>A more interesting example is when the value we’re pattern matching on is not a function argument. For example:</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb267-1" data-line-number="1"><span class="ot">search ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb267-2" data-line-number="2">search p xs <span class="fu">=</span> <span class="kw">case</span> filter p xs <span class="kw">of</span> [] <span class="ot">-&gt;</span> <span class="st">&quot;not found&quot;</span></a>
<a class="sourceLine" id="cb267-3" data-line-number="3">                                  (x<span class="fu">:</span>_) <span class="ot">-&gt;</span> <span class="st">&quot;found &quot;</span> <span class="fu">++</span> show x</a></code></pre></div>
<div class="sourceCode" id="cb268"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb268-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> search even [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb268-2" data-line-number="2"><span class="st">&quot;found 2&quot;</span></a>
<a class="sourceLine" id="cb268-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> search even [<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">7</span>]</a>
<a class="sourceLine" id="cb268-4" data-line-number="4"><span class="st">&quot;not found&quot;</span></a></code></pre></div>
<p>If we wanted to write <code>search</code> using normal pattern matching, we would need a helper function:</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb269-1" data-line-number="1"><span class="ot">search ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb269-2" data-line-number="2">search p xs <span class="fu">=</span> searchResult (filter p xs)</a>
<a class="sourceLine" id="cb269-3" data-line-number="3">  <span class="kw">where</span> searchResult [] <span class="fu">=</span> <span class="st">&quot;not found&quot;</span></a>
<a class="sourceLine" id="cb269-4" data-line-number="4">        searchResult (x<span class="fu">:</span>_) <span class="fu">=</span> <span class="st">&quot;found &quot;</span> <span class="fu">++</span> show x</a></code></pre></div>
<h2 id="more-data-structures"><span class="header-section-number">4.7</span> More data structures</h2>
<p>Now that we are familiar with the standard type classes, we can look at one of their applications: the <code>Map</code> and <code>Array</code> data structures.</p>
<h3 id="data.map"><span class="header-section-number">4.7.1</span> <code>Data.Map</code></h3>
<p>The <code>Data.Map</code> module defines the <code>Map</code> type. Maps are search trees for key-value pairs. One way to look at this is that a value of type <code>Map k v</code> is roughly the same as a value of type <code>[(k,v)]</code>, a list of pairs. However, the operations on a map are more efficient than operations on a list.</p>
<p>Since <code>Data.Map</code> contains some function with the same names as <code>Prelude</code> functions, the namespace needs to be imported <em>qualified</em>:</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb270-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></a></code></pre></div>
<p>Now we can refer to the map type as <code>Map.Map</code>, and to various map functions like <code>Map.insert</code>. Here are the most important functions for maps:</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb271-1" data-line-number="1"><span class="co">-- Create a Map from a list of key-value pairs</span></a>
<a class="sourceLine" id="cb271-2" data-line-number="2">Map.fromList<span class="ot"> ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> [(k, a)] <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k a</a>
<a class="sourceLine" id="cb271-3" data-line-number="3"></a>
<a class="sourceLine" id="cb271-4" data-line-number="4"><span class="co">-- Insert a value into a map. Overrides any previous value with the same key.</span></a>
<a class="sourceLine" id="cb271-5" data-line-number="5"><span class="co">-- Returns a new map. Does not mutate the given map.</span></a>
<a class="sourceLine" id="cb271-6" data-line-number="6">Map.insert<span class="ot"> ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k a <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k a</a>
<a class="sourceLine" id="cb271-7" data-line-number="7"></a>
<a class="sourceLine" id="cb271-8" data-line-number="8"><span class="co">-- Get a value from a map using a key. Returns Nothing if the key was not present in the map.</span></a>
<a class="sourceLine" id="cb271-9" data-line-number="9">Map.lookup<span class="ot"> ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb271-10" data-line-number="10"></a>
<a class="sourceLine" id="cb271-11" data-line-number="11"><span class="co">-- An empty map</span></a>
<a class="sourceLine" id="cb271-12" data-line-number="12">Map.empty<span class="ot"> ::</span> <span class="dt">Map.Map</span> k a</a></code></pre></div>
<p>The <code>Ord</code> constraint for the key type of the map is needed because maps are implemented as <em>ordered binary search trees</em>.</p>
<p>Here’s an example of representing a bank as a <code>Map String Int</code> (map from account name to account balance), and withdrawing some money from an account:</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb272-1" data-line-number="1"><span class="ot">withdraw ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb272-2" data-line-number="2">withdraw account amount bank <span class="fu">=</span></a>
<a class="sourceLine" id="cb272-3" data-line-number="3">  <span class="kw">case</span> Map.lookup account bank <span class="kw">of</span></a>
<a class="sourceLine" id="cb272-4" data-line-number="4">    <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> bank                                   <span class="co">-- account not found, no change</span></a>
<a class="sourceLine" id="cb272-5" data-line-number="5">    <span class="dt">Just</span> sum <span class="ot">-&gt;</span> Map.insert account (sum<span class="fu">-</span>amount) bank   <span class="co">-- set new balance</span></a></code></pre></div>
<p>Here’s how you might use the <code>withdraw</code> function in <code>GHCi</code>. Note how the maps get printed as <code>fromList</code> invocations. Also note how calling <code>withdraw ... bank</code> returns a <em>new</em> bank and doesn’t change the existing bank. Maps are <em>immutable</em> just like other Haskell data structures like lists.</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb273-1" data-line-number="1"><span class="dt">GHCi</span><span class="fu">&gt;</span> <span class="kw">let</span> bank <span class="fu">=</span> Map.fromList [(<span class="st">&quot;Bob&quot;</span>,<span class="dv">100</span>),(<span class="st">&quot;Mike&quot;</span>,<span class="dv">50</span>)]</a>
<a class="sourceLine" id="cb273-2" data-line-number="2"><span class="dt">GHCi</span><span class="fu">&gt;</span> withdraw <span class="st">&quot;Bob&quot;</span> <span class="dv">80</span> bank</a>
<a class="sourceLine" id="cb273-3" data-line-number="3">fromList [(<span class="st">&quot;Bob&quot;</span>,<span class="dv">20</span>),(<span class="st">&quot;Mike&quot;</span>,<span class="dv">50</span>)]</a>
<a class="sourceLine" id="cb273-4" data-line-number="4"><span class="dt">GHCi</span><span class="fu">&gt;</span> withdraw <span class="st">&quot;Bozo&quot;</span> <span class="dv">1000</span> bank</a>
<a class="sourceLine" id="cb273-5" data-line-number="5">fromList [(<span class="st">&quot;Bob&quot;</span>,<span class="dv">100</span>),(<span class="st">&quot;Mike&quot;</span>,<span class="dv">50</span>)]</a>
<a class="sourceLine" id="cb273-6" data-line-number="6"><span class="dt">GHCi</span><span class="fu">&gt;</span> bank</a>
<a class="sourceLine" id="cb273-7" data-line-number="7">fromList [(<span class="st">&quot;Bob&quot;</span>,<span class="dv">100</span>),(<span class="st">&quot;Mike&quot;</span>,<span class="dv">50</span>)]</a></code></pre></div>
<p><code>Data.Map</code> defines all sorts of useful higher-order functions for updating maps. We can rewrite the <code>withdraw</code> function using <code>Data.Map.adjust</code>:</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb274-1" data-line-number="1"><span class="ot">withdraw ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb274-2" data-line-number="2">withdraw account amount bank <span class="fu">=</span> Map.adjust (\x <span class="ot">-&gt;</span> x<span class="fu">-</span>amount) account bank</a></code></pre></div>
<p><strong>Note!</strong> There are separate <code>Data.Map.Strict</code> and <code>Data.Map.Lazy</code> implementations. When you import <code>Data.Map</code> you get <code>Data.Map.Lazy</code>. You can find the documentation for all the <code>Data.Map</code> functions in <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Lazy.html">the docs for <code>Data.Map.Lazy</code></a>. We won’t go into their differences here, but mostly you shold use <code>Data.Map.Strict</code> in real code.</p>
<h3 id="data.array"><span class="header-section-number">4.7.2</span> <code>Data.Array</code></h3>
<p>Another type that works kind of like a list but is more efficient for some operations is the array. Arrays are familiar from many other programming languages, but Haskell arrays are a bit different.</p>
<p>Unlike the <code>Data.Map</code> module, the <code>Data.Array</code> can just be imported normally:</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb275-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Array</span></a></code></pre></div>
<p>Now we can look at the type of the <code>array</code> function that constructs an array.</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb276-1" data-line-number="1"><span class="ot">array ::</span> <span class="dt">Ix</span> i <span class="ot">=&gt;</span> (i, i) <span class="ot">-&gt;</span> [(i, e)] <span class="ot">-&gt;</span> <span class="dt">Array</span> i e</a></code></pre></div>
<p>There are a couple of things to notice here. First of all, the <code>Array</code> type is parameterized by <em>two</em> types: the index type and the element type. Most other programming languages only parameterize arrays with the element type, but the index type is always <code>int</code>. In Haskell, we can have, for example, an <code>Array Char Int</code>: an array indexed by characters, or <code>Array Bool String</code>, an array indexed by booleans, or even <code>Array (Int,Int) Int</code>, a two-dimensional array of ints.</p>
<p>Not all types can be index types. Only types that are similar to integers are suitable. That is the reason for the <code>Ix i</code> class constraint. The <code>Ix</code> class collects all the types that can be used as array indexes.</p>
<p>Secondly, the <code>array</code> function takes an extra <code>(i,i)</code> parameter. These are the minimun and maximum indexes of the array. Unlike some other languages, where arrays always start at index 0 or 1, in Haskell you can define an array that starts from 7 and goes to 11. So here’s that array:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb277-1" data-line-number="1"><span class="ot">myArray ::</span> <span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb277-2" data-line-number="2">myArray <span class="fu">=</span> array (<span class="dv">7</span>,<span class="dv">11</span>) [(<span class="dv">7</span>,<span class="st">&quot;seven&quot;</span>), (<span class="dv">8</span>,<span class="st">&quot;eight&quot;</span>), (<span class="dv">9</span>,<span class="st">&quot;nine&quot;</span>), (<span class="dv">10</span>,<span class="st">&quot;ten&quot;</span>), (<span class="dv">11</span>,<span class="st">&quot;ELEVEN&quot;</span>)]</a></code></pre></div>
<p>Listing all the indices and elements in order can be a bit cumbersome, so there’s also the <code>listArray</code> constructor that just takes a list of elements in order:</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb278-1" data-line-number="1"><span class="ot">listArray ::</span> <span class="dt">Ix</span> i <span class="ot">=&gt;</span> (i, i) <span class="ot">-&gt;</span> [e] <span class="ot">-&gt;</span> <span class="dt">Array</span> i e</a></code></pre></div>
<div class="sourceCode" id="cb279"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb279-1" data-line-number="1"><span class="ot">myArray ::</span> <span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb279-2" data-line-number="2">myArray <span class="fu">=</span> listArray (<span class="dv">7</span>,<span class="dv">11</span>) [<span class="st">&quot;seven&quot;</span>, <span class="st">&quot;eight&quot;</span>, <span class="st">&quot;nine&quot;</span>, <span class="st">&quot;ten&quot;</span>, <span class="st">&quot;ELEVEN&quot;</span>]</a></code></pre></div>
<p>Arrays are used with two new operators:</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb280-1" data-line-number="1"><span class="co">-- Array lookup</span></a>
<a class="sourceLine" id="cb280-2" data-line-number="2"><span class="ot">(!) ::</span> <span class="dt">Ix</span> i <span class="ot">=&gt;</span> <span class="dt">Array</span> i e <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> e</a>
<a class="sourceLine" id="cb280-3" data-line-number="3"><span class="co">-- Array update</span></a>
<a class="sourceLine" id="cb280-4" data-line-number="4"><span class="ot">(//) ::</span> <span class="dt">Ix</span> i <span class="ot">=&gt;</span> <span class="dt">Array</span> i e <span class="ot">-&gt;</span> [(i, e)] <span class="ot">-&gt;</span> <span class="dt">Array</span> i e</a></code></pre></div>
<p>Here’s an example <code>GHCi</code> session:</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb281-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Array</span></a>
<a class="sourceLine" id="cb281-2" data-line-number="2"><span class="dt">Prelude</span> <span class="dt">Data.Array</span><span class="fu">&gt;</span> <span class="kw">let</span> myArray <span class="fu">=</span> listArray (<span class="dv">7</span>,<span class="dv">11</span>) [<span class="st">&quot;seven&quot;</span>, <span class="st">&quot;eight&quot;</span>, <span class="st">&quot;nine&quot;</span>, <span class="st">&quot;ten&quot;</span>, <span class="st">&quot;ELEVEN&quot;</span>]</a>
<a class="sourceLine" id="cb281-3" data-line-number="3"><span class="dt">Prelude</span> <span class="dt">Data.Array</span><span class="fu">&gt;</span> myArray</a>
<a class="sourceLine" id="cb281-4" data-line-number="4">array (<span class="dv">7</span>,<span class="dv">11</span>) [(<span class="dv">7</span>,<span class="st">&quot;seven&quot;</span>),(<span class="dv">8</span>,<span class="st">&quot;eight&quot;</span>),(<span class="dv">9</span>,<span class="st">&quot;nine&quot;</span>),(<span class="dv">10</span>,<span class="st">&quot;ten&quot;</span>),(<span class="dv">11</span>,<span class="st">&quot;ELEVEN&quot;</span>)]</a>
<a class="sourceLine" id="cb281-5" data-line-number="5"><span class="dt">Prelude</span> <span class="dt">Data.Array</span><span class="fu">&gt;</span> myArray <span class="fu">!</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb281-6" data-line-number="6"><span class="st">&quot;eight&quot;</span></a>
<a class="sourceLine" id="cb281-7" data-line-number="7"><span class="dt">Prelude</span> <span class="dt">Data.Array</span><span class="fu">&gt;</span> myArray <span class="fu">//</span> [(<span class="dv">8</span>,<span class="st">&quot;ocho&quot;</span>),(<span class="dv">9</span>,<span class="st">&quot;nueve&quot;</span>)]</a>
<a class="sourceLine" id="cb281-8" data-line-number="8">array (<span class="dv">7</span>,<span class="dv">11</span>) [(<span class="dv">7</span>,<span class="st">&quot;seven&quot;</span>),(<span class="dv">8</span>,<span class="st">&quot;ocho&quot;</span>),(<span class="dv">9</span>,<span class="st">&quot;nueve&quot;</span>),(<span class="dv">10</span>,<span class="st">&quot;ten&quot;</span>),(<span class="dv">11</span>,<span class="st">&quot;ELEVEN&quot;</span>)]</a></code></pre></div>
<p>You might be wondering why the <code>(//)</code> operator does multiple updates at once. The reason is the main weakness of Haskell arrays: immutability. Since arrays can’t be changed in place, <code>(//)</code> must copy the whole array. This is why in Haskell it’s often preferable to use lists or maps to store data that needs to be updated. Arrays are still useful when you can construct then once and then do lots of lookups. We’ll get back to how Haskell data structures work in the next lecture.</p>
<p><strong>Note!</strong> In this course we’ll use only <code>Array</code>, a simple array type that’s specified in the Haskell standard. There are many other array types like the mutable <code>IOArray</code> and the somewhat obscure <code>DiffArray</code>. There are also type classes for arrays like <code>IArray</code> and <code>MArray</code>. In addition to arrays there is a <a href="https://hackage.haskell.org/package/vector">wide family of <code>Vector</code> types</a> that can be more practical than <code>Array</code> for real programs.</p>
<h3 id="sidenote-folding-over-maps-arrays"><span class="header-section-number">4.7.3</span> Sidenote: folding over Maps &amp; Arrays</h3>
<p>The <code>Map</code> and <code>Array</code> type are instances of <code>Foldable</code> just like lists are! This means you can use functions like <code>length</code> and <code>foldr</code> on them:</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb282-1" data-line-number="1">length (array (<span class="dv">7</span>,<span class="dv">11</span>) [(<span class="dv">7</span>,<span class="st">&quot;seven&quot;</span>),(<span class="dv">8</span>,<span class="st">&quot;eight&quot;</span>),(<span class="dv">9</span>,<span class="st">&quot;nine&quot;</span>),(<span class="dv">10</span>,<span class="st">&quot;ten&quot;</span>),(<span class="dv">11</span>,<span class="st">&quot;ELEVEN&quot;</span>)])</a>
<a class="sourceLine" id="cb282-2" data-line-number="2">  <span class="fu">==&gt;</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb282-3" data-line-number="3">foldr (<span class="fu">+</span>) <span class="dv">0</span> (Map.fromList [(<span class="st">&quot;banana&quot;</span>,<span class="dv">3</span>),(<span class="st">&quot;egg&quot;</span>,<span class="dv">7</span>)])</a>
<a class="sourceLine" id="cb282-4" data-line-number="4">  <span class="fu">==&gt;</span> <span class="dv">10</span></a></code></pre></div>
<h2 id="reading-docs"><span class="header-section-number">4.8</span> Reading docs</h2>
<p>Haskell libraries tend to have pretty good docs. We’ve linked to docs via Hackage (<a href="https://hackage.haskell.org" class="uri">https://hackage.haskell.org</a>) previously, but it’s important to know how to find the docs by your self too. The tool for generating Haskell documentation is called <em>Haddock</em> so sometimes Haskell docs are referred to as <em>haddocks</em>.</p>
<p>Hackage is the Haskell package repository (just like <a href="https://pypi.org/">PyPI</a> for Python, Maven Central for Java or <a href="https://npmjs.com">NPM</a> for Javascript). In addition to the actual packages, it hosts documentation for them. Most of the modules that we use on this course are in the package called <code>base</code>. You can browse the docs for the base package at <a href="http://hackage.haskell.org/package/base" class="uri">http://hackage.haskell.org/package/base</a>.</p>
<p>When you’re not quite sure where the function you’re looking for is, Hoogle (<a href="https://hoogle.haskell.org/" class="uri">https://hoogle.haskell.org/</a>) can help. Hoogle is a search engine for Haskell documentation. It is a great resource when you need to check what was the type of <code>foldr</code> or which packages contain a function named <code>reverse</code>.</p>
<p>Finally, since this course is using the <code>stack</code> tool, you can also browse the documentation for the libraries stack has installed for you with the commands</p>
<pre><code>stack haddock --open
stack haddock --open &lt;package&gt;</code></pre>
<p>This has the added benefit of getting exactly the right version of the documentation.</p>
<p>In summary, here are the main ways of reading Haskell library documentation: - If you know the name of the package you browse the docs via <a href="https://hackage.haskell.org/" class="uri">https://hackage.haskell.org/</a>. - If you know the name of the function you can find it using <a href="https://hoogle.haskell.org/" class="uri">https://hoogle.haskell.org/</a>. - If you’re using <code>stack</code> you can use <code>stack haddock --open</code> or <code>stack haddock --open &lt;package&gt;</code> to open docs in your browser.</p>
<h2 id="quiz-3"><span class="header-section-number">4.9</span> Quiz</h2>
<p>What is the type of <code>swap . swap</code>?</p>
<ol class="quiz">
<li class="correct">
<code>(a, b) -&gt; (a, b)</code>
</li>
<li>
<code>(a, b) -&gt; (b, a)</code>
</li>
<li>
<code>a -&gt; a</code>
</li>
</ol>
<p>What is the type of <code>\f g x -&gt; (f x, g x)</code>?</p>
<ol class="quiz">
<li>
<code>(a -&gt; b) -&gt; (c -&gt; d) -&gt; (a,c) -&gt; (b, d)</code>
</li>
<li class="correct">
<code>(a -&gt; b) -&gt; (a -&gt; c) -&gt; a -&gt; (b, c)</code>
</li>
<li>
<code>(a -&gt; b) -&gt; (b -&gt; a) -&gt; a -&gt; (b, a)</code>
</li>
</ol>
<p>What is the type of <code>\t -&gt; (fst . fst $ t, (snd . fst $ t, snd t))</code>?</p>
<ol class="quiz">
<li>
<code>(a, (b, c)) -&gt; (a, (b, c))</code>
</li>
<li>
<code>(a, (b, c)) -&gt; ((a, b), c)</code>
</li>
<li class="correct">
<code>((a, b), c) -&gt; (a, (b, c))</code>
</li>
</ol>
<p>What does the function <code>foldr (\x xs -&gt; xs ++ [x]) []</code> do?</p>
<ol class="quiz">
<li>
It doesn’t change its input list at all
</li>
<li>
It changes the associativity of a list from left to right
</li>
<li class="correct">
It reverses its input list
</li>
</ol>
<p>What does the function <code>foldr (\(x, y) zs -&gt; x : y : zs) []</code> do?</p>
<ol class="quiz">
<li>
It turns a list of pairs into a pair of lists
</li>
<li>
It turns a pair of lists into a list of pairs
</li>
<li class="correct">
It turns a list of pairs into a list of elements
</li>
</ol>
<p>What is the type of <code>foldr (\n b -&gt; n == 3 &amp;&amp; b)</code>?</p>
<ol class="quiz">
<li class="correct">
<code>(Foldable t, Eq a, Num a) =&gt; Bool -&gt; t a -&gt; Bool</code>
</li>
<li>
<code>(Foldable t, Eq a, Num a, Bool b) =&gt; b -&gt; t a -&gt; b</code>
</li>
<li>
<code>(Foldable t, Eq a, Num a) =&gt; Bool -&gt; [ a ] -&gt; Bool</code>
</li>
</ol>
<p>What is the type of <code>\x -&gt; case x of (True, &quot;Foo&quot;) -&gt; show True ++ &quot;Foo&quot;</code>?</p>
<ol class="quiz">
<li>
<code>Either Bool String -&gt; String</code>
</li>
<li class="correct">
<code>(Bool, String) -&gt; String</code>
</li>
<li>
<code>Show a =&gt; (Bool, String) -&gt; a</code>
</li>
</ol>
<!-- TODO more, maybe some Array and Map questions -->
<h2 id="exercises-3"><span class="header-section-number">4.10</span> Exercises</h2>
<ul>
<li><a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set4a.hs">Set4a</a>: type classes</li>
<li><a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set4b.hs">Set4b</a>: folds</li>
</ul>
<p>Remember to give <a href="https://forms.gle/YCo2jAaUTg9vER7G6">feedback</a>!</p>
<h1 id="lecture-5-you-need-string-for-a-knot"><span class="header-section-number">5</span> Lecture 5: You Need String for a Knot</h1>
<ul>
<li>Type system</li>
<li>Defining custom types</li>
</ul>
<h2 id="algebraic-datatypes"><span class="header-section-number">5.1</span> Algebraic Datatypes</h2>
<p>Haskell has a system called <em>algebraic datatypes</em> for defining new types. This sounds fancy, but is rather simple. Let’s dive in by looking at the standard library definitions of some familiar types:</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb284-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">True</span> <span class="fu">|</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb284-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Ordering</span> <span class="fu">=</span> <span class="dt">LT</span> <span class="fu">|</span> <span class="dt">EQ</span> <span class="fu">|</span> <span class="dt">GT</span></a></code></pre></div>
<p>With this syntax you too can define types:</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb285-1" data-line-number="1"><span class="co">-- definition of a type with three values</span></a>
<a class="sourceLine" id="cb285-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span> <span class="dt">Red</span> <span class="fu">|</span> <span class="dt">Green</span> <span class="fu">|</span> <span class="dt">Blue</span></a>
<a class="sourceLine" id="cb285-3" data-line-number="3"></a>
<a class="sourceLine" id="cb285-4" data-line-number="4"><span class="co">-- a function that uses pattern matching on our new type</span></a>
<a class="sourceLine" id="cb285-5" data-line-number="5"><span class="ot">rgb ::</span> <span class="dt">Color</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</a>
<a class="sourceLine" id="cb285-6" data-line-number="6">rgb <span class="dt">Red</span> <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb285-7" data-line-number="7">rgb <span class="dt">Green</span> <span class="fu">=</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb285-8" data-line-number="8">rgb <span class="dt">Blue</span> <span class="fu">=</span> [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]</a></code></pre></div>
<div class="sourceCode" id="cb286"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb286-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Red</span></a>
<a class="sourceLine" id="cb286-2" data-line-number="2"><span class="dt">Red</span><span class="ot"> ::</span> <span class="dt">Color</span></a>
<a class="sourceLine" id="cb286-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t [<span class="dt">Red</span>,<span class="dt">Blue</span>,<span class="dt">Green</span>]</a>
<a class="sourceLine" id="cb286-4" data-line-number="4">[<span class="dt">Red</span>,<span class="dt">Blue</span>,<span class="dt">Green</span>]<span class="ot"> ::</span> [<span class="dt">Color</span>]</a>
<a class="sourceLine" id="cb286-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> rgb <span class="dt">Red</span></a>
<a class="sourceLine" id="cb286-6" data-line-number="6">[<span class="fl">1.0</span>,<span class="fl">0.0</span>,<span class="fl">0.0</span>]</a></code></pre></div>
<h3 id="fields"><span class="header-section-number">5.1.1</span> Fields</h3>
<p>Types like <code>Bool</code>, <code>Ordering</code> and <code>Color</code> that just list a bunch of constants are called <em>enumerations</em> or <em>enums</em> in Haskell and other languages. Enums are useful, but you need other types as well. Here we define a type for reports containing an id number, a title, and a body:</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb287-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Report</span> <span class="fu">=</span> <span class="dt">ConstructReport</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="dt">String</span></a></code></pre></div>
<p>This is how you create a report:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb288-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">ConstructReport</span> <span class="dv">1</span> <span class="st">&quot;Title&quot;</span> <span class="st">&quot;This is the body.&quot;</span></a>
<a class="sourceLine" id="cb288-2" data-line-number="2"><span class="dt">ConstructReport</span> <span class="dv">1</span> <span class="st">&quot;Title&quot;</span> <span class="st">&quot;This is the body.&quot;</span><span class="ot"> ::</span> <span class="dt">Report</span></a></code></pre></div>
<p>You can access the fields with pattern matching:</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb289-1" data-line-number="1"><span class="ot">reportContents ::</span> <span class="dt">Report</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb289-2" data-line-number="2">reportContents (<span class="dt">ConstructReport</span> id title contents) <span class="fu">=</span> contents</a>
<a class="sourceLine" id="cb289-3" data-line-number="3"><span class="ot">setReportContents ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Report</span> <span class="ot">-&gt;</span> <span class="dt">Report</span></a>
<a class="sourceLine" id="cb289-4" data-line-number="4">setReportContents contents (<span class="dt">ConstructReport</span> id title _contents) <span class="fu">=</span> <span class="dt">ConstructReport</span> id title contents</a></code></pre></div>
<h3 id="constructors"><span class="header-section-number">5.1.2</span> Constructors</h3>
<p>The things on the right hand side of a <code>data</code> declaration are called <em>constructors</em>. <code>True</code>, <code>False</code>, <code>Red</code> and <code>ConstructReport</code> are all examples of constructors. A type can have multiple constructors, and a constructor can have zero or more fields.</p>
<p>Here is a datatype for a standard playing card. It has five constructors, of which <code>Joker</code> has zero fields and the others have one field.</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb290-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Card</span> <span class="fu">=</span> <span class="dt">Joker</span> <span class="fu">|</span> <span class="dt">Heart</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Club</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Spade</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Diamond</span> <span class="dt">Int</span></a></code></pre></div>
<p>Constructors with fields have function type and can be used wherever functions can:</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb291-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Heart</span></a>
<a class="sourceLine" id="cb291-2" data-line-number="2"><span class="dt">Heart</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Card</span></a>
<a class="sourceLine" id="cb291-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Club</span></a>
<a class="sourceLine" id="cb291-4" data-line-number="4"><span class="dt">Club</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Card</span></a>
<a class="sourceLine" id="cb291-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> map <span class="dt">Heart</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb291-6" data-line-number="6">[<span class="dt">Heart</span> <span class="dv">1</span>,<span class="dt">Heart</span> <span class="dv">2</span>,<span class="dt">Heart</span> <span class="dv">3</span>]</a>
<a class="sourceLine" id="cb291-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dt">Heart</span> <span class="fu">.</span> (\x <span class="ot">-&gt;</span> x<span class="fu">+</span><span class="dv">1</span>)) <span class="dv">3</span></a>
<a class="sourceLine" id="cb291-8" data-line-number="8"><span class="dt">Heart</span> <span class="dv">4</span></a></code></pre></div>
<h3 id="sidenote-deriving"><span class="header-section-number">5.1.3</span> Sidenote: deriving</h3>
<p>By the way, there’s something missing from our <code>Card</code> type. Look at how it behaves compared to <code>Ordering</code> and <code>Bool</code>:</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb292-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">EQ</span></a>
<a class="sourceLine" id="cb292-2" data-line-number="2"><span class="dt">EQ</span></a>
<a class="sourceLine" id="cb292-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb292-4" data-line-number="4"><span class="dt">True</span></a>
<a class="sourceLine" id="cb292-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Joker</span></a>
<a class="sourceLine" id="cb292-6" data-line-number="6"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">0</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb292-7" data-line-number="7">    <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Show</span> <span class="dt">Card</span>)</a>
<a class="sourceLine" id="cb292-8" data-line-number="8">      arising from a use <span class="kw">of</span> <span class="ot">`print&#39; at &lt;interactive&gt;:1:0-4</span></a>
<a class="sourceLine" id="cb292-9" data-line-number="9"><span class="ot">    Possible fix: add an instance declaration for (Show Card)</span></a>
<a class="sourceLine" id="cb292-10" data-line-number="10"><span class="ot">    In a stmt of a &#39;do&#39; expression: print it</span></a></code></pre></div>
<p>The problem is that Haskell does not know how to print the types we defined. As the error says, they are not part of the <code>Show</code> class. The easy solution is to just add a <code>deriving Show</code> after the type definition:</p>
<div class="sourceCode" id="cb293"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb293-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Card</span> <span class="fu">=</span> <span class="dt">Joker</span> <span class="fu">|</span> <span class="dt">Heart</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Club</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Spade</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Diamond</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb293-2" data-line-number="2">  <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<div class="sourceCode" id="cb294"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb294-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Joker</span></a>
<a class="sourceLine" id="cb294-2" data-line-number="2"><span class="dt">Joker</span></a></code></pre></div>
<p>The <code>deriving</code> syntax is a way to automatically make your class a member of certain basic type classes, most notably <code>Read</code>, <code>Show</code> and <code>Eq</code>. We’ll talk more about what this means later.</p>
<h3 id="algebraic"><span class="header-section-number">5.1.4</span> Algebraic?</h3>
<p>So why are these datatypes called algebraic? This is because, theoretically speaking, each datatype can be a <em>sum</em> of constructors, and each constructor is a <em>product</em> of fields. It makes sense to think of these as sums and products for many reasons, one being that we can count the possible values of each type this way:</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb295-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">True</span> <span class="fu">|</span> <span class="dt">False</span>            <span class="co">-- corresponds to 1+1. Has 2 possible values.</span></a>
<a class="sourceLine" id="cb295-2" data-line-number="2"><span class="kw">data</span> <span class="dt">TwoBools</span> <span class="fu">=</span> <span class="dt">TwoBools</span> <span class="dt">Bool</span> <span class="dt">Bool</span>  <span class="co">-- corresponds to Bool*Bool, i.e. 2*2. Has 4 possible values.</span></a>
<a class="sourceLine" id="cb295-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Complex</span> <span class="fu">=</span> <span class="dt">Two</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="fu">|</span> <span class="dt">One</span> <span class="dt">Bool</span> <span class="fu">|</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb295-4" data-line-number="4">                                    <span class="co">-- corresponds to Bool*Bool+Bool+1 = 2*2+2+1 = 7. Has 7 possible values.</span></a></code></pre></div>
<p>There is a rich theory of algebraic datatypes. If you’re interested, you might find more info <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">here</a> or <a href="https://www.cis.upenn.edu/~sweirich/papers/yorgey-thesis.pdf">here</a>.</p>
<h2 id="type-parameters"><span class="header-section-number">5.2</span> Type parameters</h2>
<p>We introduced type parameters and parametric polymorphism when introducing lists in Lecture 2. Since then, we’ve seen other parameterized types like <code>Maybe</code> and <code>Either</code>. Now we’ll learn how we can define our own parameterized types.</p>
<h3 id="defining-parameterized-types"><span class="header-section-number">5.2.1</span> Defining parameterized types</h3>
<p>The definition for <code>Maybe</code> is:</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb296-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a</a></code></pre></div>
<p>What’s <code>a</code>? We define a parameterized type by mentioning a <em>type variable</em> (<code>a</code> in this case) on the left side of the <code>=</code> sign. We can then use the same type variable in fields for our constructors. This is analogous to polymorphic functions. Instead of defining separate functions</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb297-1" data-line-number="1"><span class="ot">headInt ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb297-2" data-line-number="2"><span class="ot">headBool ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p>and so on, we define one function <code>head :: [a] -&gt; a</code> that works for all types <code>a</code>. Similarly, instead of defining multiple types</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb298-1" data-line-number="1"><span class="kw">data</span> <span class="dt">MaybeInt</span> <span class="fu">=</span> <span class="dt">NothingInt</span> <span class="fu">|</span> <span class="dt">JustInt</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb298-2" data-line-number="2"><span class="kw">data</span> <span class="dt">MaybeBool</span> <span class="fu">=</span> <span class="dt">NothingBool</span> <span class="fu">|</span> <span class="dt">JustBool</span> <span class="dt">Bool</span></a></code></pre></div>
<p>we define one type <code>Maybe a</code> that works for all types <code>a</code>.</p>
<p>Here’s our first own parameterized type <code>Described</code>. The values of type <code>Described a</code> contain a value of type <code>a</code> and a <code>String</code> description.</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb299-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Described</span> a <span class="fu">=</span> <span class="dt">Describe</span> a <span class="dt">String</span></a>
<a class="sourceLine" id="cb299-2" data-line-number="2"></a>
<a class="sourceLine" id="cb299-3" data-line-number="3"><span class="ot">getValue ::</span> <span class="dt">Described</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb299-4" data-line-number="4">getValue (<span class="dt">Describe</span> x _) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb299-5" data-line-number="5"></a>
<a class="sourceLine" id="cb299-6" data-line-number="6"><span class="ot">getDescription ::</span> <span class="dt">Described</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb299-7" data-line-number="7">getDescription (<span class="dt">Describe</span> _ desc) <span class="fu">=</span> desc</a></code></pre></div>
<div class="sourceCode" id="cb300"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb300-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Describe</span></a>
<a class="sourceLine" id="cb300-2" data-line-number="2"><span class="dt">Describe</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Described</span> a</a>
<a class="sourceLine" id="cb300-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Describe</span> <span class="dt">True</span> <span class="st">&quot;This is true&quot;</span></a>
<a class="sourceLine" id="cb300-4" data-line-number="4"><span class="dt">Describe</span> <span class="dt">True</span> <span class="st">&quot;This is true&quot;</span><span class="ot"> ::</span> <span class="dt">Described</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb300-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> getValue (<span class="dt">Describe</span> <span class="dv">3</span> <span class="st">&quot;a number&quot;</span>)</a>
<a class="sourceLine" id="cb300-6" data-line-number="6"><span class="dv">3</span></a>
<a class="sourceLine" id="cb300-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> getDescription (<span class="dt">Describe</span> <span class="dv">3</span> <span class="st">&quot;a number&quot;</span>)</a>
<a class="sourceLine" id="cb300-8" data-line-number="8"><span class="st">&quot;a number&quot;</span></a></code></pre></div>
<h3 id="syntactic-note"><span class="header-section-number">5.2.2</span> Syntactic note</h3>
<p>In the above definitions, we’ve used <code>a</code> as a type variable. However any word that starts with a lower case letter is fine. We could have defined <code>Maybe</code> like this:</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb301-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Maybe</span> theType <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> theType</a></code></pre></div>
<p>The rules for Haskell identifiers are:</p>
<ul>
<li>Type variables and names for functions and values start lower case (e.g. <code>a</code>, <code>map</code>, <code>xs</code>)</li>
<li>Type names and constructor names start with upper case (e.g. <code>Maybe</code>, <code>Just</code>, <code>Card</code>, <code>Heart</code>)</li>
</ul>
<p>Note that a type and its constructor can have the same name. This is very common in Haskell code for types that only have one constructor. In this material we try to avoid it to avoid confusion. Here are some examples:</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb302-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Pair</span> a <span class="fu">=</span> <span class="dt">Pair</span> a a</a>
<a class="sourceLine" id="cb302-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Report</span> <span class="fu">=</span> <span class="dt">Report</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="dt">String</span></a></code></pre></div>
<div class="sourceCode" id="cb303"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb303-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Pair</span></a>
<a class="sourceLine" id="cb303-2" data-line-number="2"><span class="dt">Pair</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Pair</span> a</a></code></pre></div>
<p>Beware of mixing up types and constructors. Luckily types and constructors can never occur in the same context, so you get a nice error:</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb304-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Maybe</span>                              <span class="co">-- trying to use a type name as a value</span></a>
<a class="sourceLine" id="cb304-2" data-line-number="2"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb304-3" data-line-number="3">    • <span class="dt">Data</span> constructor not <span class="kw">in</span> scope<span class="fu">:</span> <span class="dt">Maybe</span></a>
<a class="sourceLine" id="cb304-4" data-line-number="4"></a>
<a class="sourceLine" id="cb304-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span><span class="ot"> undefined ::</span> <span class="dt">Nothing</span>               <span class="co">-- trying to use a constructor as a type</span></a>
<a class="sourceLine" id="cb304-6" data-line-number="6"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">14</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb304-7" data-line-number="7">    <span class="dt">Not</span> <span class="kw">in</span> scope<span class="fu">:</span> <span class="kw">type</span> constructor or <span class="kw">class</span> ‘<span class="dt">Nothing</span>’</a></code></pre></div>
<h3 id="sidenote-multiple-type-parameters"><span class="header-section-number">5.2.3</span> Sidenote: multiple type parameters</h3>
<p>Types can have multiple type parameters. The syntax is similar to defining functions with many arguments. Here’s the definition of the standard <code>Either</code> type:</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb305-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Either</span> a b <span class="fu">=</span> <span class="dt">Left</span> a <span class="fu">|</span> <span class="dt">Right</span> b</a></code></pre></div>
<h2 id="recursive-types"><span class="header-section-number">5.3</span> Recursive types</h2>
<p>So far, all of the types we’ve defined have been of constant size. We can represent one report or one colour, but how could we represent a collection of things? We could use lists of course, but could we define a list type ourselves?</p>
<p>Just like Haskell functions, Haskell data types can be <em>recursive</em>. This is no weirder than having an object in Java or Python that refers to another object of the same class. This is how you define a list of integers:</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb306-1" data-line-number="1"><span class="kw">data</span> <span class="dt">IntList</span> <span class="fu">=</span> <span class="dt">Empty</span> <span class="fu">|</span> <span class="dt">Node</span> <span class="dt">Int</span> <span class="dt">IntList</span></a>
<a class="sourceLine" id="cb306-2" data-line-number="2">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb306-3" data-line-number="3"></a>
<a class="sourceLine" id="cb306-4" data-line-number="4"><span class="ot">ihead ::</span> <span class="dt">IntList</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb306-5" data-line-number="5">ihead (<span class="dt">Node</span> i _) <span class="fu">=</span> i</a>
<a class="sourceLine" id="cb306-6" data-line-number="6"></a>
<a class="sourceLine" id="cb306-7" data-line-number="7"><span class="ot">itail ::</span> <span class="dt">IntList</span> <span class="ot">-&gt;</span> <span class="dt">IntList</span></a>
<a class="sourceLine" id="cb306-8" data-line-number="8">itail (<span class="dt">Node</span> _ t) <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb306-9" data-line-number="9"></a>
<a class="sourceLine" id="cb306-10" data-line-number="10"><span class="ot">ilength ::</span> <span class="dt">IntList</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb306-11" data-line-number="11">ilength <span class="dt">Empty</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb306-12" data-line-number="12">ilength (<span class="dt">Node</span> _ t) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> ilength t</a></code></pre></div>
<p>We can use the functions defined above to work with lists of integers:</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb307-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> ihead (<span class="dt">Node</span> <span class="dv">3</span> (<span class="dt">Node</span> <span class="dv">5</span> (<span class="dt">Node</span> <span class="dv">4</span> <span class="dt">Empty</span>)))</a>
<a class="sourceLine" id="cb307-2" data-line-number="2"><span class="dv">3</span></a>
<a class="sourceLine" id="cb307-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> itail (<span class="dt">Node</span> <span class="dv">3</span> (<span class="dt">Node</span> <span class="dv">5</span> (<span class="dt">Node</span> <span class="dv">4</span> <span class="dt">Empty</span>)))</a>
<a class="sourceLine" id="cb307-4" data-line-number="4"><span class="dt">Node</span> <span class="dv">5</span> (<span class="dt">Node</span> <span class="dv">4</span> <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb307-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> ilength (<span class="dt">Node</span> <span class="dv">3</span> (<span class="dt">Node</span> <span class="dv">5</span> (<span class="dt">Node</span> <span class="dv">4</span> <span class="dt">Empty</span>)))</a>
<a class="sourceLine" id="cb307-6" data-line-number="6"><span class="dv">3</span></a></code></pre></div>
<p>Note that we can’t put values other than <code>Int</code>s inside our <code>IntList</code>:</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb308-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Node</span> <span class="dt">False</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb308-2" data-line-number="2"></a>
<a class="sourceLine" id="cb308-3" data-line-number="3"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">3</span><span class="fu">:</span><span class="dv">6</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb308-4" data-line-number="4">    • <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> ‘<span class="dt">Int</span>’ with actual <span class="kw">type</span> ‘<span class="dt">Bool</span>’</a>
<a class="sourceLine" id="cb308-5" data-line-number="5">    • <span class="dt">In</span> the first argument <span class="kw">of</span> ‘<span class="dt">Node</span>’, namely ‘<span class="dt">False</span>’</a>
<a class="sourceLine" id="cb308-6" data-line-number="6">      <span class="dt">In</span> the expression<span class="fu">:</span> <span class="dt">Node</span> <span class="dt">False</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb308-7" data-line-number="7">      <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> <span class="dt">Node</span> <span class="dt">False</span> <span class="dt">Empty</span></a></code></pre></div>
<p>To be able to put any type of element in our list, let’s do the same thing with a type parameter. This is the same as the built in type <code>[a]</code>, but with slightly clunkier syntax:</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb309-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Empty</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb309-2" data-line-number="2">  <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>Note how we need to pass the the type parameter <code>a</code> onwards in the recursion. We need to write <code>Node a (List a)</code> instead of <code>Node a List</code>. The <code>Node</code> constructor has two arguments. The first has type <code>a</code>, and the second has type <code>List a</code>. Here are the reimplementations of some standard list functions for our <code>List</code> type:</p>
<div class="sourceCode" id="cb310"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb310-1" data-line-number="1"><span class="ot">lhead ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb310-2" data-line-number="2">lhead (<span class="dt">Node</span> h _) <span class="fu">=</span> h</a>
<a class="sourceLine" id="cb310-3" data-line-number="3"></a>
<a class="sourceLine" id="cb310-4" data-line-number="4"><span class="ot">ltail ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb310-5" data-line-number="5">ltail (<span class="dt">Node</span> _ t) <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb310-6" data-line-number="6"></a>
<a class="sourceLine" id="cb310-7" data-line-number="7"><span class="ot">lnull ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb310-8" data-line-number="8">lnull <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb310-9" data-line-number="9">lnull _     <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb310-10" data-line-number="10"></a>
<a class="sourceLine" id="cb310-11" data-line-number="11"><span class="ot">llength ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb310-12" data-line-number="12">llength <span class="dt">Empty</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb310-13" data-line-number="13">llength (<span class="dt">Node</span> _ t) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> llength t</a></code></pre></div>
<div class="sourceCode" id="cb311"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb311-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> lhead (<span class="dt">Node</span> <span class="dt">True</span> <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb311-2" data-line-number="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb311-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> ltail (<span class="dt">Node</span> <span class="dt">True</span> (<span class="dt">Node</span> <span class="dt">False</span> <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb311-4" data-line-number="4"><span class="dt">Node</span> <span class="dt">False</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb311-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> lnull <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb311-6" data-line-number="6"><span class="dt">True</span></a></code></pre></div>
<p>Note that just like with normal Haskell lists, we can’t have elements of different types in the same list:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb312-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Node</span> <span class="dt">True</span> (<span class="dt">Node</span> <span class="st">&quot;foo&quot;</span> <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb312-2" data-line-number="2"></a>
<a class="sourceLine" id="cb312-3" data-line-number="3"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">5</span><span class="fu">:</span><span class="dv">12</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb312-4" data-line-number="4">    • <span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> ‘[<span class="dt">Char</span>]’ with ‘<span class="dt">Bool</span>’</a>
<a class="sourceLine" id="cb312-5" data-line-number="5">      <span class="dt">Expected</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">List</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb312-6" data-line-number="6">        <span class="dt">Actual</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">List</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb312-7" data-line-number="7">    • <span class="dt">In</span> the second argument <span class="kw">of</span> ‘<span class="dt">Node</span>’, namely ‘(<span class="dt">Node</span> <span class="st">&quot;foo&quot;</span> <span class="dt">Empty</span>)’</a>
<a class="sourceLine" id="cb312-8" data-line-number="8">      <span class="dt">In</span> the expression<span class="fu">:</span> <span class="dt">Node</span> <span class="dt">True</span> (<span class="dt">Node</span> <span class="st">&quot;foo&quot;</span> <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb312-9" data-line-number="9">      <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> <span class="dt">Node</span> <span class="dt">True</span> (<span class="dt">Node</span> <span class="st">&quot;foo&quot;</span> <span class="dt">Empty</span>)</a></code></pre></div>
<h3 id="example-growing-a-tree"><span class="header-section-number">5.3.1</span> Example: Growing a tree</h3>
<p>Just like a list, we can also represent a binary tree:</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb313-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a) <span class="fu">|</span> <span class="dt">Empty</span></a></code></pre></div>
<p>Our tree contains nodes, which contain a value of type <code>a</code> and two child trees, and empty trees.</p>
<p>In case you’re not familiar with binary trees, they’re a data structure that’s often used as the basis for other data structures (<code>Data.Map</code> is based on trees!). Binary trees are often drawn as (upside-down) pictures, like this:</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb314-1" data-line-number="1">     <span class="dv">0</span></a>
<a class="sourceLine" id="cb314-2" data-line-number="2">    <span class="fu">/</span> \</a>
<a class="sourceLine" id="cb314-3" data-line-number="3">   <span class="dv">1</span>   <span class="dv">4</span></a>
<a class="sourceLine" id="cb314-4" data-line-number="4">  <span class="fu">/</span> \</a>
<a class="sourceLine" id="cb314-5" data-line-number="5"> <span class="dv">2</span>   <span class="dv">3</span></a></code></pre></div>
<p>The highest node in the tree is called the <em>root</em> (<code>0</code> in this case), and the nodes with no children are called <code>leaves</code> (<code>2</code>, <code>3</code> and <code>4</code> in this case). We can define this tree using our <code>Tree</code> type like this:</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb315-1" data-line-number="1"><span class="ot">example ::</span> <span class="dt">Tree</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb315-2" data-line-number="2">example <span class="fu">=</span> (<span class="dt">Node</span> <span class="dv">0</span> (<span class="dt">Node</span> <span class="dv">1</span> (<span class="dt">Node</span> <span class="dv">2</span> <span class="dt">Empty</span> <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb315-3" data-line-number="3">                          (<span class="dt">Node</span> <span class="dv">3</span> <span class="dt">Empty</span> <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb315-4" data-line-number="4">                  (<span class="dt">Node</span> <span class="dv">4</span> <span class="dt">Empty</span> <span class="dt">Empty</span>))</a></code></pre></div>
<p>The height of a binary tree is length of the longest path from the root to a leaf. In Haskell terms, it’s how many nested levels of <code>Node</code> constructors you need to build the tree. The height of our example tree is 3. Here’s a function that computes the height of a tree:</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb316-1" data-line-number="1"><span class="ot">treeHeight ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb316-2" data-line-number="2">treeHeight <span class="dt">Empty</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb316-3" data-line-number="3">treeHeight (<span class="dt">Node</span> _ l r) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> max (treeHeight l) (treeHeight r)</a></code></pre></div>
<div class="sourceCode" id="cb317"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb317-1" data-line-number="1">treeHeight <span class="dt">Empty</span> <span class="fu">==&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb317-2" data-line-number="2">treeHeight (<span class="dt">Node</span> <span class="dv">2</span> <span class="dt">Empty</span> <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb317-3" data-line-number="3">  <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> max (treeHeight <span class="dt">Empty</span>) (treeHeight <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb317-4" data-line-number="4">  <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> max <span class="dv">0</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb317-5" data-line-number="5">  <span class="fu">==&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb317-6" data-line-number="6">treeHeight (<span class="dt">Node</span> <span class="dv">1</span> <span class="dt">Empty</span> (<span class="dt">Node</span> <span class="dv">2</span> <span class="dt">Empty</span> <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb317-7" data-line-number="7">  <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> max (treeHeight <span class="dt">Empty</span>) (treeHeight (<span class="dt">Node</span> <span class="dv">2</span> <span class="dt">Empty</span> <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb317-8" data-line-number="8">  <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> max <span class="dv">0</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb317-9" data-line-number="9">  <span class="fu">==&gt;</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb317-10" data-line-number="10">treeHeight (<span class="dt">Node</span> <span class="dv">0</span> (<span class="dt">Node</span> <span class="dv">1</span> <span class="dt">Empty</span> (<span class="dt">Node</span> <span class="dv">2</span> <span class="dt">Empty</span> <span class="dt">Empty</span>)) <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb317-11" data-line-number="11">  <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> max (treeHeight (<span class="dt">Node</span> <span class="dv">1</span> <span class="dt">Empty</span> (<span class="dt">Node</span> <span class="dv">2</span> <span class="dt">Empty</span> <span class="dt">Empty</span>))) (treeHeight <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb317-12" data-line-number="12">  <span class="fu">==&gt;</span> <span class="dv">1</span> <span class="fu">+</span> max <span class="dv">2</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb317-13" data-line-number="13">  <span class="fu">==&gt;</span> <span class="dv">3</span></a></code></pre></div>
<p>In case you’re familiar with <em>binary search trees</em>, here are the definitions of the lookup and insert opertions for a binary search tree. If you don’t know what I’m talking about, you don’t need to understand this.</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb318-1" data-line-number="1">lookup<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb318-2" data-line-number="2">lookup x <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb318-3" data-line-number="3">lookup x (<span class="dt">Node</span> y l r)</a>
<a class="sourceLine" id="cb318-4" data-line-number="4">  <span class="fu">|</span> x <span class="fu">&lt;</span> y <span class="fu">=</span> lookup x l</a>
<a class="sourceLine" id="cb318-5" data-line-number="5">  <span class="fu">|</span> x <span class="fu">&gt;</span> y <span class="fu">=</span> lookup x r</a>
<a class="sourceLine" id="cb318-6" data-line-number="6">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb318-7" data-line-number="7"></a>
<a class="sourceLine" id="cb318-8" data-line-number="8"><span class="ot">insert ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb318-9" data-line-number="9">insert x <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">Node</span> x <span class="dt">Empty</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb318-10" data-line-number="10">insert x (<span class="dt">Node</span> y l r)</a>
<a class="sourceLine" id="cb318-11" data-line-number="11">  <span class="fu">|</span> x <span class="fu">&lt;</span> y <span class="fu">=</span> <span class="dt">Node</span> y (insert x l) r</a>
<a class="sourceLine" id="cb318-12" data-line-number="12">  <span class="fu">|</span> x <span class="fu">&gt;</span> y <span class="fu">=</span> <span class="dt">Node</span> y l (insert x r)</a>
<a class="sourceLine" id="cb318-13" data-line-number="13">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> y l r</a></code></pre></div>
<h2 id="record-syntax"><span class="header-section-number">5.4</span> Record Syntax</h2>
<p>If some fields need to be accessed often, it can be convenient to have helper functions for reading those fields. For instance, the type <code>Person</code> might have multiple fields:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb319-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">MkPerson</span> <span class="dt">String</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span> <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>A list of persons might look like the following:</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb320-1" data-line-number="1"><span class="ot">people ::</span> [<span class="dt">Person</span>]</a>
<a class="sourceLine" id="cb320-2" data-line-number="2">people <span class="fu">=</span> [ <span class="dt">MkPerson</span> <span class="st">&quot;Jane Doe&quot;</span> <span class="dv">21</span> <span class="st">&quot;Houston&quot;</span> <span class="st">&quot;Texas&quot;</span> <span class="st">&quot;Engineer&quot;</span></a>
<a class="sourceLine" id="cb320-3" data-line-number="3">         , <span class="dt">MkPerson</span> <span class="st">&quot;Maija Meikäläinen&quot;</span> <span class="dv">35</span> <span class="st">&quot;Rovaniemi&quot;</span> <span class="st">&quot;Finland&quot;</span> <span class="st">&quot;Engineer&quot;</span></a>
<a class="sourceLine" id="cb320-4" data-line-number="4">         , <span class="dt">MkPerson</span> <span class="st">&quot;Mauno Mutikainen&quot;</span> <span class="dv">27</span> <span class="st">&quot;Turku&quot;</span> <span class="st">&quot;Finland&quot;</span> <span class="st">&quot;Mathematician&quot;</span></a>
<a class="sourceLine" id="cb320-5" data-line-number="5">         ]</a></code></pre></div>
<p>Suppose that we need to find all engineers from Finland:</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb321-1" data-line-number="1"><span class="ot">query ::</span> [<span class="dt">Person</span>] <span class="ot">-&gt;</span> [<span class="dt">Person</span>]</a>
<a class="sourceLine" id="cb321-2" data-line-number="2">query [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb321-3" data-line-number="3">query (<span class="dt">MkPerson</span> name age town state profession)<span class="fu">:</span>xs</a>
<a class="sourceLine" id="cb321-4" data-line-number="4">  <span class="fu">|</span> state <span class="fu">==</span> <span class="st">&quot;Finland&quot;</span> <span class="fu">&amp;&amp;</span> profession <span class="fu">==</span> <span class="st">&quot;Engineer&quot;</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb321-5" data-line-number="5">      (<span class="dt">MkPerson</span> name age town state profession) <span class="fu">:</span> query xs</a>
<a class="sourceLine" id="cb321-6" data-line-number="6">  <span class="fu">|</span> otherwise <span class="fu">=</span> query xs</a></code></pre></div>
<p>Thus,</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb322-1" data-line-number="1">query people <span class="fu">==&gt;</span> [<span class="dt">MkPerson</span> <span class="st">&quot;Maija Meikäläinen&quot;</span> <span class="dv">35</span> <span class="st">&quot;Rovaniemi&quot;</span> <span class="st">&quot;Finland&quot;</span> <span class="st">&quot;Engineer&quot;</span>]</a></code></pre></div>
<p>Note that the types of the fields give little information on what is the intended content in those fields. We need to remember in all places in the code that <code>town</code> goes before <code>state</code> and not vice versa.</p>
<p>Haskell has a feature called <em>record syntax</em> that is helpful in these kinds of cases. The datatype <code>Person</code> can be defined as a record:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb323-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">MkPerson</span> {<span class="ot"> name ::</span> <span class="dt">String</span>,<span class="ot"> age ::</span> <span class="dt">Int</span>,<span class="ot"> town ::</span> <span class="dt">String</span>,<span class="ot"> state ::</span> <span class="dt">String</span>,<span class="ot"> profession ::</span> <span class="dt">String</span>}</a>
<a class="sourceLine" id="cb323-2" data-line-number="2">  <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>We can still define values of <code>Person</code> normally, but the <code>Show</code> instance prints the field names for us:</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb324-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">MkPerson</span> <span class="st">&quot;Jane Doe&quot;</span> <span class="dv">21</span> <span class="st">&quot;Houston&quot;</span> <span class="st">&quot;Texas&quot;</span> <span class="st">&quot;Engineer&quot;</span></a>
<a class="sourceLine" id="cb324-2" data-line-number="2"><span class="dt">MkPerson</span> {name <span class="fu">=</span> <span class="st">&quot;Jane Doe&quot;</span>, age <span class="fu">=</span> <span class="dv">21</span>, town <span class="fu">=</span> <span class="st">&quot;Houston&quot;</span>, state <span class="fu">=</span> <span class="st">&quot;Texas&quot;</span>, profession <span class="fu">=</span> <span class="st">&quot;Engineer&quot;</span>}</a></code></pre></div>
<p>However, we can also define values using record syntax. Note how the fields don’t need to be in any specific order now that they have names.</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb325-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">MkPerson</span> {name <span class="fu">=</span> <span class="st">&quot;Jane Doe&quot;</span>, town <span class="fu">=</span> <span class="st">&quot;Houston&quot;</span>, profession <span class="fu">=</span> <span class="st">&quot;Engineer&quot;</span>, state <span class="fu">=</span> <span class="st">&quot;Texas&quot;</span>, age <span class="fu">=</span> <span class="dv">21</span>}</a>
<a class="sourceLine" id="cb325-2" data-line-number="2"><span class="dt">MkPerson</span> {name <span class="fu">=</span> <span class="st">&quot;Jane Doe&quot;</span>, age <span class="fu">=</span> <span class="dv">21</span>, town <span class="fu">=</span> <span class="st">&quot;Houston&quot;</span>, state <span class="fu">=</span> <span class="st">&quot;Texas&quot;</span>, profession <span class="fu">=</span> <span class="st">&quot;Engineer&quot;</span>}</a></code></pre></div>
<p>Most importantly, We get <em>accessor functions</em> for the fields for free:</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb326-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t profession</a>
<a class="sourceLine" id="cb326-2" data-line-number="2"><span class="ot">profession ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb326-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> profession (<span class="dt">MkPerson</span> <span class="st">&quot;Jane Doe&quot;</span> <span class="dv">21</span> <span class="st">&quot;Houston&quot;</span> <span class="st">&quot;Texas&quot;</span> <span class="st">&quot;Engineer&quot;</span>)</a>
<a class="sourceLine" id="cb326-4" data-line-number="4"><span class="st">&quot;Engineer&quot;</span></a></code></pre></div>
<p>We can now rewrite the query function using these accessor functions:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb327-1" data-line-number="1"><span class="ot">query ::</span> [<span class="dt">Person</span>] <span class="ot">-&gt;</span> [<span class="dt">Person</span>]</a>
<a class="sourceLine" id="cb327-2" data-line-number="2">query []     <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb327-3" data-line-number="3">query (x<span class="fu">:</span>xs)</a>
<a class="sourceLine" id="cb327-4" data-line-number="4">  <span class="fu">|</span> state x <span class="fu">==</span> <span class="st">&quot;Finland&quot;</span> <span class="fu">&amp;&amp;</span> profession x <span class="fu">==</span> <span class="st">&quot;Engineer&quot;</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb327-5" data-line-number="5">      x <span class="fu">:</span> query xs</a>
<a class="sourceLine" id="cb327-6" data-line-number="6">  <span class="fu">|</span> otherwise <span class="fu">=</span> query xs</a></code></pre></div>
<p>You’ll probably agree that the code looks more pleasant now.</p>
<h2 id="algebraic-datatypes-summary"><span class="header-section-number">5.5</span> Algebraic Datatypes: Summary</h2>
<ul>
<li>Types are defined like this</li>
</ul>
<div class="sourceCode" id="cb328"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb328-1" data-line-number="1"><span class="kw">data</span> <span class="dt">TypeName</span> <span class="fu">=</span> <span class="dt">ConstructorName</span> <span class="dt">FieldType</span> <span class="dt">FieldType2</span> <span class="fu">|</span> <span class="dt">AnotherConstructor</span> <span class="dt">FieldType3</span> <span class="fu">|</span> <span class="dt">OneMoreCons</span></a></code></pre></div>
<ul>
<li>… or like this if we’re using type variables</li>
</ul>
<div class="sourceCode" id="cb329"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb329-1" data-line-number="1"><span class="kw">data</span> <span class="dt">TypeName</span> variable <span class="fu">=</span> <span class="dt">Cons1</span> variable <span class="dt">Type1</span> <span class="fu">|</span> <span class="dt">Cons2</span> <span class="dt">Type2</span> variable</a></code></pre></div>
<ul>
<li>You can have one or more constructors</li>
<li>Each constructor can have zero or more fields</li>
<li>Constructors start with upper case, type variables with lower case</li>
<li>Values are handled with pattern matching:</li>
</ul>
<div class="sourceCode" id="cb330"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb330-1" data-line-number="1">foo (<span class="dt">ConstructorName</span> a b) <span class="fu">=</span> a<span class="fu">+</span>b</a>
<a class="sourceLine" id="cb330-2" data-line-number="2">foo (<span class="dt">AnotherConstructor</span> _) <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb330-3" data-line-number="3">foo <span class="dt">OneMoreCons</span> <span class="fu">=</span> <span class="dv">7</span></a></code></pre></div>
<ul>
<li>Constructors are just functions:</li>
</ul>
<div class="sourceCode" id="cb331"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb331-1" data-line-number="1"><span class="dt">ConstructorName</span><span class="ot"> ::</span> <span class="dt">FieldType</span> <span class="ot">-&gt;</span> <span class="dt">FieldType2</span> <span class="ot">-&gt;</span> <span class="dt">TypeName</span></a>
<a class="sourceLine" id="cb331-2" data-line-number="2"><span class="dt">Cons1</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Type1</span> <span class="ot">-&gt;</span> <span class="dt">TypeName</span> a</a></code></pre></div>
<ul>
<li>You can also define datatypes using record syntax:</li>
</ul>
<div class="sourceCode" id="cb332"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb332-1" data-line-number="1"><span class="kw">data</span> <span class="dt">TypeName</span> <span class="fu">=</span> <span class="dt">Constructor</span> {<span class="ot"> field1 ::</span> <span class="dt">Field1Type</span>,<span class="ot"> field2 ::</span> <span class="dt">Field2Type</span> }</a></code></pre></div>
<p>This gives you accessor functions like <code>field1 :: TypeName -&gt; Field1Type</code> for free.</p>
<h2 id="sidenote-other-ways-of-defining-types"><span class="header-section-number">5.6</span> Sidenote: other ways of defining types</h2>
<p>In addition to the <code>data</code> keyword, there are two additional ways of defining types in Haskell.</p>
<p>The <code>newtype</code> keyword works like <code>data</code>, but you can only have a single constructor with a single field. It’s sometimes wise to use <code>newtype</code> for performance resons, but we’ll get back to those in part 2.</p>
<p>The <code>type</code> keyword introduces a <em>type alias</em>. Type aliases don’t affect type checking, they just offer a shorthand for writing types. For example the familiar <code>String</code> type is an alias for <code>[Char]</code>:</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb333-1" data-line-number="1"><span class="kw">type</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>]</a></code></pre></div>
<p>This means that whenever the compiler reads <code>String</code>, it just immediately replaces it with <code>[Char]</code>. Type aliases seem useful, but they can easily make reading type errors harder.</p>
<h2 id="how-do-algebraic-datatypes-work"><span class="header-section-number">5.7</span> How do algebraic datatypes work?</h2>
<p>Remember how lists were represented in memory as linked lists? Let’s look in more detail at what algebraic datatypes look like in memory.</p>
<p>Haskell data forms <em>directed graphs</em> in memory. Every constructor is a node, every field is an edge. Names (of variables) are pointers into this graph. Different names can <em>share</em> parts of the structure. Here’s an example with lists. Note how the last two elements of <code>x</code> are shared with <code>y</code> and <code>z</code>.</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb334-1" data-line-number="1">     code                       memory</a>
<a class="sourceLine" id="cb334-2" data-line-number="2">                          x               y</a>
<a class="sourceLine" id="cb334-3" data-line-number="3">                          <span class="fu">|</span>               <span class="fu">|</span></a>
<a class="sourceLine" id="cb334-4" data-line-number="4">                          v               v</a>
<a class="sourceLine" id="cb334-5" data-line-number="5"><span class="kw">let</span> x <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]        (<span class="dv">1</span><span class="fu">:</span>) <span class="ot">-&gt;</span> (<span class="dv">2</span><span class="fu">:</span>) <span class="ot">-&gt;</span> (<span class="dv">3</span><span class="fu">:</span>) <span class="ot">-&gt;</span> (<span class="dv">4</span><span class="fu">:</span>) <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb334-6" data-line-number="6">    y <span class="fu">=</span> drop <span class="dv">2</span> x                          <span class="fu">^</span></a>
<a class="sourceLine" id="cb334-7" data-line-number="7">    z <span class="fu">=</span> <span class="dv">5</span><span class="fu">:</span>y                               <span class="fu">|</span></a>
<a class="sourceLine" id="cb334-8" data-line-number="8">                              z <span class="ot">-&gt;</span> (<span class="dv">5</span><span class="fu">:</span>) <span class="fu">--+</span></a></code></pre></div>
<p>What happens when you make a new version of a datastructure is called <em>path copying</em>. Since Haskell data is immutable, the changed parts of the datastructure get copied, while the unchanged parts can be shared between the old and new versions.</p>
<p>Consider the definition of <code>++</code>:</p>
<div class="sourceCode" id="cb335"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb335-1" data-line-number="1">[]     <span class="fu">++</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb335-2" data-line-number="2">(x<span class="fu">:</span>xs) <span class="fu">++</span> ys <span class="fu">=</span> x<span class="fu">:</span>(xs <span class="fu">++</span> ys)</a></code></pre></div>
<p>We are making a copy of the first argument while we walk it. For every <code>:</code> constructor in the first input list, we are creating a new <code>:</code> constructor in the output list. The second argument can be shared. It is not used at all in the recursion. Visually:</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb336-1" data-line-number="1">      xs <span class="ot">-&gt;</span> (<span class="dv">1</span><span class="fu">:</span>) <span class="ot">-&gt;</span> (<span class="dv">2</span><span class="fu">:</span>) <span class="ot">-&gt;</span> (<span class="dv">3</span><span class="fu">:</span>) <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb336-2" data-line-number="2"></a>
<a class="sourceLine" id="cb336-3" data-line-number="3">                            ys <span class="ot">-&gt;</span> (<span class="dv">5</span><span class="fu">:</span>) <span class="ot">-&gt;</span> (<span class="dv">6</span><span class="fu">:</span>) <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb336-4" data-line-number="4">                                   <span class="fu">^</span></a>
<a class="sourceLine" id="cb336-5" data-line-number="5">                                   <span class="fu">|</span></a>
<a class="sourceLine" id="cb336-6" data-line-number="6">xs <span class="fu">++</span> ys <span class="ot">-&gt;</span> (<span class="dv">1</span><span class="fu">:</span>) <span class="ot">-&gt;</span> (<span class="dv">2</span><span class="fu">:</span>) <span class="ot">-&gt;</span> (<span class="dv">3</span><span class="fu">:</span>) <span class="fu">--+</span></a></code></pre></div>
<p>One more way to think about it is this: we want to change the <code>tail</code> pointer of the list element <code>(3:)</code>. That means we need to make a new <code>(3:)</code>. However the <code>(2:)</code> points to the <code>(3:)</code> so we need a new copy of the <code>(2:)</code> as well. Likewise for <code>(1:)</code>.</p>
<p>The graphs that we get when working with lists are fairly simple. As a more involved example, here is what happens in memory when we run the binary tree insertion example from earlier in this lecture.</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb337-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb337-2" data-line-number="2">insert x <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">Node</span> x <span class="dt">Empty</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb337-3" data-line-number="3">insert x (<span class="dt">Node</span> y l r)</a>
<a class="sourceLine" id="cb337-4" data-line-number="4">  <span class="fu">|</span> x <span class="fu">&lt;</span> y <span class="fu">=</span> <span class="dt">Node</span> y (insert x l) r</a>
<a class="sourceLine" id="cb337-5" data-line-number="5">  <span class="fu">|</span> x <span class="fu">&gt;</span> y <span class="fu">=</span> <span class="dt">Node</span> y l (insert x r)</a>
<a class="sourceLine" id="cb337-6" data-line-number="6">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> y l r</a></code></pre></div>
<div class="sourceCode" id="cb338"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb338-1" data-line-number="1">            t              insert <span class="dv">6</span> t</a>
<a class="sourceLine" id="cb338-2" data-line-number="2">            <span class="fu">|</span>                  <span class="fu">|</span></a>
<a class="sourceLine" id="cb338-3" data-line-number="3">          <span class="dt">Node</span> <span class="dv">5</span>            <span class="dt">Node</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb338-4" data-line-number="4">         <span class="fu">/</span>______\__________<span class="fu">/</span>      \</a>
<a class="sourceLine" id="cb338-5" data-line-number="5">        <span class="fu">//</span>       \                 \</a>
<a class="sourceLine" id="cb338-6" data-line-number="6">   <span class="dt">Node</span> <span class="dv">3</span>        <span class="dt">Node</span> <span class="dv">7</span>            <span class="dt">Node</span> <span class="dv">7</span></a>
<a class="sourceLine" id="cb338-7" data-line-number="7">  <span class="fu">/</span>      \      <span class="fu">/</span>      \          <span class="fu">/</span>      \</a>
<a class="sourceLine" id="cb338-8" data-line-number="8"><span class="dt">Empty</span>  <span class="dt">Node</span> <span class="dv">4</span>  <span class="dt">Empty</span>  <span class="dt">Empty</span>    <span class="dt">Node</span> <span class="dv">6</span>    <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb338-9" data-line-number="9">       <span class="fu">/</span>    \                 <span class="fu">/</span>     \</a>
<a class="sourceLine" id="cb338-10" data-line-number="10">   <span class="dt">Empty</span>   <span class="dt">Empty</span>           <span class="dt">Empty</span>   <span class="dt">Empty</span></a></code></pre></div>
<p>Note how the old and the new tree share the subtree with 3 and 4 since it wasn’t changed, but the node 7 that was “changed” and all nodes above it get copied.</p>
<h2 id="quiz-4"><span class="header-section-number">5.8</span> Quiz</h2>
<p>Why can’t we <code>map Nothing</code>?</p>
<ol class="quiz">
<li class="correct">
Because <code>Nothing</code> doesn’t take arguments
</li>
<li>
Because <code>Nothing</code> returns nothing
</li>
<li>
Because <code>Nothing</code> is a constructor.
</li>
</ol>
<p>If we define <code>data Boing = Frick String Boing (Int -&gt; Bool)</code>, what is the type of <code>Frick</code>?</p>
<ol class="quiz">
<li>
<code>Boing</code>
</li>
<li>
<code>String -&gt; Boing -&gt; Int -&gt; Bool -&gt; Boing</code>
</li>
<li class="correct">
<code>String -&gt; Boing -&gt; (Int -&gt; Bool) -&gt; Boing</code>
</li>
</ol>
<p>If we define <code>data ThreeLists a b c = ThreeLists [a] [b] [c]</code>, what is the type of the constructor <code>ThreeLists</code>?</p>
<ol class="quiz">
<li>
<code>[a] -&gt; [b] -&gt; [c] -&gt; ThreeLists</code>
</li>
<li>
<code>a -&gt; b -&gt; c -&gt; ThreeLists a b c</code>
</li>
<li class="correct">
<code>[a] -&gt; [b] -&gt; [c] -&gt; ThreeLists a b c</code>
</li>
<li>
<code>[a] -&gt; [b] -&gt; [c] -&gt; ThreeLists [a] [b] [c]</code>
</li>
</ol>
<p>If we define <code>data TwoLists a b = TwoList {aList :: [a], bList :: [b]}</code>, what is the type of the function <code>aList</code>?</p>
<ol class="quiz">
<li>
<code>aList</code> is not a function, it is a field
</li>
<li class="correct">
<code>TwoLists a b -&gt; [a]</code>
</li>
<li>
<code>[a] -&gt; TwoLists a b</code>
</li>
<li>
<code>[a]</code>
</li>
</ol>
<h2 id="exercises-4"><span class="header-section-number">5.9</span> Exercises</h2>
<ul>
<li><a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set5a.hs">Set5a</a>: using and defining algebraic datatypes</li>
<li><a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set5b.hs">Set5b</a>: playing with binary trees</li>
</ul>
<p>Remember to give <a href="https://forms.gle/YCo2jAaUTg9vER7G6">feedback</a>!</p>
<h1 id="lecture-6-working-class-hero"><span class="header-section-number">6</span> Lecture 6: Working Class Hero</h1>
<p>We’ve seen class constraints like <code>Eq a =&gt;</code> in types. We know how to use existing classes with existing types. But how do we use existing classes with our own types? How can we define our own classes?</p>
<p>Here’s how to make your own type a member of the <code>Eq</code> class:</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb339-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span> <span class="dt">Black</span> <span class="fu">|</span> <span class="dt">White</span></a>
<a class="sourceLine" id="cb339-2" data-line-number="2"></a>
<a class="sourceLine" id="cb339-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Color</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb339-4" data-line-number="4">  <span class="dt">Black</span> <span class="fu">==</span> <span class="dt">Black</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb339-5" data-line-number="5">  <span class="dt">White</span> <span class="fu">==</span> <span class="dt">White</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb339-6" data-line-number="6">  _     <span class="fu">==</span> _      <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>A class instance is an <code>instance</code> block that contains definitions for the functions in that class. Here we define how <code>==</code> works on <code>Color</code>.</p>
<h2 id="the-syntax-of-classes-and-instances"><span class="header-section-number">6.1</span> The syntax of classes and instances</h2>
<p>A type class is defined using <code>class</code> syntax. The functions in the class are given types. Here’s a class <code>Size</code> that contains one function, <code>size</code>:</p>
<div class="sourceCode" id="cb340"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb340-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Size</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb340-2" data-line-number="2"><span class="ot">  size ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>Instances of a class are defined with <code>instance</code> syntax we’ve just seen. Here is how we make <code>Int</code> and <code>[a]</code> members of the <code>Size</code> class:</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb341-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Size</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb341-2" data-line-number="2">  size x <span class="fu">=</span> abs x</a>
<a class="sourceLine" id="cb341-3" data-line-number="3"></a>
<a class="sourceLine" id="cb341-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Size</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb341-5" data-line-number="5">  size xs <span class="fu">=</span> length xs</a></code></pre></div>
<p>Our class <code>Size</code> behaves just like existing type classes. We can use <code>size</code> anywhere where a function can be used, and Haskell can infer types with <code>Size</code> constraints for us:</p>
<div class="sourceCode" id="cb342"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb342-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t size</a>
<a class="sourceLine" id="cb342-2" data-line-number="2"><span class="ot">size ::</span> <span class="dt">Size</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb342-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> size [<span class="dt">True</span>,<span class="dt">False</span>]</a>
<a class="sourceLine" id="cb342-4" data-line-number="4"><span class="dv">2</span></a>
<a class="sourceLine" id="cb342-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> sizeBoth a b <span class="fu">=</span> [size a, size b]</a>
<a class="sourceLine" id="cb342-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t sizeBoth</a>
<a class="sourceLine" id="cb342-7" data-line-number="7"><span class="ot">sizeBoth ::</span> (<span class="dt">Size</span> a1, <span class="dt">Size</span> a2) <span class="ot">=&gt;</span> a1 <span class="ot">-&gt;</span> a2 <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a></code></pre></div>
<p>A class can contain multiple functions, and even constants. Here we define a new version of the <code>Size</code> class with more content.</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb343-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Size</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb343-2" data-line-number="2"><span class="ot">  empty ::</span> a</a>
<a class="sourceLine" id="cb343-3" data-line-number="3"><span class="ot">  size ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb343-4" data-line-number="4"><span class="ot">  sameSize ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb343-5" data-line-number="5"></a>
<a class="sourceLine" id="cb343-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Size</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb343-7" data-line-number="7">  empty <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb343-8" data-line-number="8"></a>
<a class="sourceLine" id="cb343-9" data-line-number="9">  size <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb343-10" data-line-number="10">  size (<span class="dt">Just</span> a) <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb343-11" data-line-number="11"></a>
<a class="sourceLine" id="cb343-12" data-line-number="12">  sameSize x y <span class="fu">=</span> size x <span class="fu">==</span> size y</a>
<a class="sourceLine" id="cb343-13" data-line-number="13"></a>
<a class="sourceLine" id="cb343-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">Size</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb343-15" data-line-number="15">  empty <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb343-16" data-line-number="16">  size xs <span class="fu">=</span> length xs</a>
<a class="sourceLine" id="cb343-17" data-line-number="17">  sameSize x y <span class="fu">=</span> size x <span class="fu">==</span> size y</a></code></pre></div>
<h2 id="sidenote-restrictions-on-instances"><span class="header-section-number">6.2</span> Sidenote: restrictions on instances</h2>
<p>The Haskell 2010 allows only a very specific type of class instance. Let’s look at some instances that aren’t allowed. The examples use the <code>Size</code> class:</p>
<div class="sourceCode" id="cb344"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb344-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Size</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb344-2" data-line-number="2"><span class="ot">  size ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>We saw a <code>Size [a]</code> instance above. Why not define an instance just for lists of booleans?</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb345-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Size</span> [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb345-2" data-line-number="2">  size bs <span class="fu">=</span> length (filter id bs)   <span class="co">-- count Trues</span></a></code></pre></div>
<pre class="haskel"><code>error:
    • Illegal instance declaration for ‘Size [Bool]’
        (All instance types must be of the form (T a1 ... an)
         where a1 ... an are *distinct type variables*,
         and each type variable appears at most once in the instance head.
         Use FlexibleInstances if you want to disable this.)
    • In the instance declaration for ‘Size [Bool]’</code></pre>
<p>Dang. As the error tries to tell us, we can only define instances where all type parameters are <em>different</em> type variables. That is, we can define <code>instance Size (Either a b)</code> but we can’t define:</p>
<ul>
<li><code>instance Size (Either String a)</code> – since <code>String</code> is not a type variable</li>
<li><code>instance Size (Either a a)</code> – since the type variables aren’t different</li>
<li><code>instance Size [[a]]</code> – since <code>[a]</code> is not a type variable</li>
</ul>
<p>Why is this? This rule guarantees that it’s simple for the compiler to look up the correct type class instance. It can just look at what the <em>top-level type constructor</em> is, and then pick an instance.</p>
<p>The GHC Haskell implementation has many extensions to the type class system – we’ll get back to some of them in part 2 of this course.</p>
<h2 id="default-implementations"><span class="header-section-number">6.3</span> Default implementations</h2>
<p>Did you notice how in the previous example we gave <code>sameSize</code> the same definition in both instances? This is a very common occurrence, and it’s why Haskell classes can have <em>default implementations</em>. As a first example, here’s an <code>Example</code> type class for giving example values of types.</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb347-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Example</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb347-2" data-line-number="2"><span class="ot">  example ::</span> a           <span class="co">-- the main example for the type `a`</span></a>
<a class="sourceLine" id="cb347-3" data-line-number="3"><span class="ot">  examples ::</span> [a]        <span class="co">-- a short list of examples</span></a>
<a class="sourceLine" id="cb347-4" data-line-number="4">  examples <span class="fu">=</span> [example]   <span class="co">-- ...defaulting to just the main example</span></a>
<a class="sourceLine" id="cb347-5" data-line-number="5"></a>
<a class="sourceLine" id="cb347-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Example</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb347-7" data-line-number="7">  example <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb347-8" data-line-number="8">  examples <span class="fu">=</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb347-9" data-line-number="9"></a>
<a class="sourceLine" id="cb347-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Example</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb347-11" data-line-number="11">  example <span class="fu">=</span> <span class="dt">True</span></a></code></pre></div>
<p>Here’s how <code>Example</code> works. Note how the default implementation of <code>examples</code> got used in the <code>Bool</code> case but not in the <code>Int</code> case. Also note the need for explicit type signatures to tell GHCi which instance we’re interested in. Without them, we would get an “Ambiguous type variable” error.</p>
<div class="sourceCode" id="cb348"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb348-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span><span class="ot"> example ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb348-2" data-line-number="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb348-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span><span class="ot"> example ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb348-4" data-line-number="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb348-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span><span class="ot"> examples ::</span> [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb348-6" data-line-number="6">[<span class="dt">True</span>]</a>
<a class="sourceLine" id="cb348-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span><span class="ot"> examples ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb348-8" data-line-number="8">[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>]</a></code></pre></div>
<p>The standard type classes use lots of default implementations to make implementing the classes easy. Here is the standard definitions for <code>Eq</code> (formatted for readability).</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb349-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb349-2" data-line-number="2"><span class="ot">  (==) ::</span>  a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb349-3" data-line-number="3">  x <span class="fu">==</span> y  <span class="fu">=</span> not (x <span class="fu">/=</span> y)</a>
<a class="sourceLine" id="cb349-4" data-line-number="4"></a>
<a class="sourceLine" id="cb349-5" data-line-number="5"><span class="ot">  (/=) ::</span>  a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb349-6" data-line-number="6">  x <span class="fu">/=</span> y  <span class="fu">=</span> not (x <span class="fu">==</span> y)</a></code></pre></div>
<p>Note how both operations have a default implementation in terms of the other. This means we could define an <code>Eq</code> instance with no content at all, but the resulting functions would just recurse forever. In practice, we want to define at least one of <code>==</code> and <code>/=</code>.</p>
<p>When there are lots of default implementations, it can be hard to know which functions you need to implement yourself. For this reason class documentation usually mentions the <em>minimal complete definition</em>. For <code>Eq</code>, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Eq">the docs say</a> “Minimal complete definition: either == or /=.”</p>
<p>Let’s look at <code>Ord</code> next. <code>Ord</code> has 7 operations, all with default implementations in terms of each other. By the way, note the quirky way of defining multiple type signatures at once. It’s okay, it’s a feature of Haskell, this is how <code>Ord</code> is defined in <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1270006.3">the standard</a>. (We’ll get back to what the <code>(Eq a) =&gt;</code> part means soon.)</p>
<div class="sourceCode" id="cb350"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb350-1" data-line-number="1"><span class="kw">class</span>  (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Ord</span> a  <span class="kw">where</span></a>
<a class="sourceLine" id="cb350-2" data-line-number="2"><span class="ot">  compare              ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></a>
<a class="sourceLine" id="cb350-3" data-line-number="3">  (<span class="fu">&lt;</span>), (<span class="fu">&lt;=</span>), (<span class="fu">&gt;=</span>),<span class="ot"> (&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb350-4" data-line-number="4">  max,<span class="ot"> min             ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb350-5" data-line-number="5"></a>
<a class="sourceLine" id="cb350-6" data-line-number="6">  compare x y <span class="fu">|</span> x <span class="fu">==</span> y    <span class="fu">=</span> <span class="dt">EQ</span></a>
<a class="sourceLine" id="cb350-7" data-line-number="7">              <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">LT</span></a>
<a class="sourceLine" id="cb350-8" data-line-number="8">              <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">GT</span></a>
<a class="sourceLine" id="cb350-9" data-line-number="9"></a>
<a class="sourceLine" id="cb350-10" data-line-number="10">  x <span class="fu">&lt;=</span> y  <span class="fu">=</span> compare x y <span class="fu">/=</span> <span class="dt">GT</span></a>
<a class="sourceLine" id="cb350-11" data-line-number="11">  x <span class="fu">&lt;</span>  y  <span class="fu">=</span> compare x y <span class="fu">==</span> <span class="dt">LT</span></a>
<a class="sourceLine" id="cb350-12" data-line-number="12">  x <span class="fu">&gt;=</span> y  <span class="fu">=</span> compare x y <span class="fu">/=</span> <span class="dt">LT</span></a>
<a class="sourceLine" id="cb350-13" data-line-number="13">  x <span class="fu">&gt;</span>  y  <span class="fu">=</span> compare x y <span class="fu">==</span> <span class="dt">GT</span></a>
<a class="sourceLine" id="cb350-14" data-line-number="14"></a>
<a class="sourceLine" id="cb350-15" data-line-number="15">  max x y <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span>  y</a>
<a class="sourceLine" id="cb350-16" data-line-number="16">          <span class="fu">|</span> otherwise <span class="fu">=</span>  x</a>
<a class="sourceLine" id="cb350-17" data-line-number="17">  min x y <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span>  x</a>
<a class="sourceLine" id="cb350-18" data-line-number="18">          <span class="fu">|</span> otherwise <span class="fu">=</span>  y</a></code></pre></div>
<p>With this definition it’s really hard to know what the minimal complete definition is. Luckily the <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Ord">docs tell us</a> “Minimal complete definition: either compare or &lt;=.”</p>
<p>As a final word on default implementations, if there is never a need to override the default definition, the function can be moved out of the class for simplicity. Consider a class like <code>Combine</code> below:</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb351-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Combine</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb351-2" data-line-number="2"><span class="ot">  combine ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb351-3" data-line-number="3"><span class="ot">  combine3 ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb351-4" data-line-number="4">  combine3 x y z <span class="fu">=</span> combine x (combine y z)</a></code></pre></div>
<p>It’s hard to think of a case where <code>combine3</code> would be given any other definition, so why not move it out of the class:</p>
<div class="sourceCode" id="cb352"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb352-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Combine</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb352-2" data-line-number="2"><span class="ot">  combine ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb352-3" data-line-number="3"></a>
<a class="sourceLine" id="cb352-4" data-line-number="4"><span class="ot">combine3 ::</span> <span class="dt">Combine</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb352-5" data-line-number="5">combine3 x y z <span class="fu">=</span> combine x (combine y z)</a></code></pre></div>
<h3 id="example-the-pair-type"><span class="header-section-number">6.3.1</span> Example: the Pair type</h3>
<p>Here are the <code>Eq</code> and <code>Ord</code> instances for a simple pair type. Note how the definition uses the minimal complete definition rules by only defining <code>==</code> and <code>&lt;=</code>.</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb353-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Pair</span> a <span class="fu">=</span> <span class="dt">MakePair</span> a a</a>
<a class="sourceLine" id="cb353-2" data-line-number="2">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb353-3" data-line-number="3"></a>
<a class="sourceLine" id="cb353-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Pair</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb353-5" data-line-number="5">  <span class="dt">MakePair</span> a b <span class="fu">==</span> <span class="dt">MakePair</span> c d  <span class="fu">=</span> a<span class="fu">==</span>c <span class="fu">&amp;&amp;</span> b<span class="fu">==</span>d</a>
<a class="sourceLine" id="cb353-6" data-line-number="6"></a>
<a class="sourceLine" id="cb353-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Ord</span> (<span class="dt">Pair</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb353-8" data-line-number="8">  <span class="dt">MakePair</span> a b <span class="fu">&lt;=</span> <span class="dt">MakePair</span> c d</a>
<a class="sourceLine" id="cb353-9" data-line-number="9">     <span class="fu">|</span> a<span class="fu">&lt;</span>c       <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb353-10" data-line-number="10">     <span class="fu">|</span> a<span class="fu">&gt;</span>c       <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb353-11" data-line-number="11">     <span class="fu">|</span> otherwise <span class="fu">=</span> b<span class="fu">&lt;=</span>d</a></code></pre></div>
<div class="sourceCode" id="cb354"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb354-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> (<span class="dt">MakePair</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="fu">&lt;</span> (<span class="dt">MakePair</span> <span class="dv">2</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb354-2" data-line-number="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb354-3" data-line-number="3"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> (<span class="dt">MakePair</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="fu">&gt;</span> (<span class="dt">MakePair</span> <span class="dv">2</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb354-4" data-line-number="4"><span class="dt">False</span></a>
<a class="sourceLine" id="cb354-5" data-line-number="5"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> compare (<span class="dt">MakePair</span> <span class="dv">1</span> <span class="dv">2</span>) (<span class="dt">MakePair</span> <span class="dv">2</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb354-6" data-line-number="6"><span class="dt">LT</span></a></code></pre></div>
<h2 id="useful-stuff"><span class="header-section-number">6.4</span> Useful stuff</h2>
<h3 id="deriving"><span class="header-section-number">6.4.1</span> Deriving</h3>
<p>As we’ve seen many times already, <code>deriving</code> is a way to get automatically generated class instances. The <code>Read</code> and <code>Show</code> classes should pretty much always be derived to get the standard behaviour. The derived instance for <code>Eq</code> is typically what you want. It requires constructors and fields to match.</p>
<p>The derived <code>Ord</code> instance might not be what you want. It orders constructors left-to-right, and then compares fields inside constructors left-to-right. An example:</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb355-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Dead</span> <span class="fu">|</span> <span class="dt">Alive</span> <span class="dt">String</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb355-2" data-line-number="2">  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<div class="sourceCode" id="cb356"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb356-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Dead</span> <span class="fu">&lt;</span> <span class="dt">Alive</span> <span class="st">&quot;Bob&quot;</span> <span class="dv">35</span>                   <span class="co">-- constructors are ordered left-to-right</span></a>
<a class="sourceLine" id="cb356-2" data-line-number="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb356-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Alive</span> <span class="st">&quot;Barbara&quot;</span> <span class="dv">35</span> <span class="fu">&lt;</span> <span class="dt">Alive</span> <span class="st">&quot;Clive&quot;</span> <span class="dv">17</span>   <span class="co">-- names are compared before ages</span></a>
<a class="sourceLine" id="cb356-4" data-line-number="4"><span class="dt">True</span></a>
<a class="sourceLine" id="cb356-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Alive</span> <span class="st">&quot;Clive&quot;</span> <span class="dv">17</span> <span class="fu">&lt;</span> <span class="dt">Alive</span> <span class="st">&quot;Clive&quot;</span> <span class="dv">30</span>     <span class="co">-- finally, ages are compared if names match</span></a>
<a class="sourceLine" id="cb356-6" data-line-number="6"><span class="dt">True</span></a></code></pre></div>
<h3 id="asking-ghci-about-classes"><span class="header-section-number">6.4.2</span> Asking GHCi about classes</h3>
<p>You can use the <code>:info</code> command in GHCi to get the contents and instances of a class. These days the info even includes the minimal complete definition (see the MINIMAL pragma). For example:</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb357-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">Num</span></a>
<a class="sourceLine" id="cb357-2" data-line-number="2"><span class="kw">class</span> <span class="dt">Num</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb357-3" data-line-number="3"><span class="ot">  (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb357-4" data-line-number="4"><span class="ot">  (-) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb357-5" data-line-number="5"><span class="ot">  (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb357-6" data-line-number="6"><span class="ot">  negate ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb357-7" data-line-number="7"><span class="ot">  abs ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb357-8" data-line-number="8"><span class="ot">  signum ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb357-9" data-line-number="9"><span class="ot">  fromInteger ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb357-10" data-line-number="10">  <span class="ot">{-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}</span></a>
<a class="sourceLine" id="cb357-11" data-line-number="11">    <span class="co">-- Defined in ‘GHC.Num’</span></a>
<a class="sourceLine" id="cb357-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Word</span> <span class="co">-- Defined in ‘GHC.Num’</span></a>
<a class="sourceLine" id="cb357-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Integer</span> <span class="co">-- Defined in ‘GHC.Num’</span></a>
<a class="sourceLine" id="cb357-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Int</span> <span class="co">-- Defined in ‘GHC.Num’</span></a>
<a class="sourceLine" id="cb357-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Float</span> <span class="co">-- Defined in ‘GHC.Float’</span></a>
<a class="sourceLine" id="cb357-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Double</span> <span class="co">-- Defined in ‘GHC.Float’</span></a></code></pre></div>
<h2 id="hierarchies"><span class="header-section-number">6.5</span> Hierarchies</h2>
<p>Both classes and instances can form <em>hierarchies</em>. This means that a class or instance depends on another class or instance.</p>
<p>Let’s start with a simple type class and instance</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb358-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Check</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb358-2" data-line-number="2"><span class="ot">  check ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb358-3" data-line-number="3"></a>
<a class="sourceLine" id="cb358-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Check</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb358-5" data-line-number="5">  check x <span class="fu">=</span> x <span class="fu">&gt;</span> <span class="dv">0</span></a></code></pre></div>
<p>Now we can write a function that checks a list:</p>
<div class="sourceCode" id="cb359"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb359-1" data-line-number="1"><span class="ot">checkAll ::</span> <span class="dt">Check</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb359-2" data-line-number="2">checkAll <span class="fu">=</span> and (map check xs)</a></code></pre></div>
<p>In order to turn this into a <code>Check [a]</code> instance, we need to add a constraint to the instance declaration. Our <code>Check [a]</code> is based on the <code>Check a</code> instance.</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb360-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Check</span> a <span class="ot">=&gt;</span> <span class="dt">Check</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb360-2" data-line-number="2">  check xs <span class="fu">=</span> and (map check xs)</a></code></pre></div>
<p>This means that our <code>Check [a]</code> instance is only valid when there is a corresponding <code>Check a</code> instance. For example, if we try to invoke a <code>Check [Bool]</code> instance, we get an error about the missing <code>Check Bool</code> instance:</p>
<div class="sourceCode" id="cb361"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb361-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> check [<span class="dt">True</span>,<span class="dt">False</span>]</a>
<a class="sourceLine" id="cb361-2" data-line-number="2"></a>
<a class="sourceLine" id="cb361-3" data-line-number="3"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb361-4" data-line-number="4">    • <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Check</span> <span class="dt">Bool</span>) arising from a use <span class="kw">of</span> ‘check’</a>
<a class="sourceLine" id="cb361-5" data-line-number="5">    • <span class="dt">In</span> the expression<span class="fu">:</span> check [<span class="dt">True</span>, <span class="dt">False</span>]</a>
<a class="sourceLine" id="cb361-6" data-line-number="6">      <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> check [<span class="dt">True</span>, <span class="dt">False</span>]</a></code></pre></div>
<p>Also, if we try to define <code>Check [a]</code> instance without the constraint, we get an error (with a pretty good suggestion!)</p>
<pre><code>    • No instance for (Check a) arising from a use of ‘check’
      Possible fix:
        add (Check a) to the context of the instance declaration</code></pre>
<p>If you think about it, this instance hierarchy allows us to circumvent the limitation that we can’t make a <code>Check [Int]</code> instance.</p>
<p>Respectively, a class can depend on another class. This is useful for instance when you want to use functions from another class in your default implementations:</p>
<div class="sourceCode" id="cb363"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb363-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Size</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb363-2" data-line-number="2"><span class="ot">  size ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb363-3" data-line-number="3"></a>
<a class="sourceLine" id="cb363-4" data-line-number="4"><span class="kw">class</span> <span class="dt">Size</span> a <span class="ot">=&gt;</span> <span class="dt">SizeBoth</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb363-5" data-line-number="5"><span class="ot">  sizeBoth ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb363-6" data-line-number="6">  sizeBoth x y <span class="fu">=</span> size x <span class="fu">+</span> size y</a></code></pre></div>
<p>In cases like this we say <code>SizeBoth</code> is a <em>subclass</em> of <code>Size</code>. Note again the confusion with object oriented programming. Examples of subclasses in the standard library include:</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb364-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Ord</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb364-2" data-line-number="2">  <span class="fu">...</span></a>
<a class="sourceLine" id="cb364-3" data-line-number="3"><span class="kw">class</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb364-4" data-line-number="4">  <span class="fu">...</span></a></code></pre></div>
<p>Another way to look at subclasses is that if you have a <code>class Sub a =&gt; Main a</code>, you must provide an <code>instance Sub MyType</code> in order to be able to declare <code>instance Main MyType</code>.</p>
<h2 id="quiz-5"><span class="header-section-number">6.6</span> Quiz</h2>
<p>What are the functions in the <code>Eq</code> class?</p>
<ol class="quiz">
<li class="correct">
<code>(==), (/=)</code>
</li>
<li>
<code>(==)</code>
</li>
<li>
<code>(==)</code>, <code>(&lt;)</code>, <code>(&gt;)</code>
</li>
</ol>
<p>For which of the following classes can we get automatic instances with <code>deriving</code>?</p>
<ol class="quiz">
<li>
<code>Num</code>
</li>
<li class="correct">
<code>Ord</code>
</li>
<li>
<code>Size</code>
</li>
</ol>
<p>Which of the following instance declarations is legal?</p>
<ol class="quiz">
<li>
<code>instance Eq Maybe</code>
</li>
<li>
<code>instance Eq (a,a)</code>
</li>
<li>
<code>instance Eq (Maybe Int)</code>
</li>
<li class="correct">
<code>instance Eq (a,b)</code>
</li>
</ol>
<p>Given the following definition of the class <code>BitOperations</code></p>
<div class="sourceCode" id="cb365"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb365-1" data-line-number="1"><span class="kw">class</span> <span class="dt">BitOperations</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb365-2" data-line-number="2"><span class="ot">  bitNot ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb365-3" data-line-number="3">  bitNot x <span class="fu">=</span> bitNand bitTrue x</a>
<a class="sourceLine" id="cb365-4" data-line-number="4"><span class="ot">  bitAnd ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb365-5" data-line-number="5">  bitAnd x y <span class="fu">=</span> bitNot (bitOr (bitNot x) (bitNot y))</a>
<a class="sourceLine" id="cb365-6" data-line-number="6"><span class="ot">  bitOr ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb365-7" data-line-number="7">  bitOr x y <span class="fu">=</span> bitNot (bitAnd (bitNot x) (bitNot y))</a>
<a class="sourceLine" id="cb365-8" data-line-number="8"><span class="ot">  bitNand ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb365-9" data-line-number="9">  bitNand x y <span class="fu">=</span> bitNot (bitAnd x y)</a></code></pre></div>
<p>which set of operations is <em>not</em> a minimal complete definition of <code>BitOperations</code>?</p>
<ol class="quiz">
<li>
<code>bitNand, bitAnd</code>
</li>
<li class="correct">
<code>bitAnd, bitOr</code>
</li>
<li>
<code>bitAnd, bitNot</code>
</li>
<li>
<code>bitNot, bitOr</code>
</li>
</ol>
<p>The declaration <code>instance Num a =&gt; Eq (Pair a)</code> tells me that</p>
<ol class="quiz">
<li>
All instances of <code>Num</code> are instances of <code>Eq</code>
</li>
<li class="correct">
<code>Pair a</code> is an instance of <code>Eq</code> if <code>a</code> is an instance of <code>Num</code>
</li>
<li>
The instance <code>Eq (Pair a)</code> inherits the instance <code>Num a</code>
</li>
</ol>
<p>The declaration <code>class Num a =&gt; Fractional a</code> tells me that</p>
<ol class="quiz">
<li class="correct">
All instances of <code>Fractional</code> must be instances of <code>Num</code>
</li>
<li>
All instances of <code>Num</code> must be instances of <code>Fractional</code>
</li>
<li>
If I define an instance for <code>Fractional</code>, I also get an instance for <code>Num</code>
</li>
<li>
If I define an instance for <code>Num</code>, I also get an instance for <code>Fractional</code>
</li>
</ol>
<h2 id="exercises-5"><span class="header-section-number">6.7</span> Exercises</h2>
<ul>
<li><a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set6.hs">Set6</a>: defining classes and instances</li>
</ul>
<p>Remember to give <a href="https://forms.gle/YCo2jAaUTg9vER7G6">feedback</a>!</p>
<h1 id="lecture-7-new-constellations"><span class="header-section-number">7</span> Lecture 7: New Constellations</h1>
<p>This lecture offers an introduction to <em>design patterns</em> for <em>typed functional programming</em>. These patterns are both useful when writing Haskell programs, and offer a nice arena for practicing skills from the previous lectures.</p>
<h2 id="modeling-with-boxes"><span class="header-section-number">7.1</span> Modeling with boxes</h2>
<p>Sometimes you don’t need a new type, but instead can just reuse a standard type. For example, repesenting car register plate numbers with <code>String</code>. However, if your code is full of <code>String</code>s, it can be easy to accidentally mix up e.g. a car’s model and registration in a function like <code>registerCar :: String -&gt; String -&gt; CarRegistry -&gt; CarRegistry</code>.</p>
<p>For situations like this it’s common to create a new type that just contains a <code>String</code> (a “boxed” string):</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb366-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Plate</span> <span class="fu">=</span> <span class="dt">Plate</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb366-2" data-line-number="2">  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>We can now give <code>registerCar</code> a slightly nicer type, <code>String -&gt; Plate -&gt; CarRegistry -&gt; CarRegistry</code>. Additionally, we can restrict the operations that are possible on <code>Plate</code>s to a subset of those that are possible on strings. For example, there is no need to combine the register plate numbers of two cars. Thus we don’t need to offer a function <code>concatPlates :: Plate -&gt; Plate -&gt; Plate</code>. We can also define a <em>smart constructor</em> for <code>Plate</code> that checks that the register number is in the correct format:</p>
<div class="sourceCode" id="cb367"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb367-1" data-line-number="1"><span class="ot">parsePlate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Plate</span></a>
<a class="sourceLine" id="cb367-2" data-line-number="2">parsePlate string</a>
<a class="sourceLine" id="cb367-3" data-line-number="3">  <span class="fu">|</span> correctPlateNumber string  <span class="fu">=</span>  <span class="dt">Just</span> (<span class="dt">Plate</span> string)</a>
<a class="sourceLine" id="cb367-4" data-line-number="4">  <span class="fu">|</span> otherwise                  <span class="fu">=</span>  <span class="dt">Nothing</span></a></code></pre></div>
<p>Here’s another example: representing money. If we just store money as <code>Int</code>s, the compiler won’t protect us from mistakes like multiplying money with money. If instead we implement our own <code>Money</code> type that wraps <code>Int</code>, we get type safety. Additionally, we can encapsulate the fact that money is represented as an integer amount of cents.</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb368-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Money</span> <span class="fu">=</span> <span class="dt">Money</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb368-2" data-line-number="2">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb368-3" data-line-number="3"></a>
<a class="sourceLine" id="cb368-4" data-line-number="4"><span class="ot">renderMoney ::</span> <span class="dt">Money</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb368-5" data-line-number="5">renderMoney (<span class="dt">Money</span> cents) <span class="fu">=</span> show (fromIntegral cents <span class="fu">/</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb368-6" data-line-number="6"></a>
<a class="sourceLine" id="cb368-7" data-line-number="7"><span class="ot">(+!) ::</span> <span class="dt">Money</span> <span class="ot">-&gt;</span> <span class="dt">Money</span> <span class="ot">-&gt;</span> <span class="dt">Money</span></a>
<a class="sourceLine" id="cb368-8" data-line-number="8">(<span class="dt">Money</span> a) <span class="fu">+!</span> (<span class="dt">Money</span> b) <span class="fu">=</span> <span class="dt">Money</span> (a<span class="fu">+</span>b)</a>
<a class="sourceLine" id="cb368-9" data-line-number="9"></a>
<a class="sourceLine" id="cb368-10" data-line-number="10"><span class="ot">scale ::</span> <span class="dt">Money</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Money</span></a>
<a class="sourceLine" id="cb368-11" data-line-number="11">scale (<span class="dt">Money</span> a) x <span class="fu">=</span> <span class="dt">Money</span> (round (fromIntegral a <span class="fu">*</span> x))</a>
<a class="sourceLine" id="cb368-12" data-line-number="12"></a>
<a class="sourceLine" id="cb368-13" data-line-number="13"><span class="ot">addVat ::</span> <span class="dt">Money</span> <span class="ot">-&gt;</span> <span class="dt">Money</span></a>
<a class="sourceLine" id="cb368-14" data-line-number="14">addVat m <span class="fu">=</span> m <span class="fu">+!</span> scale m <span class="fl">0.24</span></a></code></pre></div>
<div class="sourceCode" id="cb369"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb369-1" data-line-number="1">renderMoney (<span class="dt">Money</span> <span class="dv">100</span> <span class="fu">+!</span> <span class="dt">Money</span> <span class="dv">150</span>)</a>
<a class="sourceLine" id="cb369-2" data-line-number="2">  <span class="fu">==&gt;</span> <span class="st">&quot;2.5&quot;</span></a>
<a class="sourceLine" id="cb369-3" data-line-number="3"></a>
<a class="sourceLine" id="cb369-4" data-line-number="4">scale (<span class="dt">Money</span> <span class="dv">299</span>) <span class="fl">0.24</span></a>
<a class="sourceLine" id="cb369-5" data-line-number="5">  <span class="fu">==&gt;</span> <span class="dt">Money</span> <span class="dv">72</span></a>
<a class="sourceLine" id="cb369-6" data-line-number="6"></a>
<a class="sourceLine" id="cb369-7" data-line-number="7">addVat (<span class="dt">Money</span> <span class="dv">299</span>)</a>
<a class="sourceLine" id="cb369-8" data-line-number="8">  <span class="fu">==&gt;</span> <span class="dt">Money</span> <span class="dv">371</span></a></code></pre></div>
<h2 id="modeling-with-cases"><span class="header-section-number">7.2</span> Modeling with cases</h2>
<p>Haskell’s algebraic datatypes are really powerful at modeling things based on <em>cases</em>. It’s often useful to think of types as defining the set of possible cases, and functions <em>handling</em> those cases (often via pattern matching). Let’s look at two examples.</p>
<p>Since it’s so easy to define custom types in Haskell, it’s quite convenient to use more descriptive types instead of booleans or strings. Consider a list of persons. In some other language if you wanted to sort the persons into ascending order by name you might use a call like <code>sortPersons(persons, &quot;name&quot;, true)</code>. In Haskell you can do this instead:</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb370-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> {<span class="ot">name ::</span> <span class="dt">String</span>,<span class="ot"> age ::</span> <span class="dt">Int</span>}</a>
<a class="sourceLine" id="cb370-2" data-line-number="2">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb370-3" data-line-number="3"></a>
<a class="sourceLine" id="cb370-4" data-line-number="4"><span class="kw">data</span> <span class="dt">SortOrder</span> <span class="fu">=</span> <span class="dt">Ascending</span> <span class="fu">|</span> <span class="dt">Descending</span></a>
<a class="sourceLine" id="cb370-5" data-line-number="5"><span class="kw">data</span> <span class="dt">SortField</span> <span class="fu">=</span> <span class="dt">Name</span> <span class="fu">|</span> <span class="dt">Age</span></a>
<a class="sourceLine" id="cb370-6" data-line-number="6"></a>
<a class="sourceLine" id="cb370-7" data-line-number="7"><span class="ot">sortByField ::</span> <span class="dt">SortField</span> <span class="ot">-&gt;</span> [<span class="dt">Person</span>] <span class="ot">-&gt;</span> [<span class="dt">Person</span>]</a>
<a class="sourceLine" id="cb370-8" data-line-number="8">sortByField <span class="dt">Name</span> ps <span class="fu">=</span> sortBy (comparing name) ps</a>
<a class="sourceLine" id="cb370-9" data-line-number="9">sortByField <span class="dt">Age</span> ps <span class="fu">=</span> sortBy (comparing age) ps</a>
<a class="sourceLine" id="cb370-10" data-line-number="10"></a>
<a class="sourceLine" id="cb370-11" data-line-number="11"><span class="ot">sortPersons ::</span> <span class="dt">SortField</span> <span class="ot">-&gt;</span> <span class="dt">SortOrder</span> <span class="ot">-&gt;</span> [<span class="dt">Person</span>] <span class="ot">-&gt;</span> [<span class="dt">Person</span>]</a>
<a class="sourceLine" id="cb370-12" data-line-number="12">sortPersons field <span class="dt">Ascending</span> ps <span class="fu">=</span> sortByField field ps</a>
<a class="sourceLine" id="cb370-13" data-line-number="13">sortPersons field <span class="dt">Descending</span> ps <span class="fu">=</span> reverse (sortByField field ps)</a>
<a class="sourceLine" id="cb370-14" data-line-number="14"></a>
<a class="sourceLine" id="cb370-15" data-line-number="15">persons <span class="fu">=</span> [<span class="dt">Person</span> <span class="st">&quot;Fridolf&quot;</span> <span class="dv">73</span>, <span class="dt">Person</span> <span class="st">&quot;Greta&quot;</span> <span class="dv">60</span>, <span class="dt">Person</span> <span class="st">&quot;Hans&quot;</span> <span class="dv">65</span>]</a></code></pre></div>
<div class="sourceCode" id="cb371"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb371-1" data-line-number="1">sortPersons <span class="dt">Name</span> <span class="dt">Ascending</span> persons</a>
<a class="sourceLine" id="cb371-2" data-line-number="2">  <span class="fu">==&gt;</span> [<span class="dt">Person</span> {name <span class="fu">=</span> <span class="st">&quot;Fridolf&quot;</span>, age <span class="fu">=</span> <span class="dv">73</span>},<span class="dt">Person</span> {name <span class="fu">=</span> <span class="st">&quot;Greta&quot;</span>, age <span class="fu">=</span> <span class="dv">60</span>},<span class="dt">Person</span> {name <span class="fu">=</span> <span class="st">&quot;Hans&quot;</span>, age <span class="fu">=</span> <span class="dv">65</span>}]</a>
<a class="sourceLine" id="cb371-3" data-line-number="3">sortPersons <span class="dt">Age</span> <span class="dt">Descending</span> persons</a>
<a class="sourceLine" id="cb371-4" data-line-number="4">  <span class="fu">==&gt;</span> [<span class="dt">Person</span> {name <span class="fu">=</span> <span class="st">&quot;Fridolf&quot;</span>, age <span class="fu">=</span> <span class="dv">73</span>},<span class="dt">Person</span> {name <span class="fu">=</span> <span class="st">&quot;Hans&quot;</span>, age <span class="fu">=</span> <span class="dv">65</span>},<span class="dt">Person</span> {name <span class="fu">=</span> <span class="st">&quot;Greta&quot;</span>, age <span class="fu">=</span> <span class="dv">60</span>}]</a></code></pre></div>
<p>Note how you can’t accidentally typo the field name (unlike with strings), and how you don’t need to remember whether <code>true</code> refers to ascending or descending order.</p>
<p>Let’s move on to the next example. Many Haskell functions don’t work with empty lists (consider <code>head []</code>). If you’re writing code that needs to track whether lists are possibly empty or guaranteed to not be empty, you can use the <code>NonEmpty</code> type from the <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List-NonEmpty.html">Data.List.NonEmpty</a> module.</p>
<p>Consider the definition of <code>NonEmpty</code>:</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb372-1" data-line-number="1"><span class="kw">data</span> <span class="dt">NonEmpty</span> a <span class="fu">=</span> a <span class="fu">:|</span> [a]</a></code></pre></div>
<p>Here the type represents a <em>lack of</em> cases. The type <code>NonEmpty a</code> will always consist of a value of type <code>a</code>, and some further <code>a</code>s, collected in a list. Here are some example values of <code>NonEmpty Int</code>:</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb373-1" data-line-number="1"><span class="dv">1</span> <span class="fu">:|</span> [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb373-2" data-line-number="2"><span class="dv">1</span> <span class="fu">:|</span> []</a></code></pre></div>
<p>By the way, this is also an example of an <em>infix constructor</em>. We’ve already met another infix constructor earlier, the list constructor <code>(:)</code>. Any operator that begins with a colon (the <code>:</code> character) can be used as an infix constructor. We can pattern match on <code>(:|)</code> just like on <code>(:)</code>, as you’ll see in the examples below.</p>
<p>Here are the functions that convert between normal lists and nonempty lists. Note how we can’t have a function <code>[a] -&gt; NonEmpty a</code>, but must instead use <code>Maybe</code> to represent the possibility that the list was, indeed, empty. Note also how <code>toList</code> has only one equation, we can’t have a <code>toList []</code> situation due to the type <code>NonEmpty</code>.</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb374-1" data-line-number="1"><span class="ot">nonEmpty ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">NonEmpty</span> a)</a>
<a class="sourceLine" id="cb374-2" data-line-number="2">nonEmpty [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb374-3" data-line-number="3">nonEmpty (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> (x <span class="fu">:|</span> xs)</a>
<a class="sourceLine" id="cb374-4" data-line-number="4"></a>
<a class="sourceLine" id="cb374-5" data-line-number="5"><span class="ot">toList ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb374-6" data-line-number="6">toList (x <span class="fu">:|</span> xs) <span class="fu">=</span> x <span class="fu">:</span> xs</a></code></pre></div>
<p>In summary, if you write types that represent all possible cases for your values, and then write functions that handle those cases, your code will be simple and correct.</p>
<h2 id="monoids"><span class="header-section-number">7.3</span> Monoids</h2>
<!-- TODO: move to the end of the lecture? -->
<h3 id="what"><span class="header-section-number">7.3.1</span> What?</h3>
<p>A simple but useful abstraction that Haskell libraries use is that of the <em>monoid</em>. (Not to be confused with a <em>monad</em>!) In Haskell terms, <code>Monoid</code> is a type class that contains the function <code>&lt;&gt;</code> and the constant <code>mempty</code>.</p>
<p>The <code>&lt;&gt;</code> operation is meant to be <em>associative</em> that is, <code>x &lt;&gt; (y &lt;&gt; z) == (x &lt;&gt; y) &lt;&gt; z</code>. Familiar examples of associative operations include <code>+</code>, <code>*</code>, <code>++</code>, <code>max</code>, etc.</p>
<p>The <code>mempty</code> constant is meant to be a <em>neutral element</em> of the <code>&lt;&gt;</code> operation. This means that <code>mempty &lt;&gt; x == x</code> and <code>x &lt;&gt; mempty == x</code>. The neutral elements of <code>+</code>, <code>*</code> and <code>++</code> are 0, 1 and <code>[]</code>, respectively.</p>
<p>As we can guess at this point, there is a <code>Monoid [a]</code> instance that has <code>(&lt;&gt;) = (++)</code> and <code>mempty = []</code>:</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb375-1" data-line-number="1">[<span class="dv">1</span>,<span class="dv">2</span>] <span class="fu">&lt;&gt;</span> [<span class="dv">3</span>] <span class="fu">&lt;&gt;</span> mempty <span class="fu">&lt;&gt;</span> [<span class="dv">4</span>]  <span class="fu">==&gt;</span>  [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a></code></pre></div>
<p>For a type like <code>Int</code>, it would be hard to pick a single instance <code>Monoid Int</code> since there are so many candidates for <code>&lt;&gt;</code>: at least <code>+</code>, <code>*</code>, <code>max</code> and <code>min</code>. That’s why the Haskell standard library defines the wrapper types <code>Sum</code>, <code>Product</code>, <code>Max</code> and <code>Min</code>. These types are from the <code>Data.Monoid</code> and <code>Data.Semigroup</code> modules.</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb376-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span></a>
<a class="sourceLine" id="cb376-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Data.Semigroup</span></a></code></pre></div>
<p>They work like this:</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb377-1" data-line-number="1"><span class="dt">Max</span> <span class="dv">3</span> <span class="fu">&lt;&gt;</span> <span class="dt">Max</span> <span class="dv">4</span> <span class="fu">==&gt;</span> <span class="dt">Max</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb377-2" data-line-number="2"><span class="dt">Min</span> <span class="dv">3</span> <span class="fu">&lt;&gt;</span> <span class="dt">Min</span> <span class="dv">4</span> <span class="fu">==&gt;</span> <span class="dt">Min</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb377-3" data-line-number="3"><span class="dt">Sum</span> <span class="dv">3</span> <span class="fu">&lt;&gt;</span> <span class="dt">Sum</span> <span class="dv">4</span> <span class="fu">==&gt;</span> <span class="dt">Sum</span> <span class="dv">7</span></a>
<a class="sourceLine" id="cb377-4" data-line-number="4"><span class="dt">Product</span> <span class="dv">3</span> <span class="fu">&lt;&gt;</span> <span class="dt">Product</span> <span class="dv">4</span> <span class="fu">==&gt;</span> <span class="dt">Product</span> <span class="dv">12</span></a></code></pre></div>
<p>This is another benefit of boxing things: being able to declare different type class instances!</p>
<p>The reason we want both a neutral element and an associative binary operator is that those are the exact two things we need in order to <em>reduce</em> or <em>fold</em> multiple elements into one value. This is the job of:</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb378-1" data-line-number="1">mconcat<span class="ot"> ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>Sidenote: one way to define <code>mconcat</code> is <code>foldr (&lt;&gt;) mempty</code>. Do you remember <code>foldr</code>?</p>
<p>Let’s look at why we need the properties of <code>Monoid</code> to implement <code>mconcat</code>. Firstly, we need <code>mempty</code> to handle empty lists:</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb379-1" data-line-number="1">mconcat []<span class="ot"> ::</span> <span class="dt">Sum</span> <span class="dt">Int</span>          <span class="fu">==&gt;</span>  <span class="dt">Sum</span> <span class="dv">0</span></a></code></pre></div>
<p>Secondly, we need associativity to be able to reduce a list <code>[x,y,z]</code> to a unique value. If <code>&lt;&gt;</code> were not associative, we would have two possible values for <code>mconcat [x,y,z]</code>, namely <code>(x&lt;&gt;y)&lt;&gt;z</code> and <code>x&lt;&gt;(y&lt;&gt;z)</code>.</p>
<h3 id="why"><span class="header-section-number">7.3.2</span> Why?</h3>
<p>What use is this <code>Monoid</code> class? Can’t we just write <code>1 + 2</code> instead of <code>Sum 1 &lt;&gt; Sum 2</code>? We can, yes, but some library functions work on all <code>Monoid</code> types. The most useful one is <code>foldMap</code>:</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb380-1" data-line-number="1">foldMap<span class="ot"> ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m</a></code></pre></div>
<p>That type signature looks scary, but concrete cases are simpler:</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb381-1" data-line-number="1">foldMap <span class="dt">Max</span> [<span class="dv">1</span><span class="ot">::</span><span class="dt">Int</span>,<span class="dv">4</span>,<span class="dv">2</span>]  <span class="fu">==&gt;</span>  <span class="dt">Max</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb381-2" data-line-number="2">foldMap <span class="dt">Product</span> [<span class="dv">1</span><span class="ot">::</span><span class="dt">Int</span>,<span class="dv">4</span>,<span class="dv">2</span>]  <span class="fu">==&gt;</span>  <span class="dt">Product</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb381-3" data-line-number="3"><span class="co">-- We need the ::Int to avoid an &quot;Ambiguous type variable&quot; error when printing the result</span></a></code></pre></div>
<p>Let’s break down that type. We know that an example of a <code>Foldable t =&gt; t a</code> type is <code>[a]</code>, so we can rewrite the type as</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb382-1" data-line-number="1"><span class="ot">foldMap&#39; ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m</a></code></pre></div>
<p>We can build this function out of functions we already know:</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb383-1" data-line-number="1">foldMap&#39; f xs <span class="fu">=</span> mconcat (map f xs)</a></code></pre></div>
<p>Oh, by the way, thanks to the <code>(Monoid a, Monoid b) =&gt; Monoid (a,b)</code> instance we can even compute the maximum and product in one pass:</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb384-1" data-line-number="1">foldMap (\x <span class="ot">-&gt;</span> (<span class="dt">Max</span> x, <span class="dt">Product</span> x)) [<span class="dv">1</span><span class="ot">::</span><span class="dt">Int</span>,<span class="dv">4</span>,<span class="dv">2</span>]  <span class="fu">==&gt;</span>  (<span class="dt">Max</span> <span class="dv">4</span>, <span class="dt">Product</span> <span class="dv">8</span>)</a></code></pre></div>
<p>Note, you don’t need to use monoids in your own code, but you’ll eventually bump into them when using Haskell libraries so it’s good to know what they are.</p>
<h3 id="how"><span class="header-section-number">7.3.3</span> How?</h3>
<p>Due to various historical and performance reasons, the definition of the <code>Monoid</code> class isn’t just</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb385-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb385-2" data-line-number="2"><span class="ot">  (&lt;&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb385-3" data-line-number="3"><span class="ot">  mempty ::</span> a</a></code></pre></div>
<p>although you can mostly pretend it is. The actual definition consists of two classes with a number of methods:</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb386-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb386-2" data-line-number="2">  <span class="co">-- | An associative operation.</span></a>
<a class="sourceLine" id="cb386-3" data-line-number="3"><span class="ot">  (&lt;&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb386-4" data-line-number="4"></a>
<a class="sourceLine" id="cb386-5" data-line-number="5">  <span class="co">-- Combine elements of a nonempty list with &lt;&gt;</span></a>
<a class="sourceLine" id="cb386-6" data-line-number="6"><span class="ot">  sconcat ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb386-7" data-line-number="7">  sconcat as <span class="fu">=</span> <span class="fu">...</span> <span class="co">-- default implementation omitted</span></a>
<a class="sourceLine" id="cb386-8" data-line-number="8"></a>
<a class="sourceLine" id="cb386-9" data-line-number="9">  <span class="co">-- Combine a value with itself using &lt;&gt;, n times</span></a>
<a class="sourceLine" id="cb386-10" data-line-number="10"><span class="ot">  stimes ::</span> <span class="dt">Integral</span> b <span class="ot">=&gt;</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb386-11" data-line-number="11">  stimes n x <span class="fu">=</span> <span class="fu">...</span> <span class="co">-- default implementation omitted</span></a></code></pre></div>
<div class="sourceCode" id="cb387"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb387-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb387-2" data-line-number="2"><span class="ot">  mempty  ::</span> a</a>
<a class="sourceLine" id="cb387-3" data-line-number="3"></a>
<a class="sourceLine" id="cb387-4" data-line-number="4"><span class="ot">  mappend ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb387-5" data-line-number="5">  mappend <span class="fu">=</span> (<span class="fu">&lt;&gt;</span>)</a>
<a class="sourceLine" id="cb387-6" data-line-number="6"></a>
<a class="sourceLine" id="cb387-7" data-line-number="7">  <span class="co">-- Combine elements of a list with &lt;&gt;</span></a>
<a class="sourceLine" id="cb387-8" data-line-number="8"><span class="ot">  mconcat ::</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb387-9" data-line-number="9">  mconcat <span class="fu">=</span> <span class="fu">...</span> <span class="co">-- default implementation omitted</span></a></code></pre></div>
<p>As you can see, all the operations except <code>&lt;&gt;</code> and <code>mempty</code> have default definitions, so a normal <code>Monoid</code> instance declaration looks just like this:</p>
<div class="sourceCode" id="cb388"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb388-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">MyType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb388-2" data-line-number="2">  x <span class="fu">&lt;&gt;</span> y <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb388-3" data-line-number="3"></a>
<a class="sourceLine" id="cb388-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">MyType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb388-5" data-line-number="5">  mempty <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<h2 id="open-and-closed-abstractions"><span class="header-section-number">7.4</span> Open and closed abstractions</h2>
<p>A question novice Haskell programmers often ask (or at least should ask!) is: when should I use type classes? This section offers one answer.</p>
<p>Let’s look at a concrete example. A vehicle can be either a car or an airplane. We can model this with algebraic datatypes (as we’ve seen earlier in this chapter), but also with type classes. Here’s the datatype version:</p>
<div class="sourceCode" id="cb389"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb389-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Vehicle</span> <span class="fu">=</span> <span class="dt">Car</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Airplane</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb389-2" data-line-number="2"></a>
<a class="sourceLine" id="cb389-3" data-line-number="3"><span class="ot">sound ::</span> <span class="dt">Vehicle</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb389-4" data-line-number="4">sound (<span class="dt">Car</span> _) <span class="fu">=</span> <span class="st">&quot;brum brum&quot;</span></a>
<a class="sourceLine" id="cb389-5" data-line-number="5">sound (<span class="dt">Airplane</span> _) <span class="fu">=</span> <span class="st">&quot;zooooom&quot;</span></a></code></pre></div>
<p>Here’s the class version. Note how each case gets its own datatype, which are collected together in a type class.</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb390-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Car</span> <span class="fu">=</span> <span class="dt">Car</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb390-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Airplane</span> <span class="fu">=</span> <span class="dt">Airplane</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb390-3" data-line-number="3"></a>
<a class="sourceLine" id="cb390-4" data-line-number="4"><span class="kw">class</span> <span class="dt">VehicleClass</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb390-5" data-line-number="5"><span class="ot">  sound ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb390-6" data-line-number="6"></a>
<a class="sourceLine" id="cb390-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">VehicleClass</span> <span class="dt">Car</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb390-8" data-line-number="8">  sound (<span class="dt">Car</span> _) <span class="fu">=</span> <span class="st">&quot;brum brum&quot;</span></a>
<a class="sourceLine" id="cb390-9" data-line-number="9"></a>
<a class="sourceLine" id="cb390-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">VehicleClass</span> <span class="dt">Airplane</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb390-11" data-line-number="11">  sound (<span class="dt">Airplane</span> _) <span class="fu">=</span> <span class="st">&quot;zooooom&quot;</span></a></code></pre></div>
<p>What is the difference between these solutions? The data-based solution is <em>closed</em>, meaning the set of cases is fixed and we can handle all of them in one place. The class-based solution is <em>open</em>, meaning we can add new cases, even in other modules.</p>
<p>An open abstraction is nice when we want extensibility. In the class-based solution, another module could define a bike:</p>
<div class="sourceCode" id="cb391"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb391-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bike</span> <span class="fu">=</span> <span class="dt">Bike</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb391-2" data-line-number="2"></a>
<a class="sourceLine" id="cb391-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">VehicleClass</span> <span class="dt">Bike</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb391-4" data-line-number="4">  sound (<span class="dt">Bike</span> _) <span class="fu">=</span> <span class="st">&quot;whirrr&quot;</span></a></code></pre></div>
<p>A closed abstraction is good when we want to know that we’ve handled all cases, consider for example the function <code>canCollide</code> which checks whether two vehicles can collide:</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb392-1" data-line-number="1"><span class="ot">canCollide ::</span> <span class="dt">Vehicle</span> <span class="ot">-&gt;</span> <span class="dt">Vehicle</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb392-2" data-line-number="2">canCollide (<span class="dt">Car</span> _)      (<span class="dt">Car</span> _)      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb392-3" data-line-number="3">canCollide (<span class="dt">Airplane</span> _) (<span class="dt">Airplane</span> _) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb392-4" data-line-number="4">canCollide _            _            <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>This would be very hard to implement reliably in the class-based solution. Consider for example how collision checks between <code>Bike</code>s and <code>Car</code>s would get handled.</p>
<h2 id="modeling-with-languages"><span class="header-section-number">7.5</span> Modeling with languages</h2>
<p>Sometimes it’s useful to implement a mini programming language for describing parts of your software. The fancy term for these is an <em>Embedded Domain-Specific Language (EDSL)</em>. Haskell is well suited to modeling and interpreting languages. The expressions of the language are represented using (often recursive) algebraic data types. The language can be <em>interpreted</em> (that is, evaluated or run) by a recursive function.</p>
<p>Here’s an example of a language for describing price computations for products in a web shop.</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb393-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Discount</span> <span class="fu">=</span> <span class="dt">DiscountPercent</span> <span class="dt">Int</span>         <span class="co">-- A percentage discount</span></a>
<a class="sourceLine" id="cb393-2" data-line-number="2">              <span class="fu">|</span> <span class="dt">DiscountConstant</span> <span class="dt">Int</span>        <span class="co">-- A constant discount</span></a>
<a class="sourceLine" id="cb393-3" data-line-number="3">              <span class="fu">|</span> <span class="dt">MinimumPrice</span> <span class="dt">Int</span>            <span class="co">-- Set a minimum price</span></a>
<a class="sourceLine" id="cb393-4" data-line-number="4">              <span class="fu">|</span> <span class="dt">ForCustomer</span> <span class="dt">String</span> <span class="dt">Discount</span> <span class="co">-- Discounts can be conditional</span></a>
<a class="sourceLine" id="cb393-5" data-line-number="5">              <span class="fu">|</span> <span class="dt">Many</span> [<span class="dt">Discount</span>]             <span class="co">-- Apply a number of discounts in row</span></a></code></pre></div>
<p>The language is interpreted by the function <code>applyDiscount</code> that takes a customer name, a price, a discount, and returns a price.</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb394-1" data-line-number="1"><span class="ot">applyDiscount ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Discount</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb394-2" data-line-number="2">applyDiscount _        price (<span class="dt">DiscountPercent</span> percent) <span class="fu">=</span> price <span class="fu">-</span> (price <span class="fu">*</span> percent) <span class="ot">`div`</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb394-3" data-line-number="3">applyDiscount _        price (<span class="dt">DiscountConstant</span> discount) <span class="fu">=</span> price <span class="fu">-</span> discount</a>
<a class="sourceLine" id="cb394-4" data-line-number="4">applyDiscount _        price (<span class="dt">MinimumPrice</span> minPrice) <span class="fu">=</span> max price minPrice</a>
<a class="sourceLine" id="cb394-5" data-line-number="5">applyDiscount customer price (<span class="dt">ForCustomer</span> target discount)</a>
<a class="sourceLine" id="cb394-6" data-line-number="6">    <span class="fu">|</span> customer <span class="fu">==</span> target  <span class="fu">=</span> applyDiscount customer price discount</a>
<a class="sourceLine" id="cb394-7" data-line-number="7">    <span class="fu">|</span> otherwise           <span class="fu">=</span> price</a>
<a class="sourceLine" id="cb394-8" data-line-number="8">applyDiscount customer price (<span class="dt">Many</span> discounts) <span class="fu">=</span> go price discounts</a>
<a class="sourceLine" id="cb394-9" data-line-number="9">  <span class="kw">where</span> go p [] <span class="fu">=</span> p</a>
<a class="sourceLine" id="cb394-10" data-line-number="10">        go p (d<span class="fu">:</span>ds) <span class="fu">=</span> go (applyDiscount customer p d) ds</a></code></pre></div>
<p>Here we apply a discount chain of -50%, -$30 with a minimum price of $35:</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb395-1" data-line-number="1">applyDiscount <span class="st">&quot;Bob&quot;</span> <span class="dv">120</span> (<span class="dt">DiscountPercent</span> <span class="dv">50</span>)</a>
<a class="sourceLine" id="cb395-2" data-line-number="2">  <span class="fu">==&gt;</span> <span class="dv">60</span></a>
<a class="sourceLine" id="cb395-3" data-line-number="3">applyDiscount <span class="st">&quot;Bob&quot;</span> <span class="dv">60</span> (<span class="dt">DiscountConstant</span> <span class="dv">30</span>)</a>
<a class="sourceLine" id="cb395-4" data-line-number="4">  <span class="fu">==&gt;</span> <span class="dv">30</span></a>
<a class="sourceLine" id="cb395-5" data-line-number="5">applyDiscount <span class="st">&quot;Bob&quot;</span> <span class="dv">30</span> (<span class="dt">MinimumPrice</span> <span class="dv">35</span>)</a>
<a class="sourceLine" id="cb395-6" data-line-number="6">  <span class="fu">==&gt;</span> <span class="dv">35</span></a>
<a class="sourceLine" id="cb395-7" data-line-number="7">applyDiscount <span class="st">&quot;Bob&quot;</span> <span class="dv">120</span> (<span class="dt">Many</span> [<span class="dt">DiscountPercent</span> <span class="dv">50</span>, <span class="dt">DiscountConstant</span> <span class="dv">30</span>, <span class="dt">MinimumPrice</span> <span class="dv">35</span>])</a>
<a class="sourceLine" id="cb395-8" data-line-number="8">  <span class="fu">==&gt;</span> <span class="dv">35</span></a></code></pre></div>
<p>Here we have different discounts for Ssarah and Yvonne:</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb396-1" data-line-number="1">applyDiscount <span class="st">&quot;Yvonne&quot;</span> <span class="dv">100</span> (<span class="dt">Many</span> [<span class="dt">ForCustomer</span> <span class="st">&quot;Yvonne&quot;</span> (<span class="dt">DiscountConstant</span> <span class="dv">10</span>), <span class="dt">ForCustomer</span> <span class="st">&quot;Ssarah&quot;</span> (<span class="dt">DiscountConstant</span> <span class="dv">20</span>)])</a>
<a class="sourceLine" id="cb396-2" data-line-number="2">  <span class="fu">==&gt;</span> <span class="dv">90</span></a>
<a class="sourceLine" id="cb396-3" data-line-number="3">applyDiscount <span class="st">&quot;Ssarah&quot;</span> <span class="dv">100</span> (<span class="dt">Many</span> [<span class="dt">ForCustomer</span> <span class="st">&quot;Yvonne&quot;</span> (<span class="dt">DiscountConstant</span> <span class="dv">10</span>), <span class="dt">ForCustomer</span> <span class="st">&quot;Ssarah&quot;</span> (<span class="dt">DiscountConstant</span> <span class="dv">20</span>)])</a>
<a class="sourceLine" id="cb396-4" data-line-number="4">  <span class="fu">==&gt;</span> <span class="dv">80</span></a></code></pre></div>
<p>As you can see, even a simple <code>Discount</code> type can generate complex behaviours because it is self-referential (recursive). Using <code>Discount</code> we are able to represent the discount logic of our webshop as <em>data</em> instead of writing code.</p>
<p>There are multiple reasons for representing logic as data instead of code. Unlike code, data can easily be stored in a file or database, or even transmitted over the network. We can also use the same data for multiple purposes, for exaple we could visualize the discount chains in an administration user interface.</p>
<!-- ## TODO: Quiz -->
<h2 id="exercises-6"><span class="header-section-number">7.6</span> Exercises</h2>
<ul>
<li><a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set7.hs">Set7</a></li>
</ul>
<p>Remember to give <a href="https://forms.gle/YCo2jAaUTg9vER7G6">feedback</a>!</p>
<h1 id="lecture-8-the-aftertaste"><span class="header-section-number">8</span> Lecture 8: The Aftertaste</h1>
<h2 id="a-taste-of-io"><span class="header-section-number">8.1</span> A taste of IO</h2>
<p>This course has been centered around pure functional programming. We’ve done lots of arithmetic, reversed lists, worked with binary trees, but so far we haven’t been able to affect the world outside our GHCi.</p>
<p>Things like reading input, writing to a file, or talking over the network are <em>side effects</em>. Side effects can’t be represented with pure functional code. A function like</p>
<div class="sourceCode" id="cb397"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb397-1" data-line-number="1"><span class="ot">readInputFromTheUser ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a></code></pre></div>
<p>can’t be pure, because if it were, <code>readInputFromUser &quot;What is your name?&quot;</code> would always have to return the same result. However, representing side-effects and impurity in a pure language <em>is</em> possible. There are many ways of doing it, and the Haskell way is to use <em>Monads</em>.</p>
<p>Monads are reputedly difficult to understand. That is probably because they are so abstract. I think it’s best to focus on practical and concrete cases first. Here’s a taste of the <code>IO</code> Monad, which you can use for all sorts of side effects in Haskell.</p>
<p>Let’s start!</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb398-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t getLine</a>
<a class="sourceLine" id="cb398-2" data-line-number="2">getLine<span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb398-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> line <span class="ot">&lt;-</span> getLine</a></code></pre></div>
<pre><code>another line</code></pre>
<div class="sourceCode" id="cb400"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb400-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t line</a>
<a class="sourceLine" id="cb400-2" data-line-number="2"><span class="ot">line ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb400-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> line</a>
<a class="sourceLine" id="cb400-4" data-line-number="4"><span class="st">&quot;another line&quot;</span></a>
<a class="sourceLine" id="cb400-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> reverse line</a>
<a class="sourceLine" id="cb400-6" data-line-number="6"><span class="st">&quot;enil rehtona&quot;</span></a></code></pre></div>
<p>What we’ve seen here is the <em>IO action</em> <code>getLine</code>. It has type <code>IO String</code>. This means that GHCi can <em>execute</em> the action to produce a value of type <code>String</code>. When we enter <code>line &lt;- getLine</code> into GHCi, we mean:</p>
<blockquote>
<p>Execute the IO action <code>getLine</code>, and give the result the name <code>line</code>.</p>
</blockquote>
<p>After we’ve received <code>line</code>, it’s a pure <code>String</code> value and we can work with it normally.</p>
<p>Some IO actions take parameters. For example <code>putStrLn :: String -&gt; IO ()</code> takes a <code>String</code> and returns an <code>IO</code> action that prints that string. The <code>()</code> type is a special type that only has one value, <code>()</code>. In this case <code>IO ()</code> means that this IO always produces the same empty value <code>()</code>. You can run IO actions by just</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb401-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t putStrLn</a>
<a class="sourceLine" id="cb401-2" data-line-number="2">putStrLn<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb401-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t putStrLn <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb401-4" data-line-number="4">putStrLn <span class="st">&quot;hello&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb401-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> val <span class="ot">&lt;-</span> putStrLn <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb401-6" data-line-number="6">hello</a>
<a class="sourceLine" id="cb401-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> val</a>
<a class="sourceLine" id="cb401-8" data-line-number="8">()</a></code></pre></div>
<p>If you don’t need the return value of an IO action, you can run it <em>in GHCi</em> without the <code>&lt;-</code>:</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb402-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> putStrLn <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb402-2" data-line-number="2">hello</a></code></pre></div>
<p>You can build your own IO actions by combining other actions with <em>do-notation</em>. A <code>do</code> block lists IO actions that are executed in order.</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb403-1" data-line-number="1"><span class="ot">printTwoThings ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb403-2" data-line-number="2">printTwoThings <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb403-3" data-line-number="3">  putStrLn <span class="st">&quot;Hello!&quot;</span></a>
<a class="sourceLine" id="cb403-4" data-line-number="4">  putStrLn <span class="st">&quot;How are you?&quot;</span></a>
<a class="sourceLine" id="cb403-5" data-line-number="5"></a>
<a class="sourceLine" id="cb403-6" data-line-number="6"><span class="ot">greet ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb403-7" data-line-number="7">greet <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb403-8" data-line-number="8">  putStrLn <span class="st">&quot;What&#39;s your name?&quot;</span></a>
<a class="sourceLine" id="cb403-9" data-line-number="9">  name <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb403-10" data-line-number="10">  putStrLn (<span class="st">&quot;Hello, &quot;</span> <span class="fu">++</span> name)</a></code></pre></div>
<div class="sourceCode" id="cb404"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb404-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> printTwoThings</a>
<a class="sourceLine" id="cb404-2" data-line-number="2"><span class="dt">Hello</span><span class="fu">!</span></a>
<a class="sourceLine" id="cb404-3" data-line-number="3"><span class="dt">How</span> are you<span class="fu">?</span></a>
<a class="sourceLine" id="cb404-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> greet</a>
<a class="sourceLine" id="cb404-5" data-line-number="5"><span class="dt">What&#39;s</span> your name<span class="fu">?</span></a>
<a class="sourceLine" id="cb404-6" data-line-number="6"><span class="dt">Seraphim</span></a>
<a class="sourceLine" id="cb404-7" data-line-number="7"><span class="dt">Hello</span>, <span class="dt">Seraphim</span></a></code></pre></div>
<h3 id="what-about-purity"><span class="header-section-number">8.1.1</span> What about purity?</h3>
<p>It feels as if we can just do side effects where ever we want with these IO actions. However, it’s important to remember the distinction between <em>defining</em> an IO action and <em>executing</em> it.</p>
<p>Let’s try to print while mapping over a list</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb405-1" data-line-number="1"><span class="ot">printAndIncrement ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb405-2" data-line-number="2">printAndIncrement x <span class="fu">=</span> x<span class="fu">+</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb405-3" data-line-number="3">  <span class="kw">where</span> action <span class="fu">=</span> putStrLn <span class="st">&quot;got a number!&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb406"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb406-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> map printAndIncrement [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb406-2" data-line-number="2">[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a></code></pre></div>
<p>This didn’t print anything, because even though we defined our <code>action</code>, it wasn’t given to GHCi for execution. Because <code>printAndIncrement</code> returns an <code>Int</code>, it can’t return an action. Ok, let’s try another approach:</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb407-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> length (map putStrLn [<span class="st">&quot;string1&quot;</span>,<span class="st">&quot;string2&quot;</span>])</a>
<a class="sourceLine" id="cb407-2" data-line-number="2"><span class="dv">2</span></a></code></pre></div>
<p>That didn’t print anything either! Let’s see why:</p>
<div class="sourceCode" id="cb408"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb408-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t map putStrLn [<span class="st">&quot;string1&quot;</span>,<span class="st">&quot;string2&quot;</span>]</a>
<a class="sourceLine" id="cb408-2" data-line-number="2">map putStrLn [<span class="st">&quot;string1&quot;</span>,<span class="st">&quot;string2&quot;</span>]<span class="ot"> ::</span> [<span class="dt">IO</span> ()]</a>
<a class="sourceLine" id="cb408-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t length (map putStrLn [<span class="st">&quot;string1&quot;</span>,<span class="st">&quot;string2&quot;</span>])</a>
<a class="sourceLine" id="cb408-4" data-line-number="4">length (map putStrLn [<span class="st">&quot;string1&quot;</span>,<span class="st">&quot;string2&quot;</span>])<span class="ot"> ::</span> <span class="dt">Int</span></a></code></pre></div>
<p>We generated a list of IO actions and computed the value of the list. Defining IO actions is pure, it’s <em>running</em> them that causes side effects. Since the type of our expression was <code>Int</code>, no <code>IO</code> actions could land in GHCi and be executed.</p>
<p>If we instead return an IO action, it does get run:</p>
<div class="sourceCode" id="cb409"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb409-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t head (map putStrLn [<span class="st">&quot;string1&quot;</span>,<span class="st">&quot;string2&quot;</span>])</a>
<a class="sourceLine" id="cb409-2" data-line-number="2">head (map putStrLn [<span class="st">&quot;string1&quot;</span>,<span class="st">&quot;string2&quot;</span>])<span class="ot"> ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb409-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> head (map putStrLn [<span class="st">&quot;string1&quot;</span>,<span class="st">&quot;string2&quot;</span>])</a>
<a class="sourceLine" id="cb409-4" data-line-number="4">string1</a></code></pre></div>
<p>Here too, the code that produces the action <code>putStrLn &quot;string1&quot;</code> is pure, it’s only after the IO action is executed by GHCi that we see the printed string. And as you can see, the other IO action, <code>putStrLn &quot;string2&quot;</code>, never got run.</p>
<p>If this feels complicated, don’t worry. We’ll get back to this on part 2 of the course.</p>
<h3 id="what-about-haskell-programs"><span class="header-section-number">8.1.2</span> What about Haskell programs?</h3>
<p>We know that GHCi can run IO actions. What about actual Haskell programs? The way Haskell programs work is that the IO action called <code>main</code> gets executed when the program is run. Recall our example program from Lecture 1.</p>
<div class="sourceCode" id="cb410"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb410-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Gold</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb410-2" data-line-number="2"></a>
<a class="sourceLine" id="cb410-3" data-line-number="3"><span class="co">-- The golden ratio</span></a>
<a class="sourceLine" id="cb410-4" data-line-number="4"><span class="ot">phi ::</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb410-5" data-line-number="5">phi <span class="fu">=</span> (sqrt <span class="dv">5</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">/</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb410-6" data-line-number="6"></a>
<a class="sourceLine" id="cb410-7" data-line-number="7"><span class="ot">polynomial ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb410-8" data-line-number="8">polynomial x <span class="fu">=</span> x<span class="fu">^</span><span class="dv">2</span> <span class="fu">-</span> x <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb410-9" data-line-number="9"></a>
<a class="sourceLine" id="cb410-10" data-line-number="10">f x <span class="fu">=</span> polynomial (polynomial x)</a>
<a class="sourceLine" id="cb410-11" data-line-number="11"></a>
<a class="sourceLine" id="cb410-12" data-line-number="12">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb410-13" data-line-number="13">  print (polynomial phi)</a>
<a class="sourceLine" id="cb410-14" data-line-number="14">  print (f phi)</a></code></pre></div>
<p>Here we see some pure code and a <code>main</code> IO action that prints two things (<code>print</code> is just <code>putStrLn</code> combined with <code>show</code>).</p>
<p>We can place this code in a file called <code>Gold.hs</code>, compile it into an executable, and run it:</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb411-1" data-line-number="1">$ <span class="ex">ghc</span> -main-is Gold Gold.hs</a>
<a class="sourceLine" id="cb411-2" data-line-number="2">[<span class="ex">1</span> of 1] Compiling Gold             ( Gold.hs, Gold.o )</a>
<a class="sourceLine" id="cb411-3" data-line-number="3"><span class="ex">Linking</span> Gold ...</a>
<a class="sourceLine" id="cb411-4" data-line-number="4">$ <span class="ex">./Gold</span></a>
<a class="sourceLine" id="cb411-5" data-line-number="5"><span class="ex">0.0</span></a>
<a class="sourceLine" id="cb411-6" data-line-number="6"><span class="ex">-1.0</span></a></code></pre></div>
<h2 id="summary"><span class="header-section-number">8.2</span> Summary</h2>
<p>So far, we’ve learned about Haskell’s syntax and types, quite a bit of functional programming and about some language features like type classes.</p>
<p>We’ve also seen some type-oriented programming, and even gotten a taste of I/O in Haskell.</p>
<p>Now you know how to write a real computer program in Haskell, but there’s still much to learn.</p>
<h2 id="what-next"><span class="header-section-number">8.3</span> What next?</h2>
<p>We’re hoping to have Part 2 of the course ready soon. Part 2 will cover topics like Monads, IO and how Haskell works under the hood. We’ll also get to do some real world programming with networks and databases. Oh and testing in Haskell is also covered.</p>
<p>While you’re waiting for that, here are some Haskell resources you can study:</p>
<ul>
<li><a href="http://book.realworldhaskell.org/read/">Real World Haskell</a> - free e-book on advanced topics</li>
<li><a href="http://dev.stephendiehl.com/hask/">What I Wish I Knew When Learning Haskell</a></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell">The Haskell Wikibook</a></li>
<li><a href="https://www.haskell.org/">The Haskell Website</a> has links to talks and presentations</li>
</ul>
<p>I also recommend working on some programming problems in Haskell, like the ones from:</p>
<ul>
<li><a href="https://adventofcode.com/2019/events">Advent of Code</a> – nice varying puzzles, start off easy and get harder</li>
<li><a href="https://www.spoj.com/">Sphere Online Judge</a> – algorithm problems, good variety of difficulties</li>
<li><a href="https://projecteuler.net/">Project Euler</a> – mathematical programming puzzles</li>
</ul>
<p>You can also keep extending your final project and maybe generate some cool art in Haskell.</p>
<p>In any case – thank you so much for tagging along, and we hope you have a great rest of the year!</p>
<h2 id="final-project-graphics"><span class="header-section-number">8.4</span> Final project: graphics</h2>
<p>Open up the exercise file <a href="https://github.com/moocfi/haskell-mooc/blob/master/exercises/Set8.hs"><code>Set8.hs</code></a> and follow the instructions there. Have fun!</p>
<p>Remember to give <a href="https://forms.gle/YCo2jAaUTg9vER7G6">feedback</a>!</p>
<h2 id="acknowledgements"><span class="header-section-number">8.5</span> Acknowledgements</h2>
<p>Thanks to the whole Haskell Mooc team, especially</p>
<ul>
<li>John Lång for help on the material</li>
<li>Antti Laaksonen for setting up the course and helping with arrangements</li>
</ul>
</div>
</div>
</body>
</html>
